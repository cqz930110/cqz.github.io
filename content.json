{"meta":{"title":"cqzhong's blog","subtitle":"曹庆中","description":"学如逆水行舟,不进则退。心似平原走马,易放难追。","author":"曹庆中","url":"https://www.cqzhong.cn","root":"/"},"pages":[{"title":"标签","date":"2018-02-28T14:34:28.000Z","updated":"2019-12-03T12:59:45.000Z","comments":false,"path":"tags/index.html","permalink":"https://www.cqzhong.cn/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-02-28T14:34:39.000Z","updated":"2019-12-03T13:00:47.000Z","comments":false,"path":"categories/index.html","permalink":"https://www.cqzhong.cn/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2018-02-28T14:34:22.000Z","updated":"2019-04-29T11:05:58.000Z","comments":true,"path":"about/index.html","permalink":"https://www.cqzhong.cn/about/index.html","excerpt":"","text":"没什么好介绍的了！ 希望写的文章大家能够喜欢~ 如果有啥意见的话。。。 我就在这里留个统一吐槽的地方~~ 啊哈哈~~"}],"posts":[{"title":"VScode格式化配置","slug":"VScode格式化配置","date":"2020-11-06T06:00:00.000Z","updated":"2020-11-03T10:21:34.570Z","comments":true,"path":"2020/11/06/VScode格式化配置/","link":"","permalink":"https://www.cqzhong.cn/2020/11/06/VScode格式化配置/","excerpt":"一、安装常用插件： Beautify、Eslint、Vetur、Prettier","text":"一、安装常用插件： Beautify、Eslint、Vetur、Prettier 二、setting.josn 配置 文件-首选项-设置-在 setting.josn 中编辑，打开这个 setting.josn 文件后将下面配置复制即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&#123; // tab 大小为2个空格 \"editor.tabSize\": 2, // 100 列后换行 \"editor.wordWrapColumn\": 100, // 保存时格式化 \"editor.formatOnSave\": true, // 开启 vscode 文件路径导航 \"breadcrumbs.enabled\": true, // prettier 设置语句末尾不加分号 \"prettier.semi\": false, // prettier 设置强制单引号 \"prettier.singleQuote\": true, // 选择 vue 文件中 template 的格式化工具 \"vetur.format.defaultFormatter.html\": \"prettyhtml\", // 显示 markdown 中英文切换时产生的特殊字符 \"editor.renderControlCharacters\": true, // 设置 eslint 保存时自动修复 \"eslint.autoFixOnSave\": true, // eslint 检测文件类型 \"eslint.validate\": [ \"javascript\", \"javascriptreact\", &#123; \"language\": \"html\", \"autoFix\": true &#125;, &#123; \"language\": \"vue\", \"autoFix\": true &#125; ], // vetur 的自定义设置 \"vetur.format.defaultFormatterOptions\": &#123; \"prettier\": &#123; \"singleQuote\": true, \"semi\": false &#125; &#125;, // 修改500ms后自动保存 \"editor.formatOnSaveTimeout\": 500, \"files.autoSave\": \"afterDelay\", \"files.autoSaveDelay\": 500, \"editor.codeActionsOnSaveTimeout\": 500, \"[javascript]\": &#123; \"editor.defaultFormatter\": \"vscode.typescript-language-features\" &#125;&#125; 三、配置.editorconfig 文件 项目根目录下找到.editorconfig 这个文件，然后复制下面配置即可 12345678910111213141516171819202122# https://editorconfig.orgroot = true # 根目录的配置文件，编辑器会由当前目录向上查找，如果找到 `roor = true` 的文件，则不再查找[*] # 匹配所有的文件indent_style = space # 空格缩进indent_size = 4 # 缩进空格为4个end_of_line = lf # 文件换行符是 linux 的 `\\n`charset = utf-8 # 文件编码是 utf-8trim_trailing_whitespace = true # 不保留行末的空格insert_final_newline = true # 文件末尾添加一个空行curly_bracket_next_line = false # 大括号不另起一行spaces_around_operators = true # 运算符两遍都有空格indent_brace_style = 1tbs # 条件语句格式是 1tbs[*.js] # 对所有的 js 文件生效quote_type = single # 字符串使用单引号[*.&#123;html,less,css,json&#125;] # 对所有 html, less, css, json 文件生效quote_type = double # 字符串使用双引号[package.json] # 对 package.json 生效indent_size = 2 # 使用2个空格缩进 setting.json 参考 setting.json 配置一 ** 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&#123; \"editor.tabSize\": 2, // \"editor.formatOnPaste\": true, \"editor.acceptSuggestionOnCommitCharacter\": false, \"eslint.validate\": [ \"javascript\", \"javascriptreact\", \"vue-html\", \"vue\", \"html\" ], /* prettier的配置 */ \"prettier.printWidth\": 120, // 超过最大值换行 \"prettier.tabWidth\": 2, // 缩进字节数 \"prettier.useTabs\": false, // 缩进使用tab \"prettier.semi\": false, // 句尾添加分号 \"prettier.singleQuote\": true, // 使用单引号代替双引号 \"prettier.proseWrap\": \"preserve\", // 默认值。因为使用了一些折行敏感型的渲染器（如GitHub comment）而按照markdown文本样式进行折行 \"prettier.arrowParens\": \"avoid\", // (x) =&gt; &#123;&#125; 箭头函数参数只有一个时是否要有小括号。avoid：省略括号 \"prettier.bracketSpacing\": true, // 在对象，数组括号与文字之间加空格 \"&#123; foo: bar &#125;\" \"prettier.endOfLine\": \"auto\", // 结尾是 \\n \\r \\n\\r auto \"prettier.htmlWhitespaceSensitivity\": \"ignore\", \"prettier.ignorePath\": \".prettierignore\", // 不使用prettier格式化的文件填写在项目的.prettierignore文件中 \"prettier.requireConfig\": false, // Require a \"prettierconfig\" to format prettier \"prettier.trailingComma\": \"none\", // 在对象或数组最后一个元素后面是否加逗号 \"[html]\": &#123; \"editor.defaultFormatter\": \"esbenp.prettier-vscode\" &#125;, \"[css]\": &#123; \"editor.defaultFormatter\": \"esbenp.prettier-vscode\" &#125;, \"[scss]\": &#123; \"editor.defaultFormatter\": \"esbenp.prettier-vscode\" &#125;, \"[javascript]\": &#123; \"editor.defaultFormatter\": \"esbenp.prettier-vscode\" &#125;, \"[vue]\": &#123; \"editor.defaultFormatter\": \"esbenp.prettier-vscode\" &#125;, \"[json]\": &#123; \"editor.defaultFormatter\": \"esbenp.prettier-vscode\" &#125;, \"files.associations\": &#123; \"*.vue\": \"vue\" &#125;, \"window.openFilesInNewWindow\": \"default\", \"window.openFoldersInNewWindow\": \"on\", \"explorer.confirmDragAndDrop\": false, \"explorer.confirmDelete\": false, \"workbench.iconTheme\": \"vscode-icons\", // 两者会在格式化js时冲突，所以需要关闭默认js格式化程序 \"javascript.format.enable\": false, \"typescript.format.enable\": false, \"vetur.format.defaultFormatter.html\": \"none\", // js/ts程序用eslint，防止vetur中的prettier与eslint格式化冲突 \"vetur.format.defaultFormatter.js\": \"none\", \"vetur.format.defaultFormatter.ts\": \"none\", \"leetcode.endpoint\": \"leetcode-cn\", \"editor.codeActionsOnSave\": null, \"leetcode.workspaceFolder\": \"C:\\\\Users\\\\EDZ\\\\.leetcode\", \"leetcode.defaultLanguage\": \"javascript\", \"sync.gist\": \"此处是---sync.gist 替换为自己的----\"&#125; ** setting.json 配置二 ** 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170&#123; // tab 大小为2个空格 \"editor.tabSize\": 2, // 编辑器换行 \"editor.wordWrap\": \"off\", // 保存时格式化 \"editor.formatOnSave\": false, // 添加 vue 支持 \"vetur.format.defaultFormatterOptions\": &#123; \"js-beautify-html\": &#123; \"wrap_attributes\": \"auto\" &#125;, \"prettyhtml\": &#123; \"printWidth\": 140, \"singleQuote\": false // 使用单引号代替双引号 &#125;, \"prettier\": &#123; \"semi\": false, // 句尾添加分号 \"singleQuote\": true, // 使用单引号代替双引号 \"printWidth\": 400, // 超过最大值换行 \"tabWidth\": 2, // 缩进字节数 \"useTabs\": false, // 缩进使用tab \"proseWrap\": \"preserve\", // // 默认值。因为使用了一些折行敏感型的渲染器（如GitHub comment）而按照markdown文本样式进行折行 \"arrowParens\": \"avoid\", // (x) =&gt; &#123;&#125; 箭头函数参数只有一个时是否要有小括号。avoid：省略括号 \"bracketSpacing\": true, // 在对象，数组括号与文字之间加空格 \"&#123; foo: bar &#125;\" \"endOfLine\": \"auto\", // 结尾是 \\n \\r \\n\\r auto \"htmlWhitespaceSensitivity\": \"ignore\", \"ignorePath\": \".prettierignore\", // 不使用prettier格式化的文件填写在项目的.prettierignore文件中 \"requireConfig\": false, // Require a \"prettierconfig\" to format prettier \"trailingComma\": \"none\" // 在对象或数组最后一个元素后面是否加逗号 &#125; &#125;, // 选择 vue 文件中 template 的格式化工具 // \"vetur.format.defaultFormatter.html\": \"js-beautify-html\", // \"vetur.format.defaultFormatter.js\": \"vscode-typescript\", \"vetur.validation.template\": true, /* prettier的配置 */ \"prettier.printWidth\": 400, // 超过最大值换行 \"prettier.tabWidth\": 2, // 缩进字节数 \"prettier.useTabs\": false, // 缩进使用tab \"prettier.semi\": false, // 句尾添加分号 \"prettier.singleQuote\": true, // 使用单引号代替双引号 \"prettier.proseWrap\": \"preserve\", // 默认值。因为使用了一些折行敏感型的渲染器（如GitHub comment）而按照markdown文本样式进行折行 \"prettier.arrowParens\": \"avoid\", // (x) =&gt; &#123;&#125; 箭头函数参数只有一个时是否要有小括号。avoid：省略括号 \"prettier.bracketSpacing\": true, // 在对象，数组括号与文字之间加空格 \"&#123; foo: bar &#125;\" \"prettier.endOfLine\": \"auto\", // 结尾是 \\n \\r \\n\\r auto \"prettier.htmlWhitespaceSensitivity\": \"ignore\", \"prettier.ignorePath\": \".prettierignore\", // 不使用prettier格式化的文件填写在项目的.prettierignore文件中 \"prettier.requireConfig\": false, // Require a \"prettierconfig\" to format prettier \"prettier.trailingComma\": \"none\", // 在对象或数组最后一个元素后面是否加逗号 \"[html]\": &#123; \"editor.defaultFormatter\": \"esbenp.prettier-vscode\" &#125;, \"[css]\": &#123; \"editor.defaultFormatter\": \"esbenp.prettier-vscode\" &#125;, \"[scss]\": &#123; \"editor.defaultFormatter\": \"esbenp.prettier-vscode\" &#125;, \"[javascript]\": &#123; \"editor.defaultFormatter\": \"esbenp.prettier-vscode\" &#125;, \"[json]\": &#123; \"editor.defaultFormatter\": \"esbenp.prettier-vscode\" &#125;, \"[vue]\": &#123; \"editor.defaultFormatter\": \"octref.vetur\" &#125;, \"[jsonc]\": &#123; \"editor.defaultFormatter\": \"esbenp.prettier-vscode\" &#125;, \"[markdown]\": &#123; \"editor.defaultFormatter\": \"esbenp.prettier-vscode\" &#125;, \"files.associations\": &#123; \"*.vue\": \"vue\", \"*.cjson\": \"jsonc\", \"*.wxss\": \"css\", \"*.wxs\": \"javascript\", \"*.less\": \"less\" &#125;, \"eslint.validate\": [ \"javascript\", \"javascriptreact\", \"vue-html\", \"vue\", \"html\" ], //让函数(名)和后面的括号之间加个空格 \"javascript.format.insertSpaceBeforeFunctionParenthesis\": false, \"emmet.includeLanguages\": &#123; \"wxml\": \"html\" &#125;, \"minapp-vscode.disableAutoConfig\": true, \"files.autoSave\": \"onWindowChange\", \"workbench.iconTheme\": \"vscode-icons-mac\", \"leetcode.endpoint\": \"leetcode-cn\", \"leetcode.hint.configWebviewMarkdown\": false, \"leetcode.workspaceFolder\": \"/Users/ggzj/.leetcode\", \"leetcode.defaultLanguage\": \"javascript\", \"emmet.excludeLanguages\": [\"markdown\"], \"javascript.updateImportsOnFileMove.enabled\": \"never\", \"fileheader.customMade\": &#123;&#125;, \"fileheader.cursorMode\": &#123; \"description\": \"\", \"param\": \"value\", \"return\": \"&#123;Any&#125;\" &#125;, \"fileheader.configObj\": &#123; \"createFileTime\": true, \"language\": &#123; \"languagetest\": &#123; \"head\": \"/$$\", \"middle\": \" $ @\", \"end\": \" $/\" &#125; &#125;, \"autoAdd\": false, \"autoAddLine\": 100, \"autoAlready\": true, \"annotationStr\": &#123; \"head\": \"/*\", \"middle\": \" * @\", \"end\": \" */\", \"use\": false &#125;, \"headInsertLine\": &#123; \"php\": 2 &#125;, \"beforeAnnotation\": &#123; \"文件后缀\": \"该文件后缀的头部注释之前添加某些内容\" &#125;, \"afterAnnotation\": &#123; \"文件后缀\": \"该文件后缀的头部注释之后添加某些内容\" &#125;, \"specialOptions\": &#123; \"特殊字段\": \"自定义比如LastEditTime/LastEditors\" &#125;, \"switch\": &#123; \"newlineAddAnnotation\": true &#125;, \"supportAutoLanguage\": [], \"prohibitAutoAdd\": [\"json\"], \"prohibitItemAutoAdd\": [ \"项目的全称, 整个项目禁止自动添加头部注释, 可以使用快捷键添加\" ], \"moveCursor\": true, \"dateFormat\": \"YYYY-MM-DD HH:mm:ss\", \"atSymbol\": \"@\", \"atSymbolObj\": &#123; \"文件后缀\": \"修改它的@符号\" &#125;, \"colon\": \": \", \"colonObj\": &#123; \"文件后缀\": \"修改它的冒号\" &#125;, \"filePathColon\": \"路径分隔符替换\", \"showErrorMessage\": false, \"wideSame\": false, \"wideNum\": 13, \"CheckFileChange\": false, \"createHeader\": true, \"useWorker\": false, \"designAddHead\": false, \"typeParam\": true &#125;, \"editor.codeActionsOnSave\": &#123; \"source.fixAll.eslint\": true &#125;&#125;","categories":[{"name":"其它","slug":"其它","permalink":"https://www.cqzhong.cn/categories/其它/"}],"tags":[{"name":"VSCode","slug":"VSCode","permalink":"https://www.cqzhong.cn/tags/VSCode/"}]},{"title":"Charles使用总结","slug":"Charles使用总结","date":"2020-11-03T10:00:00.000Z","updated":"2020-11-03T10:21:34.283Z","comments":true,"path":"2020/11/03/Charles使用总结/","link":"","permalink":"https://www.cqzhong.cn/2020/11/03/Charles使用总结/","excerpt":"一、下载安装配置 1、下载 Charles 2、安装 dmg、使用设备安装证书 Help-&gt; SSL Proxying 电脑安装证书，钥匙串- &gt; 选择证书-&gt;显示简介-&gt;始终信任 手机安装 ：和电脑处于统一局域网下，手动设置代理-&gt; chls.pro/ssl 安装证书 -&gt; 设置 -&gt;通用-&gt;安装描述文件-&gt; 关于本机-&gt; 证书信任设置-&gt;打开","text":"一、下载安装配置 1、下载 Charles 2、安装 dmg、使用设备安装证书 Help-&gt; SSL Proxying 电脑安装证书，钥匙串- &gt; 选择证书-&gt;显示简介-&gt;始终信任 手机安装 ：和电脑处于统一局域网下，手动设置代理-&gt; chls.pro/ssl 安装证书 -&gt; 设置 -&gt;通用-&gt;安装描述文件-&gt; 关于本机-&gt; 证书信任设置-&gt;打开 3、SSL Proxying Settings 配置(Host 和 Port 配置为通配) 二、Charles 模拟弱网 1、点击顶部导航 Proxy 2、选择 Throttle Seeings… 3、勾选 Enable Throttling 三、Charles 修改请求返回数据 1、找到要修改的请求, 并打上断点 2、再次发起要修改的请求(进入断点修改请求参数) 3、修改服务器返回内容","categories":[{"name":"其它","slug":"其它","permalink":"https://www.cqzhong.cn/categories/其它/"}],"tags":[{"name":"Charles","slug":"Charles","permalink":"https://www.cqzhong.cn/tags/Charles/"}]},{"title":"UI切图命名规范","slug":"UI切图命名规范","date":"2020-09-19T06:04:11.000Z","updated":"2020-11-03T10:21:35.024Z","comments":true,"path":"2020/09/19/UI切图命名规范/","link":"","permalink":"https://www.cqzhong.cn/2020/09/19/UI切图命名规范/","excerpt":"规范的命名方式可以提高开发人员的开发效率和整个团队的友好合作。 尽可能用最少的字符而又能完整的表达标识符的含义。","text":"规范的命名方式可以提高开发人员的开发效率和整个团队的友好合作。 尽可能用最少的字符而又能完整的表达标识符的含义。","categories":[{"name":"其它","slug":"其它","permalink":"https://www.cqzhong.cn/categories/其它/"}],"tags":[{"name":"规范","slug":"规范","permalink":"https://www.cqzhong.cn/tags/规范/"}]},{"title":"iOS-OC开发编码规范","slug":"iOS-OC开发编码规范","date":"2020-09-18T07:04:11.000Z","updated":"2020-11-03T10:21:35.662Z","comments":true,"path":"2020/09/18/iOS-OC开发编码规范/","link":"","permalink":"https://www.cqzhong.cn/2020/09/18/iOS-OC开发编码规范/","excerpt":"关于 Objective-C 的编码规范，苹果和谷歌都已经有很好的总结： Coding Guidelines for Cocoa Google Objective-C Style Guide","text":"关于 Objective-C 的编码规范，苹果和谷歌都已经有很好的总结： Coding Guidelines for Cocoa Google Objective-C Style Guide 代码规范 头文件 12345678910@import AVFoundation; # 标准组件库库头文件，一般为苹果sdk自带的 framework#import DKViewController.h # 非标准库头文件全局宏常量定义全局变量类定义 切记不要 #import &lt;AVFoundation/AVFoundation.h&gt;，在 iOS7 以后推荐用 @import module;来引用苹果的组件。 例子 12345678910111213@import AVFoundation;#import \"Test.h\"#define KTest 0static CGFloat const kALAnimationDelay = 0.1;static NSString *ID = @\"cell\";@interface MyClass ()@property (nonatomic) NSObject *test;@end 类结构 使用 #pragma mark – xxx 来分类方法 123456789101112131415#pragma mark – Getters and Setters # 懒加载#pragma mark - Life Cycle # 实例生命周期#pragma mark - Events # 事件#pragma mark - Public Methods # .h 公开方法#pragma mark - UITableViewDataSource # 系统代理方法#pragma mark - UITableViewDelegate#pragma mark - UITextFieldDelegate#pragma mark - Custom Delegates # 自定义代理(#pragma mark – Private Methods # 私有方法) Private Methods 正常情况下 ViewController 里面不应该写，能抽掉尽量抽掉 不是 delegate 方法的，也不是 event response 方法的，也不是 life cycle 方法的，就是 private method。 正常情况下 ViewController 里面是不会存在 private methods 的，这个 private methods 一般是用于日期换算、图片裁剪等的小功能。这种小功能要么把它写成一个 category，要么把它做成一个模块，哪怕这个模块只有一个函数也行。 ViewController 基本上是大部分业务的载体，本身代码已经相当复杂，所以跟业务关联不大的东西，能不放在 ViewController 里面就不要放。另外一点，这个 private method 的功能这时候只是你用得到，但是将来说不定别的地方也会用到，一开始就独立出来，有利于将来的代码复用。 懒加载 很多开发工程师，初始化属性的位置比较随意，有单独添加一个初始化方法类似 setupView 的，有在 init 初始化的，各种情况都有，导致团队协作的时候代码显得非常乱。 初始化方式不一致，这样做非常有可能破坏了每个方法功能的单一性（每个方法只做一件事）。 1234567891011121314151617181920212223242526272829303132333435@interface CustomObject ()@property (nonatomic, strong) UILabel *label;@end@implementation#pragma mark - getters and setters- (UILabel *)label&#123; if (_label == nil) &#123; _label = [[UILabel alloc] init]; _label.text = @\"1234\"; _label.font = [UIFont systemFontOfSize:12]; ... ... &#125; return _label;&#125;@end#pragma mark - life cycle- (void)viewDidLoad&#123; [super viewDidLoad]; [self.view addSubview:self.label];&#125;- (void)viewWillAppear:(BOOL)animated&#123; [super viewWillAppear:animated]; self.label.frame = CGRectMake(1, 2, 3, 4);&#125; 空格 使用空格而不是制表符 Tab 不要在工程里使用 Tab 键，使用空格来进行缩进。在 Xcode &gt; Preferences &gt; Text Editing 将 Tab 和自动缩进都设置为 4 个空格。（Google 的标准是使用两个空格来缩进，但这里还是推荐使用 Xcode 默认的设置。） 每个方法或者功能块之间为了结构清晰，应当只空一行。 该空格的地方要加空格，比如每个方法的开头，在 - 和 (return_type) 之间应该有且只有一个空格；写 property 时，严格按照下面的格式。 1234567891011121314151617181920@interface SomeClass : NSObject@property (noatomic, weak) UIView *aView- (void)someMethod;@end@implementation SomeClass- (void)setAView:(NSInteger )aview&#123;&#125;- (void)someMethod&#123;&#125;@end 方法书写 先不讨论一个方法带很多参数好不好，假设真的有很多参数导致方法名很长，应该用 : 对齐，每个参数一行，以提高可阅读性。 1234567891011- (id)initWithModel:(IPCModle)model connectType:(IPCConnectType)connectType resolution:(IPCResolution)resolution authName:(NSString *)authName password:(NSString *)password mac:(NSString *)mac azIp:(NSString *)az_ip azDns:(NSString *)az_dns token:(NSString *)token email:(NSString *)email delegate:(id)delegate; 反之如果只有两三个参数，就不要这样分行写了，一行解决即可。 1- (id)initWithAuthName:(NSString *)authName password:(NSString *)password; 方法调用 函数调用不要分行，统一单行写完，让编译器自动换行即可。特别是有 block 嵌套的时候，分行会非常难看。一般写完代码的时候可以用一个小技巧来格式化代码：选中代码，然后先按 Command + Alt + [，再按 Command + Alt + ]。就是把这一段代码往上移一行，再往下移一行，回到原来的样子，但是会经过 xCode 的排版，也就达到格式化代码的效果。 例如用: 123456// blocks are easily readable [UIView animateWithDuration:1.0 animations:^&#123; // something &#125; completion:^(BOOL finished) &#123; // something &#125;]; 而不是 12345678// colon-aligning makes the block indentation hard to read [UIView animateWithDuration:1.0 animations:^&#123; // something &#125; completion:^(BOOL finished) &#123; // something &#125;]; if 语句 表达式大括号和其他大括号(if/else/switch/while 等)总是在同一行语句打开但在新行中关闭。如果没有 else 并且括号内只有一行语句，可以和 if 语句同行，并且不需要括号。 1234567if (user.isHappy) &#123; //Do something&#125; else &#123; //Do something else&#125;if (somethingIsBad) return something; switch 语句 大括号在 case 语句中并不是必须的，除非编译器强制要求。当一个 case 语句包含多行代码时，大括号应该加上。 12345678910111213141516switch (condition) &#123; case 1: // ... break; case 2: &#123; // ... // Multi-line example using braces break; &#125; case 3: // ... break; default: // ... break; &#125; 当在 switch 使用枚举类型时，default 是不需要的。例如： 12345678910111213RWTLeftMenuTopItemType menuType = RWTLeftMenuTopItemMain; switch (menuType) &#123; case RWTLeftMenuTopItemMain: // ... break; case RWTLeftMenuTopItemShows: // ... break; case RWTLeftMenuTopItemSchedule: // ... break; &#125; 注释 代码中尽量少注释，让代码能自我描述。不过当需要注释的时候，能需要清楚地解释某个代码块的含义和作用。注释应当保持最新，如果不必要请删除。 点语法 点语法是一种很方便封装访问方法调用的方式。当你使用点语法时，通过使用 getter 或 setter 方法，属性仍然被访问或修改。 点语法应该总是被用来访问和修改属性，因为它使代码更加简洁。[ ] 符号更偏向于用在其它例子。 例如用 1view.backgroundColor = [UIColor orangeColor]; 而不是 1[view setBackgroundColor:[UIColor orangeColor]]; 当然，也有特例，有些控件直接点语法是无效的，比如 1btn.titleLabel.text = @\"xxx\"; 是最容易被坑的，编译器不会告诉你错了，但按钮事件是分状态的，写 [ ] 就可以清楚地看到。正确地赋值语句应该是： 1[btn setTitle:@\"xxx\" forState:UIControlEventTouchUpInside]; Init 和 类构造方法 1234567- (instancetype)init&#123; if (self = [super init]) &#123; // ... &#125; return self;&#125; 当类构造方法被使用时，它应该返回类型是 instancetype 而不是 id，这样确保编译器正确地推断结果类型。 123@interface Airplane+ (instancetype)airplaneWithTestType:(DKTestType)type;@end RAC 规范 在使用 RAC 的方法的前一行要写@weakify(self); 在 RAC 方法回调中的第一行写 @strongify(self); weakify 和 strongify 一定是成双存在，weakify 在一个方法的作用域内只能写一次；而 strongify 在每个 RAC 的 block 回调中都要写一次，嵌套时只需要在最外层写一次。 1234567891011@weakify(self);[[self.loadMoreBtn rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(id x) &#123; @strongify(self); [DKProgressHUD showLoadingToView:self.view]; [[self.vm.loadWeekNewsCommand execute:@(++page)] subscribeNext:^(id x) &#123; // ... 此处的 block 不需要写 strongify &#125; error:^(NSError *error) &#123; @strongify(self); // ... &#125;];&#125;]; 注意，跟 RAC 相关的对象，都要用 self.xxx 的方式去调用，不要写成变量，也不要用下划线去调用_xxx，否则会导致循环引用引起控制器被强引用，最明显的结果就是不走 dealloc 方法，会导致很多问题，比如 RAC 重复绑定数据引起程序奔溃等。 在 viewModel 中定义 RACCommand 时，一定要写 [subscriber sendCompleted]; 否则会阻塞 UI 主线程，导致 command 只能 execute 一次。 12345678910@weakify(self);_loadOldDataCommand = [[DKCommand alloc] initWithSignalBlock:^RACSignal *(id input) &#123; return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; @strongify(self); self.items = DKGetCache(KITEM); [subscriber sendNext:nil]; [subscriber sendCompleted]; return nil; &#125;];&#125;]; 命名规范 命名原则 一般性原则： 可读性高(简洁且清晰)和防止命名冲突(通过加前缀后缀来保证)。 Objective-C 的命名通常都比较长, 名称遵循驼峰式命名法. 一个好的命名标准很简单, 就是做到在开发者一看到名字时, 就能够懂得它的含义和使用方法. 另外, 每个模块都要加上自己的前缀, 前缀在编程接口中非常重要, 可以区分软件的功能范畴并防止不同文件或者类之间命名发生冲突, 比如 DKTableView、DKDataBase 代码 是否正确规范 insertObject:atIndex: 正确 insert:at: 不清晰，没有说明插入什么，插到哪里 removeObjectAtIndex: 正确 removeObject: 正确，因为⽅法是⽤来移除作为参数的对象 remove: 不清晰，没有说明要移除什么 一致性 尽可能与 Cocoa 编程接⼝命名保持一致。如果不太确定某个命名的⼀致性，请浏览头文件或参考文档中的范例，在使⽤多态方法的类中，命名的⼀致性⾮常重要。在不同类中实现相同功能的⽅法应该具有同的名称。 代码 点评 – (NSInteger)tag 在 NSView, NSCell, NSControl 中有定义 – (void)setStringValue:(NSString *) 在许多 Cocoa classes 中都有定义 文件命名 文件的扩展名应该如下: 文件名规范 文件类型 .h C / C++ / Objective-C 头文件 .m Objective-C 实现文件 .mm Objective-C / C++ 实现文件 .cc 纯 C++ 实现文件 .c 纯 C 实现文件 分类的文件名应该包含被扩展的类名，如：NSString+DKUtils.h 或 NSTextView+DKAutocomplete.h。 编码命名 类的命名 类名（以及类别、协议名）应首字母大写，并以驼峰格式分割单词。 所有类名、枚举、结构、protocol 定义时最好加一个统一的标示符，可以是项目缩写，或者个人项目的名称缩写，目前规定都加上大写的 DK 作为根前缀。 根据功能模块可以给功能模块的类添加功能模块的名称前缀，如用户中心的控制器，属于 Profile 模块，可以命名为 DKProfileViewController。 声明定义 所有 protocol 定义时，都加上后缀 Delegate。 比如 DKRefreshViewDelegate，表示 RefreshView 的协议 所有的通知名都加上 Notification，通知名格式为： [ 触发通知的类名 ] + [Did/Will] + [ 动作 ] + Notification 例如： 123NSWindowDidMiniaturizeNotificationNSTextViewDidChangeSelectionNotificationNSColorPanelColorDidChangeNotification 方法命名 小驼峰原则 方法名应遵守小驼峰原则首字母小写，其他单词首字母大写,每个空格分割的名称以动词开头。执行性的方法应该以动词开头，小写字母开头，返回性的方法应该以返回的内容开头，但之前不要加 get。 123- (void)insertModel:(id)model atIndex:(NSUInteger)atIndex;- (instancetype)arrayWithArray:(NSArray *)array; 代理方法 以发送代理的对象类名作为代理方法名的开始（去掉类名的前缀，并且小写开头） 123- (BOOL)tableView:(NSTableView *)tableView shouldSelectRow:(int)row;- (BOOL)application:(NSApplication *)sender openFile:(NSString *)filename; 枚举命名 123456typedef NS_ENUM(NSInteger, DKGlobalConstants) &#123; DKPinSizeMin = 1, DKPinSizeMax = 5, DKPinCountMin = 100, DKPinCountMax = 500,&#125;; 不使用下面这种方式 1234enum GlobalConstants &#123; kMaxPinSize = 5, kMaxPinCount = 500,&#125;; 宏命名 以大写 K 开头，后面单词首字母大写，其余小写。如：#define KMaxHeigt 100.0 属性变量命名 变量名使用小驼峰法, 使变量名尽量可以推测其用途属性具有描述性。别一心想着少打几个字母，让你的代码可以迅速被理解更加重要。 每个属性命名都加上类型后缀，如按钮就加上 btn 后缀，imageView 就加上 imgView。 如果是布尔值的成员变量，要定义 getter 方法 为 isXXX 1@property (nonatomic, assign, getter=isEditable) BOOL editable; 标题 说明 类成员变量名 成员变量用小驼峰法命名并前缀下划线 局部变量名 遵守小驼峰命名规则 const 常量 以小写 k 开头，后面单词首字母大写 项目编码规范 Controller 编码规范 传统的 Controller 层代码都是非常臃肿的，在快速迭代开发中就显的非常恶心，维护代码非常不便，所以编码中要尽量使控制器瘦身。 在 Controller 中，瘦身的方法有很多种，例如架构层用 MVVM 可以从 Controller 中抽离部分代码到 ViewModel 中，但是力度还是不够。目前比较好的做法是借鉴组件化开发的思想，把一个界面分为几大块，将 view 的具体操作和布局分离出控制器，变成一个个 view 组件，控制器要做的就是拼装并利用 Masonry 布局好这些 view 组件。 控制器要不要调用调用接口看具体需求，能放到 view 中做就尽量在 view 中做，瘦身彻底一些。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#pragma mark - Life Cycle 生命周期- (void)viewDidLoad&#123; [super viewDidLoad]; [self setUpView];&#125;- (void)viewWillAppear:(BOOL)animated&#123; [super viewWillAppear:animated]; [self events];&#125;#pragma mark - Events 事件// 设置 view- (void)setUpView&#123; self.view.backgroundColor = [UIColor whiteColor]; @weakify(self); // 第一个 view UIView *firstView = [[UIView alloc] init]; [self.view addSubview:firstView]; [firstView mas_makeConstraints:^(MASConstraintMaker *make) &#123; @strongify(self); make.top.left.right.equalTo(self.view); make.height.mas_equalTo(100); &#125;]; // 第二个 view UIView *secondView = [[UIView alloc] init]; [self.view addSubview:secondView]; [secondView mas_makeConstraints:^(MASConstraintMaker *make) &#123; @strongify(self); make.top.equalTo(firstView.mas_bottom); make.left.right.equalTo(self.view); make.height.mas_equalTo(100); &#125;]; // 第三个 view UIView *thridView = [[UIView alloc] init]; [self.view addSubview:thridView]; [thridView mas_makeConstraints:^(MASConstraintMaker *make) &#123; @strongify(self); make.top.equalTo(firstView.mas_bottom); make.left.right.equalTo(self.view); make.height.mas_equalTo(100); &#125;];&#125;// 事件- (void)events&#123; // 调用接口 [[DKService fetchSomething] subscribeNext:^(id x) &#123; // 得到接口数据 &#125;];&#125; View 编码规范 view 中做的事情会比传统的只做布局会复杂一些，像一些跳转和调用 api 接口都需要由它完成。 view 在做这些操作的时候会遇到一些问题，例如 view 中跳转问题，数据传传递问题。这些都很容易解决，跳转问题需要拿到当前控制器的根控制器去跳转，有两种情况： 没有 tabbarController 拿到根控制器：(UINavigationController *)[UIApplication sharedApplication].keyWindow.rootViewController 有 tabbarController 拿到根控制器： 1(UINavigationController *)((UITabBarController *)[UIApplication sharedApplication].keyWindow.rootViewController).selectedViewController 数据传递一般是使用 Notification，使用前一定要注意命名规范： [ 触发通知的类名 ] + [Did/Will] + [ 动作 ] + Notification","categories":[{"name":"移动端","slug":"移动端","permalink":"https://www.cqzhong.cn/categories/移动端/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.cqzhong.cn/tags/iOS/"},{"name":"代码规范","slug":"代码规范","permalink":"https://www.cqzhong.cn/tags/代码规范/"}]},{"title":"vue 页面 computed、和 methods 结合 vuex 使用的方式","slug":"vue 页面 computed、和 methods 结合 vuex 使用的方式","date":"2020-08-19T11:00:00.000Z","updated":"2020-11-03T10:21:34.606Z","comments":true,"path":"2020/08/19/vue 页面 computed、和 methods 结合 vuex 使用的方式/","link":"","permalink":"https://www.cqzhong.cn/2020/08/19/vue 页面 computed、和 methods 结合 vuex 使用的方式/","excerpt":"store下 index.js中的内容","text":"store下 index.js中的内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import Vue from 'vue'import Vuex from 'vuex'// 挂载VuexVue.use(Vuex)// 创建VueX对象const store = new Vuex.Store(&#123; state: &#123; // 存放的键值对就是所要管理的状态 count: 10, countNumber: 0, qiniu: &#123; token: '', baseUrl: '' &#125; &#125;, mutations: &#123; inc(state) &#123; state.count++ &#125;, dec(state) &#123; state.count-- &#125;, updateCount(state,value) &#123; state.count = value &#125;, upNumber(state) &#123; state.countNumber++ &#125;, // 成员操作 setQiniuToken(state, data) &#123; state.qiniu.token = data.token state.qiniu.baseUrl = data.bucketUrl &#125; &#125;, getters: &#123; // 加工state成员给外界 count(state) &#123; // vuex 为其注入state对象 state.count &#125;, countNumber(state) &#123; state.countNumber &#125;, square(state) &#123; state.count*state.count &#125; &#125;, actions: &#123; // 异步操作 inc(context) &#123; context.commit(\"inc\") &#125;, dec(context) &#123; context.commit(\"dec\") &#125;, updateCount(context, payload) &#123; context.commit(\"updateCount\",payload) &#125;, upNumber:function(context) &#123; context.commit(\"upNumber\") &#125; getQiniuToken(context, payload) &#123; const param = '' context.commit('setQiniuToken', param) &#125; &#125; // modules 模块化状态管理 modules: &#123;&#125;&#125;)export default store vue 页面内 1234567891011121314151617181920import &#123; mapState, mapGetters, mapActions &#125; from 'vuex'computed: &#123; ...mapState(&#123; count: state =&gt; state.count, countNumber: state =&gt; state.countNumber &#125;), square:mapGetters(&#123; square:\"square\" &#125;).square &#125;,methods: &#123; ...mapActions(&#123; inc:\"inc\", dec:\"dec\" &#125;)&#125;,created() &#123; this.$store.dispatch(\"getQiniuToken\")&#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://www.cqzhong.cn/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.cqzhong.cn/tags/vue/"},{"name":"vuex","slug":"vuex","permalink":"https://www.cqzhong.cn/tags/vuex/"}]},{"title":"VueX（Vue状态管理)","slug":"VueX（Vue状态管理)","date":"2020-08-18T12:00:00.000Z","updated":"2020-11-03T10:21:34.797Z","comments":true,"path":"2020/08/18/VueX（Vue状态管理)/","link":"","permalink":"https://www.cqzhong.cn/2020/08/18/VueX（Vue状态管理)/","excerpt":"一、初识 VueX 1.1 关于 VueX Vue 官网提供的状态管理器名为 Vuex，Vuex，用于管理分散在 Vue 各个组件中的数据。 对于小型应用来说，完全没有必要引入状态管理，因为这会带来更多的开发成本。然而当应用的复杂度逐渐提高，状态管理也越发重要起来。 对于组件化开发来说，大型应用的状态往往跨越多个组件。在多层嵌套的父子组件之间传递状态已经十分麻烦，而 Vue 更是没有为兄弟组件提供直接共享数据的办法。基于这个问题，许多框架提供了解决方案——使用全局的状态管理器，将所有分散的共享数据交由状态管理器保管，Vue 也不例外。","text":"一、初识 VueX 1.1 关于 VueX Vue 官网提供的状态管理器名为 Vuex，Vuex，用于管理分散在 Vue 各个组件中的数据。 对于小型应用来说，完全没有必要引入状态管理，因为这会带来更多的开发成本。然而当应用的复杂度逐渐提高，状态管理也越发重要起来。 对于组件化开发来说，大型应用的状态往往跨越多个组件。在多层嵌套的父子组件之间传递状态已经十分麻烦，而 Vue 更是没有为兄弟组件提供直接共享数据的办法。基于这个问题，许多框架提供了解决方案——使用全局的状态管理器，将所有分散的共享数据交由状态管理器保管，Vue 也不例外。 1.2 安装 Npm 安装 Vuex 1npm i vuex -s 在项目的根目录下新增一个store文件夹，在该文件夹内创建index.js 123456.├── App.vue├── components├── main.js└── store └── index.js 1.3 使用 1.3.1 初始化store下 index.js中的内容 State 用于维护所有应用层的状态，并确保应用只有唯一的数据源（SSOT, Single Source of Truth）。 Getter 维护由 State 派生的一些状态，这些状态随着 State 状态的变化而变化。与计算属性一样，Getter 中的派生状态在被计算之后会被缓存起来，当重复调用时，如果被依赖的状态没有变化，那么 Vuex 不会重新计算派生状态的值，而是直接采用缓存值。 Mutation 提供修改 State 状态的方法。 Action 类似 Mutation，不同在于： Action 不能直接修改状态，只能通过提交 mutation 来修改。 Action 可以包含异步操作。在组件中，我们可以直接使用 store.dispatch 来分发 action. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import Vue from \"vue\";import Vuex from \"vuex\";//挂载VuexVue.use(Vuex);//创建VueX对象const store = new Vuex.Store(&#123; state: &#123; //存放的键值对就是所要管理的状态 name: \"helloVueX\", count: 1, version: \"1.0.0\", qiniu: &#123; token: \"\", baseUrl: \"\", &#125;, &#125;, mutations: &#123; // 成员操作 setProjectVersion(state, payload) &#123; state.version = payload; &#125;, setQiniuToken(state, data) &#123; state.qiniu.token = data.token; state.qiniu.baseUrl = data.bucketUrl; &#125;, &#125;, getters: &#123; // 加工state成员给外界 tenTimesCount(state) &#123; // vuex 为其注入state对象 return state.count * 10; &#125;, &#125;, actions: &#123; // 异步操作 getQiniuToken(context, payload) &#123; const data = &#123; token: \"\", bucketUrl: \"\", &#125;; context.commit(\"setQiniuToken\", data); &#125;, &#125;, // modules 模块化状态管理&#125;);export default store; 1.3.2 将 store 挂载到当前项目的 Vue 实例当中去 打开 main.js 1234567891011121314import Vue from \"vue\";import App from \"./App\";import router from \"./router\";import store from \"./store\";Vue.config.productionTip = false;/* eslint-disable no-new */new Vue(&#123; el: \"#app\", router, store, //store:store 和router一样，将我们创建的Vuex实例挂载到这个vue实例中 render: (h) =&gt; h(App),&#125;); 1.3.3 在组件中使用 Vuex 1234567&lt;template&gt; &lt;div id=&quot;app&quot;&gt; name: &lt;h1&gt;&#123;&#123; $store.state.name &#125;&#125;&lt;/h1&gt; &lt;span&gt;&#123;&#123; $store.getters.tenTimesCount &#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt; 1234methods:&#123; getName()&#123; console.log(this.$store.state.name)console.log(this.$store.getters.tenTimesCount)this.$store.dispatch(&apos;getQiniuToken&apos;) this.$store.commit(&apos;setProjectVersion&apos;,&apos;1.0.1&apos;) &#125; &#125; 1234567Vue.set 为某个对象设置成员的值，若不存在则新增例如对state对象中添加一个age成员Vue.set(state,&quot;age&quot;,15)Vue.delete 删除成员将刚刚添加的age成员删除Vue.delete(state,&apos;age&apos;) modules 当项目庞大，状态非常多时，可以采用模块化管理模式。Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割。 store 拆分 12345.├── actions.js├── index.js├── mutations.js└── state.js 示例代码 index.js文件 12345678910import state from \"./state\";import * as mutations from \"./mutations\";import * as actions from \"./actions\";const store = new Vuex.Store(&#123; state, mutations, actions,&#125;);export default store; state.js文件 123export default &#123; name: \"tony\",&#125;; mutations.js文件 123export const setQiniu = (state, data) =&gt; &#123; state.qiniu = data;&#125;; modules 拆分 123456.├── index.js└── modules ├── common.js ├── order.js └── user.js 示例代码 index.js文件 123456789101112131415161718import Vue from \"vue\";import Vuex from \"vuex\";Vue.use(Vuex);const files = require.context(\"./modules\", false, /\\.js$/);let modules = &#123; state: &#123;&#125;, mutations: &#123;&#125;, actions: &#123;&#125;,&#125;;files.keys().forEach((key) =&gt; &#123; Object.assign(modules.state, files(key)[\"state\"]); Object.assign(modules.mutations, files(key)[\"mutations\"]); Object.assign(modules.actions, files(key)[\"actions\"]);&#125;);const store = new Vuex.Store(modules);export default store; common.js文件 12345678910111213import Vue from \"vue\";export const state = &#123; //登录弹窗状态 loginPopupShow: false,&#125;;export const mutations = &#123; //登录弹窗状态 setLoginPopupShow(state, data) &#123; state.loginPopupShow = data; &#125;,&#125;;export const actions = &#123;&#125;; 参考来源","categories":[{"name":"前端","slug":"前端","permalink":"https://www.cqzhong.cn/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.cqzhong.cn/tags/vue/"},{"name":"vuex","slug":"vuex","permalink":"https://www.cqzhong.cn/tags/vuex/"}]},{"title":"uniapp使用小程序插件","slug":"uniapp使用小程序插件","date":"2020-07-30T12:00:00.000Z","updated":"2020-11-03T10:21:34.805Z","comments":true,"path":"2020/07/30/uniapp使用小程序插件/","link":"","permalink":"https://www.cqzhong.cn/2020/07/30/uniapp使用小程序插件/","excerpt":"1、根目录下创建wxcomponents文件夹","text":"1、根目录下创建wxcomponents文件夹 2、将小程序组件拷贝过来放入对应文件夹 3、在 uniapp 的 page.json 中添加小程序组件 123456789&#123; \"path\": \"pages/repairOrderDetail/driverDetail\", \"style\": &#123; \"navigationBarTitleText\": \"报修单详情\", \"usingComponents\": &#123; \"driver-skeleton\": \"/wxcomponents/skeleton/driverDetail/index\" &#125; &#125;&#125; 4、在页面对应的 vue 组件中直接加载使用 12345&lt;template&gt; &lt;view&gt; &lt;driver-skeleton /&gt; &lt;/view&gt;&lt;/template&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://www.cqzhong.cn/categories/前端/"}],"tags":[{"name":"uni-app","slug":"uni-app","permalink":"https://www.cqzhong.cn/tags/uni-app/"}]},{"title":"vue组件name的作用小结","slug":"vue组件name的作用小结","date":"2020-07-21T11:00:00.000Z","updated":"2020-11-03T10:21:34.595Z","comments":true,"path":"2020/07/21/vue组件name的作用小结/","link":"","permalink":"https://www.cqzhong.cn/2020/07/21/vue组件name的作用小结/","excerpt":"本文转载自 Qin__ 我们在写 vue 项目的时候会遇到给组件命名 这里的 name 非必选项，看起来好像没啥用处，但是实际上这里用处还挺多的 123export default &#123; name: \"xxx\",&#125;;","text":"本文转载自 Qin__ 我们在写 vue 项目的时候会遇到给组件命名 这里的 name 非必选项，看起来好像没啥用处，但是实际上这里用处还挺多的 123export default &#123; name: \"xxx\",&#125;; 1、当项目使用 keep-alive 时，可搭配组件 name 进行缓存过滤 举个例子： 我们有个组件命名为 detail,其中 dom 加载完毕后我们在钩子函数 mounted 中进行数据加载 123456789101112131415export default &#123; name:'Detail'&#125;，mounted()&#123; this.getInfo();&#125;，methods:&#123; getInfo()&#123; axios.get('/xx/detail.json',&#123; params:&#123; id:this.$route.params.id &#125; &#125;).then(this.getInfoSucc) &#125; &#125; 因为我们在 App.vue 中使用了 keep-alive 导致我们第二次进入的时候页面不会重新请求，即触发 mounted 函数。 有两个解决方案,一个增加 activated()函数,每次进入新页面的时候再获取一次数据。 还有个方案就是在 keep-alive 中增加一个过滤，如下图所示： 12345&lt;div id=&quot;app&quot;&gt; &lt;keep-alive exclude=&quot;Detail&quot;&gt; &lt;router-view/&gt; &lt;/keep-alive&gt; &lt;/div&gt; 2、DOM 做递归组件时 比如说 detail.vue 组件里有个 list.vue 子组件，递归迭代时需要调用自身 name list.vue: 1234567891011121314151617181920212223242526272829303132333435363738 &lt;div&gt; &lt;div v-for=&quot;(item,index) of list&quot; :key=&quot;index&quot;&gt; &lt;div&gt; &lt;span class=&quot;item-title-icon&quot;&gt;&lt;/span&gt; &#123;&#123;item.title&#125;&#125; &lt;/div&gt; &lt;div v-if=&quot;item.children&quot; &gt; &lt;detail-list :list=&quot;item.children&quot;&gt;&lt;/detail-list&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;script&gt;export default &#123; name:&apos;DetailList&apos;,//递归组件是指组件自身调用自身 props:&#123; list:Array &#125;&#125;&lt;/script&gt; list数据： const list = [&#123; &quot;title&quot;: &quot;A&quot;, &quot;children&quot;: [&#123; &quot;title&quot;: &quot;A-A&quot;, &quot;children&quot;: [&#123; &quot;title&quot;: &quot;A-A-A&quot; &#125;] &#125;,&#123; &quot;title&quot;: &quot;A-B&quot; &#125;] &#125;, &#123; &quot;title&quot;: &quot;B&quot; &#125;, &#123; &quot;title&quot;: &quot;C&quot; &#125;, &#123; &quot;title&quot;: &quot;D&quot; &#125;] 迭代的结果如下 3、当你用 vue-tools 时 vue-devtools 调试工具里显示的组见名称是由 vue 中组件 name 决定的","categories":[{"name":"前端","slug":"前端","permalink":"https://www.cqzhong.cn/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.cqzhong.cn/tags/vue/"}]},{"title":"npm命令","slug":"npm命令","date":"2020-06-23T02:00:00.000Z","updated":"2020-11-03T10:21:35.327Z","comments":true,"path":"2020/06/23/npm命令/","link":"","permalink":"https://www.cqzhong.cn/2020/06/23/npm命令/","excerpt":"先初始化一个 package.json 文件 1npm init --yes","text":"先初始化一个 package.json 文件 1npm init --yes npm 安装模块 12npm install xxx利用 npm 安装xxx模块到当前命令行所在目录npm install -g xxx利用npm安装全局模块xxx 本地安装时将模块写入 package.json 中： 123npm install xxx 安装但不写入package.jsonnpm install xxx --save 安装并写入package.json的”dependencies”中npm install xxx --save-dev 安装并写入package.json的”devDependencies”中 npm 删除模块 12npm uninstall xxx 删除xxx模块npm uninstall -g xxx 删除全局模块xxx 如果想使用淘宝源下载, 主要为了速度，建议不要用 cnpm，而是直接修改源地址 1npm i axios --save --registry=http://registry.npm.taobao.org","categories":[{"name":"前端","slug":"前端","permalink":"https://www.cqzhong.cn/categories/前端/"}],"tags":[{"name":"lerna","slug":"lerna","permalink":"https://www.cqzhong.cn/tags/lerna/"}]},{"title":"npm发布自己的package","slug":"npm发布自己的package","date":"2020-06-22T02:00:00.000Z","updated":"2020-11-03T10:21:35.342Z","comments":true,"path":"2020/06/22/npm发布自己的package/","link":"","permalink":"https://www.cqzhong.cn/2020/06/22/npm发布自己的package/","excerpt":"npm 官网 1、注册 npm 账号 2、查看当前的登录源","text":"npm 官网 1、注册 npm 账号 2、查看当前的登录源 1npm config get registry 3、修改当前登录的源 1234# 修改下载仓库npm config set registry https://registry.npmjs.org/# 修改 下载仓库为淘宝镜像npm config set registry http://registry.npm.taobao.org/ 4、查看是否登录 1234# 查看是否登录npm whoami# 没有则登录npm login 5、新建一个文件夹，初始化一个项目 12345678mkdir npm-pkgcd npm-pkgtouch index.jsvim index.jsnpm init# 或者npm init -y 6、发布包 npm 支持以@符开头的包名称，把它叫做有范围的包，示例：@somescope/somepackage。 但是在发布包的时候，npm 会把这种包当成是你的私有包来进行发布，一般我们是发布不了的，因为 npm 会提示需要登录等等东西，这个时候我们一般就加上一个参数，告诉 npm 我们要发布的这个包是一个公共包：npm publish --access=public，不出意外这个包就可以发布成功了。 1npm publish 7、删除 NPM 包 1npm unpublish 包名 --force 注意事项 包名不要包含 demo 字样，会触发垃圾检测，不能有大写字母/空格/下滑线 npm 镜像源不要连接代理,切换到官网地址 私密代码写入.gitignore 或.npmignore 中，上传就会被忽略了","categories":[{"name":"前端","slug":"前端","permalink":"https://www.cqzhong.cn/categories/前端/"}],"tags":[{"name":"lerna","slug":"lerna","permalink":"https://www.cqzhong.cn/tags/lerna/"}]},{"title":"lerna的使用总结","slug":"lerna的使用总结","date":"2020-06-21T02:00:00.000Z","updated":"2020-11-03T10:21:35.459Z","comments":true,"path":"2020/06/21/lerna的使用总结/","link":"","permalink":"https://www.cqzhong.cn/2020/06/21/lerna的使用总结/","excerpt":"Lerna 是一个工具，它优化了使用 git 和 npm 管理多包存储库的工作流。 Lerna 官网 Lerna 仓库 npm 官网","text":"Lerna 是一个工具，它优化了使用 git 和 npm 管理多包存储库的工作流。 Lerna 官网 Lerna 仓库 npm 官网 1、注册 npm 账号 2、查看当前的登录源 1npm config get registry 3、修改当前登录的源 1234# 修改下载仓库npm config set registry https://registry.npmjs.org/# 修改 下载仓库为淘宝镜像npm config set registry http://registry.npm.taobao.org/ 4、查看是否登录 1234# 查看是否登录npm whoami# 没有则登录npm login 5、安装 lerna 123npm install --global lerna# 或者npm install lerna -g 6、查看 lerna 版本 1lerna --version 7、初始化 （使用 lerna 管理项目时，可以选择两种模式。默认的为固定模式(Fixed mode)，当使用 lerna init 命令初始化项目时，就默认为固定模式，也可以使用 lerna init --independent 命令初始化项目，这个时候就为独立模式(Independent mode)。固定模式中，packages 下的所有包共用一个版本号(version)，会自动将所有的包绑定到一个版本号上(该版本号也就是 lerna.json 中的 version 字段)，所以任意一个包发生了更新，这个共用的版本号就会发生改变。而独立模式允许每一个包有一个独立的版本号，在使用 lerna publish 命令时，可以为每个包单独制定具体的操作，同时可以只更新某一个包的版本号。） 固定模式 12# 初始化项目lerna init 独立模式 12# 初始化项目（独立模式）lerna init --independent 初始化后的目录结构 123456my-lerna-demo|--- packages|--- .gitignore|--- lerna.json #lerna 配置|--- package.json|--- README.md 其中：packages 目录用来存放我们需要拆分的各种公共代码库。lerna.json 文件里面记录了 lerna 的相关配置信息 123456789101112131415&#123; \"version\": \"0.0.1\", \"npmClient\": \"npm\", \"command\": &#123; \"publish\": &#123; \"ignoreChanges\": [\"ignored-file\", \"*.md\"], \"message\": \"chore(release): publish\" &#125;, \"bootstrap\": &#123; \"ignore\": \"component-*\", \"npmClientArgs\": [\"--no-package-lock\"] &#125; &#125;, \"packages\": [\"packages/*\"]&#125; 分别介绍每个配置项的功能： version: 记录当前项目的版本号 npmClient: 你可以指定使用 npm, cnpm 或 yarn 来执行命令 command.publish.ignoreChanges: 忽略特定的项 command.publish.npmClientArgs: 当执行 lerna bootstrap 命令时，传给 npm install 的参数 command.publish.message: 发布模块的时候，填写的 commit 信息 packages: 模块包默认所在的地址 123456789# package.json 文件加入 \"private\": true, \"workspaces\": [ \"packages/*\" ],# lerna.json 文件加入\"useWorkspaces\": true,\"npmClient\": \"yarn\", 8、创建一个包 我们在 packages 新建目录 lerna-module 12345678910111213141516# cd 到lerna-module 初始化npm init# 或者npm init -y``- 目录结构```mdmy-lerna-demo|--- packages |--- lerna-module |--- package.json |--- index.js|--- .gitignore|--- lerna.json #lerna配置|--- README.md 添加依赖（类似 npm install) lerna add babel , 该命令会在 package-1 和 package-2 下安装 babel lerna add react --scope=package-1 ,该命令会在 package-1 下安装 react lerna add package-2 --scope=package-1，该命令会在 package-1 下安装 package-2 123456789lerna add# 给a, b 包中加入Lodash，会同时改变a,b模块中packages.json文件lerna add lodash packages/a packages/b# 给a 包中加入jquery, 使用--dev参数是使依赖加入到devDependencies中lerna add jquery packages/a --dev# 你也可以使用通配符, 下面这命令，会往所有re开头的模块包中加入依赖lerna add jquery packages/re-*# 指定特定的范围，要使用--scope参数，如下：给b包安装a模块lerna add a --scope=b 发版 (因为 lerna publish 是集合了 git push 和 npm publish 的操作，因此我们需要将项目文件夹连接到 git 仓库和登录 npm 仓库) 1lerna publish 运行 lerna updated 来决定哪一个包需要被 publish 如果有必要，将会更新 lerna.json 中的 version 将所有更新过的的包中的 package.json 的 version 字段更新 将所有更新过的包中的依赖更新 为新版本创建一个 git commit 或 tag 将包 publish 到 npm 上 同时，该命令也有许多的参数，例如–skip-git 将不会创建 git commit 或 tag，–skip-npm 将不会把包 publish 到 npm 上。 1234567891011121314# 新建包lerna create &lt;name&gt; [loc]# 自动构建项目lerna bootstrap# 列出当前项目所有包,显示packages下的各个package的versionlerna ls# 清理node_modules文件夹lerna clean# 将本地包链接起来，可以直接引用。链接互相引用的库lerna link# 对包是否发生过变更lerna updated/lerna diff# 运行npm script，可以指定具体的packagelerna run","categories":[{"name":"前端","slug":"前端","permalink":"https://www.cqzhong.cn/categories/前端/"}],"tags":[{"name":"lerna","slug":"lerna","permalink":"https://www.cqzhong.cn/tags/lerna/"}]},{"title":"uni原生插件开发","slug":"uni原生插件开发","date":"2020-05-31T12:00:00.000Z","updated":"2020-11-03T10:21:35.235Z","comments":true,"path":"2020/05/31/uni原生插件开发/","link":"","permalink":"https://www.cqzhong.cn/2020/05/31/uni原生插件开发/","excerpt":"本文主要介绍如何在 iOS 平台开发 uni-app 原生插件，在您阅读此文档时，您需要具备 iOS 应用开发经验，对 HTML、JavaScript、CSS 等前端开发有一定的了解，并且熟悉在 JavaScript 和 Objective-C 环境下的 JSON 格式数据操作等。","text":"本文主要介绍如何在 iOS 平台开发 uni-app 原生插件，在您阅读此文档时，您需要具备 iOS 应用开发经验，对 HTML、JavaScript、CSS 等前端开发有一定的了解，并且熟悉在 JavaScript 和 Objective-C 环境下的 JSON 格式数据操作等。 一、官方开发教程 GitLab 示例项目 iOS 原生插件踩坑记录 1、原生插件是基于 WeexSDK 规范来实现，扩展原生功能有两种方式: module：不需要参与页面布局，只需要通过 API 调用原生功能，比如：获取当前定位信息、数据请求等功能，通过扩展 module 的方式来实现； component：需要参与页面布局，比如：map、image 等需要显示 UI 的功能，通过扩展 component 即组件的方法来实现； 2、component 只能在 nvue 文件中使用，不需要引入即可直接使用 3、module 支持在 vue 和 nvue 中调用 4、package.json 中的 id 要和 nativeplugins 下的文件夹名字一致，不然打包会报错：“插件不合法，该插件在 nativeplugins 目录下不存在 5、传值方案 前端给原生传值 注册参数传值 获取组件实例传值 原生给前端传值 1[self fireEvent:@\"loginButtonEvent\" params:@&#123;@\"tag\":@(btn.tag).stringValue&#125; domChanges:nil]; 6、nuve 文件代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;template&gt; &lt;view&gt; &lt;template v-if=\"isiOS\"&gt; &lt;dc-xrlogin class=\"login\" ref=\"xrlogin\" style=\"width:750upx;height:600upx\" @loginButtonEvent=\"onLoginButtonEvent\"&gt;&lt;/dc-xrlogin&gt; &lt;/template&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; isiOS: true &#125;; &#125;, onLoad(options) &#123; uni.getSystemInfo(&#123; success(res) &#123; this.isiOS = (res.platform === 'ios') ? true : false &#125; &#125;) &#125;, mounted() &#123; if (this.$refs.xrlogin) &#123; this.$refs.xrlogin.reloadData(&#123; 'key': 'value' &#125;); &#125; &#125;, methods: &#123; onLoginButtonEvent: function(e) &#123; uni.showToast(&#123; title: `按钮的tag值：$&#123;JSON.stringify(e)&#125;`, icon: 'none', duration: 5000 &#125;); &#125; &#125; &#125;&lt;/script&gt;&lt;style lang=\"less\"&gt;.login &#123; background-color: gray;&#125;&lt;/style&gt; 7、原生插件代码 12345678910#import \"WXComponent.h\"NS_ASSUME_NONNULL_BEGIN@interface XRLoginComponent : WXComponent@endNS_ASSUME_NONNULL_END 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#import \"XRLoginComponent.h\"#import \"WeexSDK.h\"#import \"WXConvert.h\"//布局#import \"Masonry.h\"@interface XRLoginComponent()@property (nonatomic, strong) UIView *loginView;@property (nonatomic, strong) UIButton *wxButton;@end@implementation XRLoginComponent- (instancetype)initWithRef:(NSString *)ref type:(NSString *)type styles:(NSDictionary *)styles attributes:(NSDictionary *)attributes events:(NSArray *)events weexInstance:(WXSDKInstance *)weexInstance &#123; if(self = [super initWithRef:ref type:type styles:styles attributes:attributes events:events weexInstance:weexInstance]) &#123; &#125; return self;&#125;#pragma mark - Life Cycle Methods- (UIView *)loadView &#123; return self.loginView;&#125;- (void)viewDidLoad &#123; [self.loginView addSubview:self.wxButton];// self.wxButton.frame = CGRectMake(0, 100, 300, 50); [self.wxButton mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.equalTo(self.loginView.mas_left).offset(24); make.right.equalTo(self.loginView.mas_right).offset(-24); make.centerY.equalTo(self.loginView); &#125;];&#125;- (void)loginButtonEvent:(UIButton *)btn &#123;// [self fireEvent:@\"loginButtonEvent\" params:@&#123;@\"customk\":@\"customValue\"&#125;]; [self fireEvent:@\"loginButtonEvent\" params:@&#123;@\"tag\":@(btn.tag).stringValue&#125; domChanges:nil];&#125;#pragma mark - Setter Getter Methods- (UIView *)loginView &#123; if (!_loginView) &#123; _loginView = [UIView new]; &#125; return _loginView;&#125;- (UIButton *)wxButton &#123; if (!_wxButton) &#123; _wxButton = [UIButton buttonWithType:UIButtonTypeCustom]; _wxButton.tag = 1001; [_wxButton addTarget:self action:@selector(loginButtonEvent:) forControlEvents:UIControlEventTouchUpInside]; [_wxButton setTitleColor:[UIColor whiteColor] forState:UIControlStateNormal]; _wxButton.backgroundColor = [UIColor blueColor]; [_wxButton setTitle:@\"微信登录\" forState:UIControlStateNormal]; &#125; return _wxButton;&#125;// 通过 WX_EXPORT_METHOD 将方法暴露给前端WX_EXPORT_METHOD(@selector(reloadData:))- (void)reloadData:(NSDictionary *)options &#123; // options 为前端传递的参数 NSLog(@\"%@\",options); [self fireEvent:@\"loginButtonEvent\" params:options domChanges:nil];&#125;@end 8、原生 iOS 和 uniapp 交互的另一种方式 123456// iOS端代码[[NSUserDefaults standardUserDefaults]setValue:@\"我是传递的内容\" forKey:@\"name\"];// uniapp js代码var userDefaul = plus.ios.importClass(\"NSUserDefaults\");var name = userDefaul.standardUserDefaults().stringForKey(\"name\");//获取内容","categories":[{"name":"前端","slug":"前端","permalink":"https://www.cqzhong.cn/categories/前端/"},{"name":"iOS","slug":"前端/iOS","permalink":"https://www.cqzhong.cn/categories/前端/iOS/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.cqzhong.cn/tags/vue/"},{"name":"uni-app","slug":"uni-app","permalink":"https://www.cqzhong.cn/tags/uni-app/"}]},{"title":"iOS录音lame使用","slug":"iOS录音lame使用","date":"2020-05-30T11:00:00.000Z","updated":"2020-11-03T10:21:35.566Z","comments":true,"path":"2020/05/30/iOS录音lame使用/","link":"","permalink":"https://www.cqzhong.cn/2020/05/30/iOS录音lame使用/","excerpt":"lame 静态库 libmp3lame.a 编译","text":"lame 静态库 libmp3lame.a 编译 1、lame 历史版本 2、lame-ios-build 3、下载解压 下载 lame 的最新版本解压到桌面的一个文件夹里例如 lame。 下载得到 lame-build.sh 文件拷贝到上一步解压好的文件夹里（lame） 4、打开 built-lame.sh 就可以看到我们将要修改的地方 5、修改后 6、编译导出 打开终端 进入第一步的 lame 文件夹下 cd /Users/电脑名/Desktop/lame 成功进入 lame 文件下之后 输入 chmod 777 build-lame.sh 最后输入 ./build-lame.sh 找到 lame 文件夹下面的 fat-lame 文件夹里面的 libmp3lame.a 和 lame.h 这就是重新编译出来的静态库了","categories":[{"name":"移动端","slug":"移动端","permalink":"https://www.cqzhong.cn/categories/移动端/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.cqzhong.cn/tags/iOS/"},{"name":"lame","slug":"lame","permalink":"https://www.cqzhong.cn/tags/lame/"}]},{"title":"uni-app配置eslint代码检测","slug":"uni-app配置eslint代码检测","date":"2020-05-25T12:00:00.000Z","updated":"2020-11-03T10:21:34.941Z","comments":true,"path":"2020/05/25/uni-app配置eslint代码检测/","link":"","permalink":"https://www.cqzhong.cn/2020/05/25/uni-app配置eslint代码检测/","excerpt":"1、cd 至项目目录 1npm init -y","text":"1、cd 至项目目录 1npm init -y 12345npm i -D eslintnpm install eslint-plugin-vue -save-devnpm install babel-eslint -save-dev 2、创建.eslintrc.js 文件 1./node_modules/.bin/eslint --init 12345678910✔ How would you like to use ESLint? · problems✔ What type of modules does your project use? · esm✔ Which framework does your project use? · vue✔ Does your project use TypeScript? · No / Yes✔ Where does your code run? · browser✔ What format do you want your config file to be in? · JavaScriptThe config that you&apos;ve selected requires the following dependencies:eslint-plugin-vue@latest✔ Would you like to install them now with npm? · No / Yes 3、安装 babel-eslint 1npm install babel-eslint –save -dev 4、改写 package.json 部分内容为 12345678910111213&#123; \"appName\": \"大象管车-司机端\", \"version\": \"1.0.0\", \"scripts\": &#123; \"lint\": \"eslint --ext .js,.vue ./\", \"fix\": \"eslint --fix --ext .js,.vue ./\" &#125;, \"devDependencies\": &#123; \"babel-eslint\": \"^10.1.0\", \"eslint\": \"^7.7.0\", \"eslint-plugin-vue\": \"^6.2.2\" &#125;&#125; 5、改写.eslintrc.js 部分内容为 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283module.exports = &#123; root: true, parserOptions: &#123; sourceType: \"module\", parser: \"babel-eslint\", &#125;, plugins: [\"vue\"], env: &#123; browser: true, node: true, es6: true, &#125;, globals: &#123; uni: true, wx: true, plus: true, requirePlugin: true, getApp: true, getCurrentPages: true, &#125;, extends: [\"plugin:vue/recommended\", \"eslint:recommended\"], // add your custom rules here // it is base on https://github.com/vuejs/eslint-config-vue rules: &#123; \"vue/max-attributes-per-line\": [ 2, &#123; singleline: 10, multiline: &#123; max: 1, allowFirstLine: false, &#125;, &#125;, ], \"vue/singleline-html-element-content-newline\": \"off\", \"vue/multiline-html-element-content-newline\": \"off\", \"vue/name-property-casing\": [\"error\", \"PascalCase\"], \"vue/no-v-html\": \"off\", \"accessor-pairs\": 2, \"arrow-spacing\": [ 2, &#123; before: true, after: true, &#125;, ], \"block-spacing\": [2, \"always\"], \"brace-style\": [ 2, \"1tbs\", &#123; allowSingleLine: true, &#125;, ], camelcase: [ 0, &#123; properties: \"always\", &#125;, ], \"comma-dangle\": [2, \"never\"], \"comma-spacing\": [ 2, &#123; before: false, after: true, &#125;, ], \"comma-style\": [2, \"last\"], \"constructor-super\": 2, curly: [2, \"multi-line\"], \"dot-location\": [2, \"property\"], \"eol-last\": 2, eqeqeq: [\"error\", \"always\", &#123; null: \"ignore\" &#125;], \"generator-star-spacing\": [ 2, &#123; before: true, after: true, &#125;, ], \"handle-callback-err\": [2, \"^(err|error)$\"], indent: [ 2, 2, &#123; SwitchCase: 1, &#125;, ], \"jsx-quotes\": [2, \"prefer-single\"], \"key-spacing\": [ 2, &#123; beforeColon: false, afterColon: true, &#125;, ], \"keyword-spacing\": [ 2, &#123; before: true, after: true, &#125;, ], \"new-cap\": [ 2, &#123; newIsCap: true, capIsNew: false, &#125;, ], \"new-parens\": 2, \"no-array-constructor\": 2, \"no-caller\": 2, \"no-console\": \"off\", \"no-class-assign\": 2, \"no-cond-assign\": 2, \"no-const-assign\": 2, \"no-control-regex\": 0, \"no-delete-var\": 2, \"no-dupe-args\": 2, \"no-dupe-class-members\": 2, \"no-dupe-keys\": 2, \"no-duplicate-case\": 2, \"no-empty-character-class\": 2, \"no-empty-pattern\": 2, \"no-eval\": 2, \"no-ex-assign\": 2, \"no-extend-native\": 2, \"no-extra-bind\": 2, \"no-extra-boolean-cast\": 2, \"no-extra-parens\": [2, \"functions\"], \"no-fallthrough\": 2, \"no-floating-decimal\": 2, \"no-func-assign\": 2, \"no-implied-eval\": 2, \"no-inner-declarations\": [2, \"functions\"], \"no-invalid-regexp\": 2, \"no-irregular-whitespace\": 2, \"no-iterator\": 2, \"no-label-var\": 2, \"no-labels\": [ 2, &#123; allowLoop: false, allowSwitch: false, &#125;, ], \"no-lone-blocks\": 2, \"no-mixed-spaces-and-tabs\": 2, \"no-multi-spaces\": 2, \"no-multi-str\": 2, \"no-multiple-empty-lines\": [ 2, &#123; max: 1, &#125;, ], \"no-native-reassign\": 2, \"no-negated-in-lhs\": 2, \"no-new-object\": 2, \"no-new-require\": 2, \"no-new-symbol\": 2, \"no-new-wrappers\": 2, \"no-obj-calls\": 2, \"no-octal\": 2, \"no-octal-escape\": 2, \"no-path-concat\": 2, \"no-proto\": 2, \"no-redeclare\": 2, \"no-regex-spaces\": 2, \"no-return-assign\": [2, \"except-parens\"], \"no-self-assign\": 2, \"no-self-compare\": 2, \"no-sequences\": 2, \"no-shadow-restricted-names\": 2, \"no-spaced-func\": 2, \"no-sparse-arrays\": 2, \"no-this-before-super\": 2, \"no-throw-literal\": 2, \"no-trailing-spaces\": 2, \"no-undef\": 2, \"no-undef-init\": 2, \"no-unexpected-multiline\": 2, \"no-unmodified-loop-condition\": 2, \"no-unneeded-ternary\": [ 2, &#123; defaultAssignment: false, &#125;, ], \"no-unreachable\": 2, \"no-unsafe-finally\": 2, \"no-unused-vars\": [ 2, &#123; vars: \"all\", args: \"none\", &#125;, ], \"no-useless-call\": 2, \"no-useless-computed-key\": 2, \"no-useless-constructor\": 2, \"no-useless-escape\": 0, \"no-whitespace-before-property\": 2, \"no-with\": 2, \"one-var\": [ 2, &#123; initialized: \"never\", &#125;, ], \"operator-linebreak\": [ 2, \"after\", &#123; overrides: &#123; \"?\": \"before\", \":\": \"before\", &#125;, &#125;, ], \"padded-blocks\": [2, \"never\"], quotes: [ 2, \"single\", &#123; avoidEscape: true, allowTemplateLiterals: true, &#125;, ], semi: [2, \"never\"], \"semi-spacing\": [ 2, &#123; before: false, after: true, &#125;, ], \"space-before-blocks\": [2, \"always\"], \"space-before-function-paren\": [2, \"never\"], \"space-in-parens\": [2, \"never\"], \"space-infix-ops\": 2, \"space-unary-ops\": [ 2, &#123; words: true, nonwords: false, &#125;, ], \"spaced-comment\": [ 2, \"always\", &#123; markers: [ \"global\", \"globals\", \"eslint\", \"eslint-disable\", \"*package\", \"!\", \",\", ], &#125;, ], \"template-curly-spacing\": [2, \"never\"], \"use-isnan\": 2, \"valid-typeof\": 2, \"wrap-iife\": [2, \"any\"], \"yield-star-spacing\": [2, \"both\"], yoda: [2, \"never\"], \"prefer-const\": 2, \"no-debugger\": process.env.NODE_ENV === \"production\" ? 2 : 0, \"object-curly-spacing\": [ 2, \"always\", &#123; objectsInObjects: false, &#125;, ], \"array-bracket-spacing\": [2, \"never\"], &#125;,&#125;; 6、添加 .eslintignore 文件 12345node_modulesdisthybrid/components*/*.min.js","categories":[{"name":"前端","slug":"前端","permalink":"https://www.cqzhong.cn/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.cqzhong.cn/tags/vue/"},{"name":"uni-app","slug":"uni-app","permalink":"https://www.cqzhong.cn/tags/uni-app/"}]},{"title":"async &amp; await","slug":"async & await","date":"2020-05-19T11:00:00.000Z","updated":"2020-11-03T10:21:34.701Z","comments":true,"path":"2020/05/19/async & await/","link":"","permalink":"https://www.cqzhong.cn/2020/05/19/async & await/","excerpt":"async/await 是 Javascript 编写异步程序的新方法。以往的异步方法无外乎回调函数和 Promise。但是 async/await 建立于 Promise 之上。 ES2017 引入了一种新的处理异步任务的方式----async 函数，它比使用 Promise API 更加简洁。","text":"async/await 是 Javascript 编写异步程序的新方法。以往的异步方法无外乎回调函数和 Promise。但是 async/await 建立于 Promise 之上。 ES2017 引入了一种新的处理异步任务的方式----async 函数，它比使用 Promise API 更加简洁。 快速预览 async 关键字在函数声明前使用。 await 用于处理 Promise 对象。 await 只能用在 async 函数中。 async 函数总是返回一个 Promise 对象，不论函数是否 return Promise 对象。 async/await 和 Primose 对象在本质上是一样的。 使用 async 和 await 的好处 代码更加简洁、精确。 因为少回调，Debug 起来更容易。 从 Promise then/catch 书写形式过渡过来非常自然。 代码更加“自上而下”，少嵌套。 async 和 await 的基本使用 12345678910111213// 将函数声明为一个 async 函数，这样就能在内部使用 await 了async function fetchContent() &#123; // 使用 await，而非 fetch.then let content = await fetch('/') let text = await content.text() // async 函数最终返回一个 resolved 状态的 Promise 对象， // Promise 对象的 then 回调方法接收的参数就是这里的 text return text&#125;// 调用 async 函数let promise = fetchContent.then(...) await 作用 一般情况下，await 命令后面接的是一个 Promise 对象，等待 Promise 对象状态发生变化，得到返回值，但是也可以接任意表达式的返回结果，来看个例子 123456789function a() &#123; return \"a\";&#125;async function b() &#123; return \"b\";&#125;const c = await a();const d = await b();console.log(c, d); // 'a' 'b' 由例子可以看到 await 后面不管接的是什么表达式，都能等待到结果的返回: 当等到不是 Promise 对象时，就将等到的结果返回 当等到的是一个 Promise 对象时，会阻塞后面的代码，等待 Promise 对象状态变化，得到对应的值作为 await 等待的结果，这里的阻塞指的是 async 内部的阻塞，async 函数的调用并不会阻塞 async 函数总是返回一个 Promise 对象，不论函数是否 return Promise 对象。 12345678910111213141516171819202122232425262728293031async function cook() &#123; console.log(\"开始做饭\"); return \"开始切菜\";&#125;cook().then((res) =&gt; console.log(res));print();console.log(\"first\");/* // 打印结果 开始做饭 first 开始切菜*/// 执行cook()cook();/* 开始做饭 Promise &#123;&lt;resolved&gt;: \"开始切菜\"&#125; __proto__: Promise catch: ƒ catch() constructor: ƒ Promise() finally: ƒ finally() then: ƒ then() Symbol(Symbol.toStringTag): \"Promise\" __proto__: Object [[PromiseStatus]]: \"resolved\" [[PromiseValue]]: \"开始切菜\" */ async/await 配对出现 123456789101112131415161718192021222324252627282930async function cutUp() &#123; console.log(\"开始切菜\"); // return '切好的菜' Promise.reject(\"没刀咋切菜\");&#125;async function boil() &#123; console.log(\"开始烧水\"); return \"烧好的水\";&#125;async function cook() &#123; let c = await cutUp(); console.log(\"c:\", c); let b = await boil(); console.log(\"b:\", b);&#125;cook();console.log(\"first\");/* 开始切菜 first c: undefined 开始烧水 b: 烧好的水 Uncaught (in promise) 没刀咋切菜*/ 循环中的小问题 (可以面试题) 在写 JS 循环时，JS 提供了许多好用数组 api 接口。 forEach 就是其中一个，但是碰上了async/await，可能就悲剧了，得到了不是你想要的结果，来看一个例子： 异步执行 12345678910111213141516171819function getUserInfo(id) &#123; return new Promise((resolve) =&gt; &#123; resolve(&#123; id: id, name: \"xxx\", age: \"xxx\", &#125;); &#125;);&#125;const users = [&#123; id: 1 &#125;, &#123; id: 2 &#125;, &#123; id: 3 &#125;];let userInfos = [];users.forEach(async (user) =&gt; &#123; let info = await getUserInfo(user.id); userInfos.push(info);&#125;);console.log(userInfos); // []console.log(userInfos[1]); // undefined 模拟获取多个用户的用户信息，然后得到一个用户信息数组。 但是很遗憾，上面的userInfos得到的是一个空数组，上面这段代码加上了async/await后，forEach 循环就变成了异步的，因此不会等到所有用户信息都请求完才打印 userInfos 想要等待结果的返回再打印，还是要回到老式的 for 循环，来看代码： 继发式 1234567891011121314151617181920212223242526272829303132function getUserInfo(id) &#123; return new Promise((resolve) =&gt; &#123; resolve(&#123; id: id, name: \"xxx\", age: \"xxx\", &#125;); &#125;);&#125;const users = [&#123; id: 1 &#125;, &#123; id: 2 &#125;, &#123; id: 3 &#125;];let userInfos = [];async function call() &#123; for (user of users) &#123; let info = await getUserInfo(user.id); userInfos.push(info); &#125; console.log(userInfos); console.log(userInfos[1]); // 2 &#123;id: 2, name: \"xxx\", age: \"xxx\"&#125;&#125;call();/* 0: &#123;id: 1, name: \"xxx\", age: \"xxx\"&#125; 1: &#123;id: 2, name: \"xxx\", age: \"xxx\"&#125; 2: &#123;id: 3, name: \"xxx\", age: \"xxx\"&#125; length: 3 __proto__: Array(0) &#123;id: 2, name: \"xxx\", age: \"xxx\"&#125; */ 上面这种写法是继发式的，也就是会等前面一个任务执行完，再执行下一个。 但是也许你并不关心执行过程，只要拿到想要的结果就行了，这时并发式的效率会更高，来看代码： Promise.all 并发执行，串行打印（推荐） 1234567891011121314151617181920212223242526272829303132333435363738function getUserInfo(id) &#123; return new Promise((resolve) =&gt; &#123; resolve(&#123; id: id, name: \"xxx\", age: \"xxx\", &#125;); &#125;);&#125;const users = [&#123; id: 1 &#125;, &#123; id: 2 &#125;, &#123; id: 3 &#125;];let userInfos = [];// 返回一组Prmise对象的数组const promises = users.map((user) =&gt; getUserInfo(user.id));console.log(promises);/* 0: Promise &#123;&lt;resolved&gt;: &#123;…&#125;&#125; 1: Promise &#123;&lt;resolved&gt;: &#123;…&#125;&#125; 2: Promise &#123;&lt;resolved&gt;: &#123;…&#125;&#125; */// 并发执行 Promise.all[p1(), p2(), p3()]Promise.all(promises).then((res) =&gt; &#123; userInfos = res; console.log(userInfos); console.log(userInfos[1]); // 2 &#123;id: 2, name: \"xxx\", age: \"xxx\"&#125; /* 0: &#123;id: 1, name: \"xxx\", age: \"xxx\"&#125; 1: &#123;id: 2, name: \"xxx\", age: \"xxx\"&#125; 2: &#123;id: 3, name: \"xxx\", age: \"xxx\"&#125; length: 3 __proto__: Array(0) &#123;id: 2, name: \"xxx\", age: \"xxx\"&#125; */&#125;); 模拟 async/await 实现 概念 Generator 函数是 ES6 提供的一种异步编程解决方案，执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。 yield 表达式 形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function 关键字与函数名之间有一个星号；二是，函数体内部使用 yield 表达式，定义不同的内部状态。 1234567function* foo(x) &#123; yield 1; yield 2; yield 3; yield 4; return 5;&#125; 必须调用遍历器对象的 next 方法，使得指针移向下一个状态。也就是说，每次调用 next 方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个 yield 表达式（或 return 语句）为止。 换言之，Generator 函数是分段执行的，yield 表达式是暂停执行的标记，而 next 方法可以恢复执行。 1234567891011function* foo() &#123; yield 1; yield 2; return 3;&#125;var f = foo();f.next(); // &#123; value: 1, done: false &#125;f.next().value; // 2f.next(); // &#123; value: 3, done: true&#125;f.next(); // &#123; value: undefined, done: true&#125; Generator 函数已经运行完毕，next 方法返回对象的 value 属性为 3，done 属性为 true，之后再执行 next(),done 都为 true,value 未 undefined next 方法的参数 yield 表达式本身没有返回值，或者说总是返回 undefined。 next 方法可以带一个参数，该参数就会被当作上一个 yield 表达式的返回值。 123456789101112131415function* foo(x) &#123; var y = 2 * (yield x + 1); var z = yield y / 3; return x + y + z;&#125;var a = foo(5);a.next(); // Object&#123;value:6, done:false&#125;a.next(); // Object&#123;value:NaN, done:false&#125;a.next(); // Object&#123;value:NaN, done:true&#125;var b = foo(5);b.next(); // &#123; value:6, done:false &#125;b.next(12); // &#123; value:8, done:false &#125;b.next(13); // &#123; value:42, done:true &#125; Generator + Promise = 强大的异步回调方式 1234567891011121314151617181920212223242526272829303132333435363738394041424344function co(gen) &#123; if (!gen) return; return new Promise((resolve, reject) =&gt; &#123; var it = gen(); try &#123; function step(next) &#123; if (next.done) &#123; return resolve(next.value); &#125; else &#123; Promise.resolve(next.value).then( (res) =&gt; &#123; return step(it.next(res)); &#125;, (e) =&gt; &#123; return step(it.throw(e)); &#125; ); &#125; &#125; step(it.next()); &#125; catch (e) &#123; return reject(e); &#125; &#125;);&#125;function sayhello() &#123; return new Promise((resolve) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(123); console.log(123); &#125;, 3000); &#125;);&#125;co(function* helloworld() &#123; const data = yield sayhello(); console.log(data); console.log(456);&#125;);// 123// 123// 456 参考链接: 6 个 Async/Await 优于 Promise 的方面","categories":[{"name":"前端","slug":"前端","permalink":"https://www.cqzhong.cn/categories/前端/"}],"tags":[{"name":"async","slug":"async","permalink":"https://www.cqzhong.cn/tags/async/"},{"name":"await","slug":"await","permalink":"https://www.cqzhong.cn/tags/await/"}]},{"title":"unipp 图片添加水印","slug":"unipp 图片添加水印","date":"2020-05-01T12:00:00.000Z","updated":"2020-11-03T10:21:35.021Z","comments":true,"path":"2020/05/01/unipp 图片添加水印/","link":"","permalink":"https://www.cqzhong.cn/2020/05/01/unipp 图片添加水印/","excerpt":"uniapp 生成水印不要使用 canvas，因为在 app 端使用 canvas 生成图片并导出时候会用 6-7 秒延迟，所以采用七牛云拼接代码。","text":"uniapp 生成水印不要使用 canvas，因为在 app 端使用 canvas 生成图片并导出时候会用 6-7 秒延迟，所以采用七牛云拼接代码。 1、小程序加水印、生成海报，注意要转为 px 1&lt;canvas class=\"wm\" :style=\"canvasStyle\" canvas-id=\"watermark\" /&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041import pxConfig from '../../../request/config.js'uni.getImageInfo(&#123; src: tempFilePaths[0], success: (ress) =&gt; &#123; console.log(JSON.stringify(ress, null, ' ')) this.canvasW = ress.width this.canvasH = ress.height this.canvasStyle = `width:$&#123;this.canvasW&#125;px; height:$&#123;this.canvasH&#125;px;` const ctx = uni.createCanvasContext('watermark') ctx.drawImage(tempFilePaths[0], 0, 0, this.upxTopx(ress.width), this.upxTopx(ress.height)) ctx.setFontSize(this.upxTopx(30)) ctx.setFillStyle('blue') ctx.fillText('2020-03-30', 0, this.upxTopx(30)) ctx.strokeText('2020-03-30', 0, this.upxTopx(30)) ctx.draw(false, () =&gt; &#123; this.savePoster() &#125;) &#125; &#125;)upxTopx(num) &#123; return (pxConfig.SystemInfo.windowWidth / 750) * num &#125;, // 保存海报 savePoster() &#123; console.log('保存海报') uni.canvasToTempFilePath(&#123; canvasId: 'watermark', fileType: 'png', quality: 0.5, destWidth: this.canvasW, destHeight: this.canvasH, success: (res) =&gt; &#123; this.uploadFile(res.tempFilePath, 'image') &#125;, fail(err) &#123; console.log(JSON.stringify(err)) &#125; &#125;) &#125; 12345.wm &#123; position: fixed; top: 500%; left: 0;&#125; 使用七牛云图片基本处理 1、图片基本处理（imageView2） 2、可视化处理方案","categories":[{"name":"前端","slug":"前端","permalink":"https://www.cqzhong.cn/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.cqzhong.cn/tags/vue/"},{"name":"uni-app","slug":"uni-app","permalink":"https://www.cqzhong.cn/tags/uni-app/"}]},{"title":"uni-app获取当前位置","slug":"uni-app获取当前位置","date":"2020-04-28T12:00:00.000Z","updated":"2020-11-03T10:21:35.008Z","comments":true,"path":"2020/04/28/uni-app获取当前位置/","link":"","permalink":"https://www.cqzhong.cn/2020/04/28/uni-app获取当前位置/","excerpt":"uniapp 获取当前城市： 官方 api：uni.getLocation() 获取当前的地理位置、速度。 在微信小程序中，当用户离开应用后，此接口无法调用，除非申请后台持续定位权限；当用户点击“显示在聊天顶部”时，此接口可继续调用。 例","text":"uniapp 获取当前城市： 官方 api：uni.getLocation() 获取当前的地理位置、速度。 在微信小程序中，当用户离开应用后，此接口无法调用，除非申请后台持续定位权限；当用户点击“显示在聊天顶部”时，此接口可继续调用。 例 1234567uni.getLocation(&#123; type: \"gcj02\", //wgs84 type使用高德时候要用 gcj02 success: function (res) &#123; console.log(\"当前位置的经度：\" + res.longitude); console.log(\"当前位置的纬度：\" + res.latitude); &#125;,&#125;); 成功回调函数中会返回当前经纬度等信息 如果想获取当前省市区信息，可以设置参数 geocode 为 true，该属性仅 APP 端支持 例： 1234567891011121314151617181920uni.getLocation(&#123; type: \"wgs84\", geocode: true, success: function (res) &#123; console.log(res.address); &#125;,&#125;);/*\"address\": &#123; \"country\": \"中国\", \"province\": \"上海市\", \"city\": \"上海市\", \"district\": \"浦东新区\", \"street\": \"晨晖路\", \"streetNum\": \"88号\", \"poiName\": \"金蝶软件园(晨晖路)\", \"cityCode\": \"021\" &#125;*/ APP 端还可使用 plus.geolocation 获取中文地址 123456789plus.geolocation.getCurrentPosition( function (position) &#123; console.log(position.addresses); &#125;, function (e) &#123; console.log(e.message); &#125;, &#123; geocode: true &#125;); 其他端可使用地图开放平台获取 SDK： https://ask.dcloud.net.cn/article/35070 使用地图 API 获取中文地理位置代码 123456789101112131415161718192021222324/** * 获取用户的定位信息 * @return: Promise */export const getLocationInfo = () =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; uni.getLocation(&#123; type: \"gcj02\", // 'wgs84' geocode: true, success: (res) =&gt; &#123; getAddress(res.longitude, res.latitude) .then((address) =&gt; &#123; resolve(address); &#125;) .catch(() =&gt; &#123; reject(\"\"); &#125;); &#125;, fail: () =&gt; &#123; reject(\"\"); &#125;, &#125;); &#125;);&#125;; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 根据经纬度，逆地理编码出用户的中文地址 * @param &#123;number&#125; longitude 经度 * @param &#123;number&#125; latitude 纬度 * @return: Promise */export const getAddress = (longitude, latitude) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; uni.request(&#123; url: `https://restapi.amap.com/v3/geocode/regeo`, method: \"GET\", data: &#123; key: \"f7ddefce1ff0128529450ada5ce1a64c\", location: longitude + \",\" + latitude, radius: \"100\", extensions: \"base\", batch: false, roadlevel: 0, &#125;, header: &#123; \"content-type\": \"application/x-www-form-urlencoded\", &#125;, success: (res) =&gt; &#123; if (res.data.status !== \"1\") &#123; resolve(\"\"); return; &#125; const regeocode = res.data.regeocode; if ( regeocode.formatted_address &amp;&amp; regeocode.formatted_address.length &lt; 25 ) &#123; resolve(regeocode.formatted_address); return; &#125; let info = \"\"; const addressComponent = regeocode.addressComponent; info = `$&#123;info&#125;$&#123;addressComponent.province&#125;$&#123;addressComponent.district&#125;$&#123;addressComponent.township&#125;`; if (addressComponent.streetNumber) &#123; const streetNumber = addressComponent.streetNumber; info = `$&#123;info&#125;$&#123;streetNumber.street&#125;$&#123;streetNumber.number&#125;`; &#125; resolve(info); &#125;, fail: () =&gt; &#123; reject(\"\"); &#125;, &#125;); &#125;);&#125;;","categories":[{"name":"前端","slug":"前端","permalink":"https://www.cqzhong.cn/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.cqzhong.cn/tags/vue/"},{"name":"uni-app","slug":"uni-app","permalink":"https://www.cqzhong.cn/tags/uni-app/"}]},{"title":"HBuilderX链接安卓模拟器","slug":"HBuilderX链接安卓模拟器","date":"2020-04-27T12:00:00.000Z","updated":"2020-11-03T10:21:34.974Z","comments":true,"path":"2020/04/27/HBuilderX链接安卓模拟器/","link":"","permalink":"https://www.cqzhong.cn/2020/04/27/HBuilderX链接安卓模拟器/","excerpt":"1、安卓模拟器推荐 网易 MuMu 海马玩 …","text":"1、安卓模拟器推荐 网易 MuMu 海马玩 … 2、安装后打开 HBuilderX 配置路径和端口 3、打开模拟器 运行 -&gt; 运行到手机或模拟器-&gt;…","categories":[{"name":"前端","slug":"前端","permalink":"https://www.cqzhong.cn/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.cqzhong.cn/tags/vue/"},{"name":"uni-app","slug":"uni-app","permalink":"https://www.cqzhong.cn/tags/uni-app/"}]},{"title":"uniapp 蒙板双滚动问题","slug":"uniapp 蒙板双滚动问题","date":"2020-04-25T12:00:00.000Z","updated":"2020-11-03T10:21:34.970Z","comments":true,"path":"2020/04/25/uniapp 蒙板双滚动问题/","link":"","permalink":"https://www.cqzhong.cn/2020/04/25/uniapp 蒙板双滚动问题/","excerpt":"","text":"123456789101112&lt;template&gt; &lt;view class=&quot;new-drop&quot; @touchmove.stop.prevent=&quot;scrollViewDidScroll&quot;&gt; &lt;/view&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123;&#125;, methods: &#123; scrollViewDidScroll() &#123;&#125;, &#125;,&#125;;&lt;/script&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://www.cqzhong.cn/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.cqzhong.cn/tags/vue/"},{"name":"uni-app","slug":"uni-app","permalink":"https://www.cqzhong.cn/tags/uni-app/"}]},{"title":"uniapp运行区分环境","slug":"uniapp运行区分环境","date":"2020-04-24T12:00:00.000Z","updated":"2020-11-03T10:21:34.963Z","comments":true,"path":"2020/04/24/uniapp运行区分环境/","link":"","permalink":"https://www.cqzhong.cn/2020/04/24/uniapp运行区分环境/","excerpt":"template 内区分 123456789101112131415161718192021222324252627&lt;template&gt; &lt;view&gt; &lt;!-- #ifdef MP-ALIPAY --&gt; &lt;view :class=&quot;&#123; &apos;uni-collapse-cell__title-arrow-active&apos;: isOpen, &apos;uni-collapse-cell--animation&apos;: showAnimation === true, &#125;&quot; class=&quot;uni-collapse-cell__title-arrow&quot; &gt; &lt;uni-icons color=&quot;#bbb&quot; size=&quot;20&quot; type=&quot;arrowdown&quot; /&gt; &lt;/view&gt; &lt;!-- #endif --&gt; &lt;!-- #ifndef MP-ALIPAY --&gt; &lt;uni-icons :class=&quot;&#123; &apos;uni-collapse-cell__title-arrow-active&apos;: isOpen, &apos;uni-collapse-cell--animation&apos;: showAnimation === true, &#125;&quot; class=&quot;uni-collapse-cell__title-arrow&quot; color=&quot;#bbb&quot; size=&quot;20&quot; type=&quot;arrowdown&quot; /&gt; &lt;!-- #endif --&gt; &lt;/view&gt;&lt;/template&gt;","text":"template 内区分 123456789101112131415161718192021222324252627&lt;template&gt; &lt;view&gt; &lt;!-- #ifdef MP-ALIPAY --&gt; &lt;view :class=&quot;&#123; &apos;uni-collapse-cell__title-arrow-active&apos;: isOpen, &apos;uni-collapse-cell--animation&apos;: showAnimation === true, &#125;&quot; class=&quot;uni-collapse-cell__title-arrow&quot; &gt; &lt;uni-icons color=&quot;#bbb&quot; size=&quot;20&quot; type=&quot;arrowdown&quot; /&gt; &lt;/view&gt; &lt;!-- #endif --&gt; &lt;!-- #ifndef MP-ALIPAY --&gt; &lt;uni-icons :class=&quot;&#123; &apos;uni-collapse-cell__title-arrow-active&apos;: isOpen, &apos;uni-collapse-cell--animation&apos;: showAnimation === true, &#125;&quot; class=&quot;uni-collapse-cell__title-arrow&quot; color=&quot;#bbb&quot; size=&quot;20&quot; type=&quot;arrowdown&quot; /&gt; &lt;!-- #endif --&gt; &lt;/view&gt;&lt;/template&gt; script 内区分 123// #ifdef APP-PLUS ...判断内容，当运行环境为 app时候 // #endif // #ifndefAPP-PLUS|| MP-WEIXIN || MP-ALIPAY || H5 ...判断内容, 当运行环境为非App、微信小程序、支付宝小程序、h5时候 // #endif style 123.uni-swipe_button-group &#123; /* #ifndef APP-VUE|| MP-WEIXIN||H5 */ position:absolute; top: 0; right: 0; bottom: 0; z-index: 0; /* #endif */ /* #ifndefAPP-NVUE */ display: flex; flex-shrink: 0; /* #endif */ flex-direction: row; &#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://www.cqzhong.cn/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.cqzhong.cn/tags/vue/"},{"name":"uni-app","slug":"uni-app","permalink":"https://www.cqzhong.cn/tags/uni-app/"}]},{"title":"uni-app 导航栏问题","slug":"uni-app 导航栏问题","date":"2020-04-16T02:00:00.000Z","updated":"2020-11-03T10:21:35.242Z","comments":true,"path":"2020/04/16/uni-app 导航栏问题/","link":"","permalink":"https://www.cqzhong.cn/2020/04/16/uni-app 导航栏问题/","excerpt":"page.json 文件内的配置 12345678910111213141516171819202122232425&#123; \"path\": \"pages/repair/myOrder/newRepair\", \"style\": &#123; \"navigationBarTitleText\": \"新增维修项\", \"app-plus\": &#123; \"titleNView\": &#123; \"buttons\": [ &#123; \"float\": \"left\", \"fontSize\": \"30upx\", \"text\": \"上一项\", \"width\": \"auto\" &#125;, &#123; \"float\": \"right\", \"fontSize\": \"30upx\", \"text\": \"返回主页面\", \"width\": \"auto\" &#125; ] &#125;, \"scrollIndicator\": \"none\" &#125; &#125;&#125;","text":"page.json 文件内的配置 12345678910111213141516171819202122232425&#123; \"path\": \"pages/repair/myOrder/newRepair\", \"style\": &#123; \"navigationBarTitleText\": \"新增维修项\", \"app-plus\": &#123; \"titleNView\": &#123; \"buttons\": [ &#123; \"float\": \"left\", \"fontSize\": \"30upx\", \"text\": \"上一项\", \"width\": \"auto\" &#125;, &#123; \"float\": \"right\", \"fontSize\": \"30upx\", \"text\": \"返回主页面\", \"width\": \"auto\" &#125; ] &#125;, \"scrollIndicator\": \"none\" &#125; &#125;&#125; 页面内修改导航栏 12345678910111213141516var webView = this.$mp.page.$getAppWebview() const canedit = this.$utils.permissionHander('WB_VEHICE_EDITINFO') /* * 1、安卓设置text 为空子串时候无效果。 * 2、隐藏按钮 width 一定要设置为0 */ if (canedit) &#123; webView.setTitleNViewButtonStyle(0, &#123; text: '编辑' &#125;) &#125; else &#123; webView.setTitleNViewButtonStyle(0, &#123; text: '', width: 0 &#125;) &#125; 导航栏设置左右按钮 123456789101112131415161718/* * 1、一定要设置text length不能为0 * 2、如果text的length为0一定设置width为0 */ var webView = this.$mp.page.$getAppWebview() const canedit = this.$utils.permissionHander('WB_VEHICE_EDITINFO') if (canedit) &#123; webView.setTitleNViewButtonStyle(0, &#123; text: '编辑' &#125;) // this.loadModels() this.loadTeams() &#125; else &#123; webView.setTitleNViewButtonStyle(0, &#123; text: '', width: 0 &#125;) &#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://www.cqzhong.cn/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.cqzhong.cn/tags/vue/"},{"name":"uni-app","slug":"uni-app","permalink":"https://www.cqzhong.cn/tags/uni-app/"}]},{"title":"css选择器","slug":"css选择器","date":"2020-03-28T12:00:00.000Z","updated":"2020-11-03T10:21:34.904Z","comments":true,"path":"2020/03/28/css选择器/","link":"","permalink":"https://www.cqzhong.cn/2020/03/28/css选择器/","excerpt":"1、选择器 通用选择器 *{} 类型选择器 p {} 类选择器 .note {} ID 选择器 #introduction {} 子元素选择器 li&gt;a {} 后代选择器 p a {} 相邻兄弟选择器 h1+p {} 普通兄弟选择器 h1~p {}","text":"1、选择器 通用选择器 *{} 类型选择器 p {} 类选择器 .note {} ID 选择器 #introduction {} 子元素选择器 li&gt;a {} 后代选择器 p a {} 相邻兄弟选择器 h1+p {} 普通兄弟选择器 h1~p {} 1234567891011121314151617181920212223// 相邻兄弟选择器 +// 当两个dialog-input-tipitem相邻时候.dialog-input-tipitem + .dialog-input-tipitem &#123; margin-top: 20px;&#125;// 普通相邻兄弟选择器(通用兄弟选择器) ~// 所有的同级兄弟 不要求严格相邻h1 ~ p &#123; color: red;&#125;// 后代选择器// 您希望只对 h1 元素中的 em 元素应用样式，可以这样写：h1 em &#123; color: red;&#125;// 子元素选择器 &gt;// 如果您希望选择只作为 h1 元素子元素的 strong 元素，可以这样写：h1 &gt; strong &#123; color: red;&#125; 2、特性选择器 | 简单选择器 | [] 匹配一种特定的特性 | p[class] 应用于所有包含 class 特性的元素 精确选择器 匹配一种特定的特性,该特性具有特定的值 p[calss=“dog”] 应用于所有 class 特性值为 dog 的元素 | | 部分选择器 | [~=] 匹配一个特定的特性,该特性值出现在以空格隔开的单词列表中 | p[calss~=“dog”] 应用于特定的元素,这些元素的 class 特性值是以空格隔开的单词列表,而其中一项是 dog | | 开头选择器 | [^=] 匹配一个特定的特性,该特性的值以某个特定的字符串作为开头 | p[attr^“d”] 应用于特定的元素,这些元素的某个特性的值以字母&quot;d&quot;开头 | | 包含选择器 | [=] 匹配一个特定的特性,该特性的值包含一个特定的子字符串 | p[attr&quot;do&quot;] 应用于特定的元素,这些元素的某个特性的值中含有&quot;do&quot; | | 结尾选择器 | [=]匹配一个特定的特性,该特性的值以某个特定的字符串作为结尾∣p[attr=] 匹配一个特定的特性,该特性的值以某个特定的字符串作为结尾 | p[attr=]匹配一个特定的特性,该特性的值以某个特定的字符串作为结尾∣p[attr“g”] 应用于特定的元素,这些元素的某个特性的值以字母&quot;g&quot;结尾 | 123456// 精确选择器 [class^=item-][class^=\"item-\"] &#123; position: absolute; top: 50%; transform: translateY(-50%);&#125; 3、/deep/深度选择器 vue 组件中，在 style 设置为 scoped 的时候，里面在写样式对子组件是不生效的，如果想让某些样式对所以子组件都生效，可以使用 /deep/ 深度选择器。 父类有 deep 后子类自动也会深度选择 123456789101112131415161718192021&lt;style lang=\"scss\" scoped&gt;.mine_view &#123; &amp;/deep/ .tui-line-left::after &#123; left: 40rpx !important; &#125; &amp; /deep/ .tui-cell-arrow::before &#123; right: 40rpx; &#125;&#125;.wrap&#123; .class1 &#123; font-size:12px; &#125; /deep/ .class2 &#123; font-size:20px; // 对所有子组件生效. /deep/ .class3&#123; &#125; // 没有必要写多层deep 父类有deep后子类自动也会深度选择 并且这么写在firfox里会失效 &#125;&#125;&lt;/style&gt; 4、块级元素、内联元素 有些元素在浏览器窗口中显示时总是另起一行.这些元素被称为块级元素。 eg:&lt;h1&gt;&lt;p&gt;&lt;ul&gt;&lt;li&gt;等 有些元素在显示时总是与它的邻近元素出现在同一行内.这些元素被称为内联元素。 &lt;div&gt;元素允许你将一组元素集中到一个块级元素内。 &lt;span&gt;将文本和元素集中在一个内联元素中。","categories":[{"name":"前端","slug":"前端","permalink":"https://www.cqzhong.cn/categories/前端/"}],"tags":[{"name":"css","slug":"css","permalink":"https://www.cqzhong.cn/tags/css/"}]},{"title":"数组方法","slug":"数组方法","date":"2020-03-27T12:00:00.000Z","updated":"2020-11-03T10:21:34.840Z","comments":true,"path":"2020/03/27/数组方法/","link":"","permalink":"https://www.cqzhong.cn/2020/03/27/数组方法/","excerpt":"1、map 12345678// eg: 1const defaultItemList = val || [];defaultItemList.map((item) =&gt; &#123; item.scrollViewId = `id_$&#123;item.index&#125;`;&#125;);// eg: 2const fault = faultList.map((el) =&gt; el.name).join(\"、\");const checkedFault = data.faultList.map((el) =&gt; el.id);","text":"1、map 12345678// eg: 1const defaultItemList = val || [];defaultItemList.map((item) =&gt; &#123; item.scrollViewId = `id_$&#123;item.index&#125;`;&#125;);// eg: 2const fault = faultList.map((el) =&gt; el.name).join(\"、\");const checkedFault = data.faultList.map((el) =&gt; el.id); 2、reduce 1234const arr = [1, 3, 5, 7, 9];arr.reduce(function (x, y) &#123; return x + y;&#125;); 3、filter 12345const arr = [1, 2, 4, 5, 6, 9, 10, 15];const r = arr.filter(function (x) &#123; return x % 2 !== 0;&#125;);r; // [1, 5, 9, 15] 4、sort 1234567891011const arr = [10, 20, 1, 2];arr.sort(function (x, y) &#123; if (x &lt; y) &#123; return -1; &#125; if (x &gt; y) &#123; return 1; &#125; return 0;&#125;);console.log(arr); // [1, 2, 10, 20] 5、find find()方法用于查找符合条件的第一个元素，如果找到了，返回这个元素，否则，返回 undefined： 123456789101112const arr = [\"Apple\", \"pear\", \"orange\"];console.log( arr.find(function (s) &#123; return s.toLowerCase() === s; &#125;)); // 'pear', 因为pear全部是小写console.log( arr.find(function (s) &#123; return s.toUpperCase() === s; &#125;)); // undefined, 因为没有全部是大写的元素 6、findIndex 12345findIndex() 方法返回传入一个测试条件（函数）符合条件的数组第一个元素位置。this.index = this.options.findIndex(item =&gt; item.key == this.id) if (this.index &gt; -1) &#123; this.selected = this.options[this.index] &#125; 7、some 12345678some() 方法用于检测数组中的元素是否满足指定条件（函数提供）。some() 方法会依次执行数组的每个元素：如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。如果没有满足条件的元素，则返回false。注意： some() 不会对空数组进行检测。注意： some() 不会改变原始数组。 &lt;view v-if=\"options.some((item) =&gt; item.type === 'province')\" class=\"province-item\" @tap=\"showProvince\" /&gt; &lt;/view&gt; 8、every 123every()与some()方法都是JS中数组的迭代方法。every()是对数组中每一项运行给定函数，如果该函数对每一项返回true,则返回true。some()是对数组中每一项运行给定函数，如果该函数对任一项返回true，则返回true。 9、forEach 12var arr = [\"Apple\", \"pear\", \"orange\"];arr.forEach(console.log); // 依次打印每个元素 10、Object.keys 1234var arr = [\"a\", \"b\", \"c\"];console.log(Object.keys(arr)); // console: ['0', '1', '2']var obj = &#123; a: \"alive\", b: \"bike\", c: \"color\" &#125;;console.log(Object.keys(obj)); // console: ['a', 'b', 'c']","categories":[{"name":"前端","slug":"前端","permalink":"https://www.cqzhong.cn/categories/前端/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.cqzhong.cn/tags/JavaScript/"}]},{"title":"vue实现自定义组件的v-model","slug":"vue实现自定义组件的v-model","date":"2020-02-19T12:00:00.000Z","updated":"2020-11-03T10:21:34.522Z","comments":true,"path":"2020/02/19/vue实现自定义组件的v-model/","link":"","permalink":"https://www.cqzhong.cn/2020/02/19/vue实现自定义组件的v-model/","excerpt":"编写自定义组件","text":"编写自定义组件 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div&gt;&#123;&#123; title &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: &quot;MyComponents&quot;, model: &#123; prop: &quot;modelVal&quot;, //指向props的参数名 event: &quot;change&quot;, //事件名称 &#125;, props: &#123; modelVal: &quot;&quot;, &#125;, data() &#123; return &#123; title: &quot;&quot;, &#125;; &#125;, watch: &#123; //监听值变化，再赋值给modelVal title(value) &#123; this.$emit(&quot;change&quot;, value); &#125;, &#125;,&#125;;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 使用组件，设置 v-model ** 123456789101112131415161718192021&lt;template&gt; &lt;my-components v-model=&quot;title&quot; /&gt;&lt;/template&gt;&lt;script&gt;import MyComponents from &quot;./MyComponents&quot;;export default &#123; name: &quot;Test&quot;, components: &#123; MyComponents, &#125;, data() &#123; return &#123; title: &quot;&quot;, &#125;; &#125;,&#125;;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://www.cqzhong.cn/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.cqzhong.cn/tags/vue/"}]},{"title":"vue组件通信","slug":"vue组件通信","date":"2020-02-16T12:00:00.000Z","updated":"2020-11-03T10:21:34.493Z","comments":true,"path":"2020/02/16/vue组件通信/","link":"","permalink":"https://www.cqzhong.cn/2020/02/16/vue组件通信/","excerpt":"1、组件通信 主要有 4 种 Vue 组件通信方式：父子组件的通信、非父子组件的 eventBus 通信、利用本地缓存实现组件通信、Vuex 通信，后两种在这里不做重点介绍，感兴趣的读者可以在网上查找资料。","text":"1、组件通信 主要有 4 种 Vue 组件通信方式：父子组件的通信、非父子组件的 eventBus 通信、利用本地缓存实现组件通信、Vuex 通信，后两种在这里不做重点介绍，感兴趣的读者可以在网上查找资料。 1.1 父组件向子组件通信 父组件向子组件传递数据，在这里介绍两种方式，一种需使用 props，另一种要通过$parent。props 默认是单向绑定：当父组件的属性变化时，将传导给子组件，但是反过来不会。这是为了防止子组件无意中修改了父组件的状态。 （1）使用 props 属性父组件向子组件传值可以使用如下代码： 1&lt;child-component v-bind:子组件属性=&quot;父组件数据属性&quot; /&gt; 具体步骤：父组件在 template 里使用子组件，子组件使用 props 接收数据。 12// 父组件在template里使用子组件 &lt;child v-bind:&quot;parentMsg&quot; /&gt; //子组件中用props接收数据 props: [&apos;myMessage&apos;] 完整代码如下： props 默认是单向绑定，如果需要使用双向绑定可以使用.sync 显式地指定双向绑定，这使得子组件的数据修改会回传给父组件。 1&lt;my-component v-bind:my-name.sync=&quot;name&quot; v-bind:my-age.sync=&quot;age&quot; /&gt; 如果单次绑定，可以使用.once 显式地指定单次绑定，单次绑定在建立之后不会同步之后的变化，这意味着即使父组件修改了数据，也不会传导给子组件。 1&lt;my-component v-bind:my-name.once=&quot;name&quot; v-bind:my-age.once=&quot;age&quot; /&gt; （2）直接在子组件中通过 this.$parent 调用其父组件，但并不建议使用。 ** 1.2 子组件向父组件通信 子组件向父组件通信也有两种方式：一种使用自定义事件，另一种使用$refs。 1.使用自定义事件 （1）在父组件中调用子组件的时候，绑定一个自定义事件和对应的处理函数。 123456789101112131415161718&lt;template&gt; &lt;detail-info ref=&quot;detailInfo&quot; @reload=&quot;changeData&quot; @showMask=&quot;showMaskAlert&quot; /&gt;&lt;/template&gt;&lt;script&gt;import DetailInfo from &quot;./components/detail-info.vue&quot;;export default &#123; components: &#123; DetailInfo, &#125;, methods: &#123; changeData() &#123;&#125;, &#125;,&#125;;&lt;/script&gt; （2）在子组件中把要发送的数据通过触发自定义事件传递给父组件。 使用一个自定义事件实现子组件与父组件直接的通信，其中 this.emit(&quot;customEvent&quot;，&quot;参数&quot;)中emit(&quot;customEvent&quot;，&quot;参数&quot;)中emit(&quot;customEvent&quot;，&quot;参数&quot;)中emit()的意思是把事件沿着作用域链向上派送。 1this.$emit(&apos;reload&apos;) 2.使用$refs 步骤 1：在调用子组件的时候，可以制定 refs 属性。 1&lt;child-component refs=&quot;xiaoming&quot; /&gt; 步骤 2：通过$refs 得到指定引用名称对应的组件实例。 1this.$refs.xiaoming 1.3 任意组件及平行组件通信 eventBus 这种通信方式针对的是非父子组件之间的通信，它的原理还是通过事件的触发和监听。但是因为是非父子组件的关系，它们需要有一个中间组件来连接。可以在根组件，也就是#app 组件上定义一个所有组件都可以访问到的组件，具体方式如下。 使用 eventBus 传递数据的 3 个步骤如下。实例代码如例 5-18 所示。 （1）创建一个 Vue 实例，作为事件绑定触发的公共属性。 （2）在发送方的组件触发自定义事件。 1234// 1、创建一个vue实例 bus : new Vue() // 2、在子组件触发自定义的事件 $emit()————把事件沿着作用域向上派送 bus.$emit(&apos;changeMsgEvent&apos;, &apos;需要传递的数据&apos;) //3、在接收组件监听事件，接收数据 mounted() &#123; bus.$on(&apos;changeMsgEvent&apos;,function(msg) &#123; // msg是通过事件传递来的数据 &#125;) &#125; 使用 Vue 实例作为中间事件总线，实现组件之间的数据通信","categories":[{"name":"前端","slug":"前端","permalink":"https://www.cqzhong.cn/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.cqzhong.cn/tags/vue/"}]},{"title":"事件修饰符","slug":"事件修饰符","date":"2020-02-15T12:00:00.000Z","updated":"2020-11-03T10:21:34.380Z","comments":true,"path":"2020/02/15/事件修饰符/","link":"","permalink":"https://www.cqzhong.cn/2020/02/15/事件修饰符/","excerpt":".prevent 修饰符会阻止当前事件的默认行为，相当于调用了事件的 event.preventDefault()方法。","text":".prevent 修饰符会阻止当前事件的默认行为，相当于调用了事件的 event.preventDefault()方法。 1234567891011121314151617181920&lt;!--阻止单击事件冒泡--&gt;&lt;a v-on:click.stop=\"doThis\"&gt;&lt;/a&gt;&lt;!--提交事件不再重载页面--&gt;&lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt;&lt;!--修饰符可以串联--&gt;&lt;a v-on:click.stop.prevent=\"doThat\"&gt;&lt;/a&gt;&lt;!--只有修饰符--&gt;&lt;form v-on:submit.prevent=\"doThis\"&gt;&lt;/form&gt;&lt;!--添加事件监听器时使用捕获模式--&gt;&lt;div v-on:click.capture=\"doThis\"&gt;...&lt;/div&gt;&lt;!--只当事件在该元素本身（比如不是子元素）触发时触发回调--&gt;&lt;div v-on:click.self=\"doThat\"&gt;...&lt;/div&gt;&lt;!--单击事件将只会触发一次--&gt;&lt;a v-on:click.once=\"doThis\"&gt;...&lt;/a&gt; 12@click.stop.prevent=\"onClick\" @tap.stop.prevent=\"toBeforeRepair\"@click.stop.prevent=\"assignedToServiceProviders(item,idx)\" 表单中的的参数特性 lazy 在默认情况下，v-model 在和中通常是用户输入数据时绑定数据。如果在 v-model 后添加一个修饰符.lazy，它就会转变为在 change 事件中绑定数据。 12&lt;!--在 'change'而不是 \"input\"事件中更新 --&gt; &lt;input v-model.lazy=\"msg\" /&gt; 2…number.number 修饰符是用来将输入内容自动转换成数值的，用法是直接在 v-model 后添加.number。该修饰符只对开始是数字的字符串有效，当数字有非数字字符时，属性值将不再变化。 1&lt;input v-model.number=\"age\" type=\"text\" /&gt; 3…trim.trim 的作用就是自动过滤用户输入进去的首尾空格，用法和上边的两个修饰符一样，在 v-model 后添加.trim。 1&lt;input v-model.trim=\"msg\" /&gt; 双滚动问题 12345// view内滚动添加&lt;view class=\"new-drop\" @touchmove.stop.prevent=\"scrollViewDidScroll\"&gt; &lt;scroll-view scroll-y=\"true\" style=\"max-height: 525upx;\"&gt; &lt;/scroll-view&gt;&lt;/view&gt;// 添加空方法 scrollViewDidScroll() &#123; &#125;","categories":[{"name":"前端","slug":"前端","permalink":"https://www.cqzhong.cn/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.cqzhong.cn/tags/vue/"}]},{"title":"vue绑定class、绑定行内样式","slug":"vue绑定class、绑定行内样式","date":"2020-02-13T12:00:00.000Z","updated":"2020-11-03T10:21:34.387Z","comments":true,"path":"2020/02/13/vue绑定class、绑定行内样式/","link":"","permalink":"https://www.cqzhong.cn/2020/02/13/vue绑定class、绑定行内样式/","excerpt":"1、v-bind 绑定 class","text":"1、v-bind 绑定 class 2、v-bind 数组表达式绑定 class 属性 3、v-bind 对象语法绑定行内样式 4、v-bind 数组语法绑定行内样式","categories":[{"name":"前端","slug":"前端","permalink":"https://www.cqzhong.cn/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.cqzhong.cn/tags/vue/"}]},{"title":"动态规划 Dynamic Programming","slug":"动态规划 Dynamic Programming","date":"2020-01-11T16:00:00.000Z","updated":"2020-11-03T10:21:35.386Z","comments":true,"path":"2020/01/12/动态规划 Dynamic Programming/","link":"","permalink":"https://www.cqzhong.cn/2020/01/12/动态规划 Dynamic Programming/","excerpt":"参考 Wiki 上定义 mit 动态规划","text":"参考 Wiki 上定义 mit 动态规划 动态规划关键点 动态规划 和 递归或者分治 没有根本上的区别(关键看有无最优的子结构) 共性:找到重复子问题 差异性:最优子结构、中途可以淘汰次优解 动态规划小结 打破自己的思维惯性，形成机器思维 理解复杂逻辑的关键 也是职业进阶的要点要领 斐波拉契数列 123int fib (int n) &#123; return n &lt;= 1 ? n : fib (n - 1) + fib (n - 2);&#125; 路径计数问题 12345状态转移方程(DP 方程)opt[i , j] = opt[i + 1, j] + opt[i, j + 1] 完整逻辑:if a[i, j] = '空地':opt[i , j] = opt[i + 1, j] + opt[i, j + 1] else:opt[i , j] = 0 问题关键点 最优子结构 opt[n] = best_of(opt[n-1], opt[n-2], …) 储存中间状态:opt[i] 递推公式(美其名曰:状态转移方程或者 DP 方程) Fib: opt[i] = opt[n-1] + opt[n-2] 二维路径:opt[i,j] = opt[i+1][j] + opt[i][j+1] (且判断 a[i,j]是否空地)","categories":[{"name":"算法","slug":"算法","permalink":"https://www.cqzhong.cn/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.cqzhong.cn/tags/算法/"}]},{"title":"分治、回溯、深度优先搜索和广度优先搜索","slug":"分治、回溯、深度优先搜索和广度优先搜索","date":"2019-12-29T02:00:00.000Z","updated":"2020-11-03T10:21:35.416Z","comments":true,"path":"2019/12/29/分治、回溯、深度优先搜索和广度优先搜索/","link":"","permalink":"https://www.cqzhong.cn/2019/12/29/分治、回溯、深度优先搜索和广度优先搜索/","excerpt":"分治法 分治法就是把一个复杂的算法问题按一定的“分解”方法分为等价的规模较小的若干部分，然后逐个解决，分别找出各部分的解，把各部分的解组成整个问题的解，这种朴素的思想来源于人们生活与工作的经验，也完全适合于技术领域。诸如软件的体系结构设计、模块化设计都是分而治之的具体表现。","text":"分治法 分治法就是把一个复杂的算法问题按一定的“分解”方法分为等价的规模较小的若干部分，然后逐个解决，分别找出各部分的解，把各部分的解组成整个问题的解，这种朴素的思想来源于人们生活与工作的经验，也完全适合于技术领域。诸如软件的体系结构设计、模块化设计都是分而治之的具体表现。 分治法思想 快速排序之所以比冒泡快，是因为它使用了分治法。 同冒泡排序一样，快速排序也属于交换排序，通过元素之间的比较和交换位置来达到排序的目的。不同的是，冒泡排序在每一轮中只把 1 个元素冒泡到数列的一端，而快速排序则在每一轮挑选一个基准元素，并让其他比它大的元素移动到数列一边，比它小的元素移动到数列的另一边，从而把数列拆解成两个部分。 这种思路就叫作分治法。 把它分成两个或多个更小的问题； 分别解决每个小问题； 把各小问题的解答组合起来，即可得到原问题的解答。小问题通常与原问题相似，可以递归地使用分而治之策略来解决。 分治法代码模版 1234567891011121314151617181920def divide_conquer(problem, param1, param2, ...): # recursion terminator if problem is None: print_result return # prepare data data = prepare_data(problem) subproblems = split_problem(problem, data) # conquer subproblems subresult1 = self.divide_conquer(subproblems[0], p1, ...) subresult2 = self.divide_conquer(subproblems[1], p1, ...) subresult3 = self.divide_conquer(subproblems[2], p1, ...) … # process and generate the final result result = process_result(subresult1, subresult2, subresult3, …) # revert the current level states 回溯(Backtracking) 回溯法采用试错的思想，它尝试分步的去解决一个问题。在分步解决问题的过程 中，当它通过尝试发现现有的分步答案不能得到有效的正确的解答的时候，它将 取消上一步甚至是上几步的计算，再通过其它的可能的分步解答再次尝试寻找问 题的答案。 回溯法通常用最简单的递归方法来实现，在反复重复上述的步骤后可能出现两种 情况: 找到一个可能存在的正确的答案; 在尝试了所有可能的分步方法后宣告该问题没有答案。 在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。 回溯代码模版 回溯算法详解 深度优先搜索和广度优先搜索（Depth-First-Search） BFS 代码模板 123456789101112131415def BFS(graph, start, end): visited = set() queue = [] queue.append([start]) while queue: node = queue.pop() visited.add(node) process(node) nodes = generate_related_nodes(node) queue.push(nodes) # other processing work ... DFS 代码模板 递归写法 1234567891011121314visited = set()def dfs(node, visited): if node in visited: # terminator # already visited return visited.add(node) # process current node here. ... for next_node in node.children(): if next_node not in visited: dfs(next_node, visited) 非递归写法 1234567891011121314151617def DFS(self, tree): if tree.root is None: return [] visited, stack = [], [tree.root] while stack: node = stack.pop() visited.add(node) process (node) nodes = generate_related_nodes(node) stack.push(nodes) # other processing work ... 贪心算法 Greedy 贪心算法是一种在每一步选择中都采取在当前状态下最好或最优(即最有 利)的选择，从而希望导致结果是全局最好或最优的算法。 贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不 能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前进行 选择，有回退功能。 贪心法可以解决一些最优化问题，如:求图中的最小生成树、求哈夫曼编码 等。然而对于工程和生活中的问题，贪心法一般不能得到我们所要求的答案。一旦一个问题可以通过贪心法来解决，那么贪心法一般是解决这个问题的最 好办法。由于贪心法的高效性以及其所求得的答案比较接近最优结果，贪心 法也可以用作辅助算法或者直接解决一些要求结果不特别精确的问题。 适用贪心算法的场景 简单地说，问题能够分解成子问题来解决，子问题的最优解能递推到最终 问题的最优解。这种子问题最优解称为最优子结构。 贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择， 不能回退。动态规划则会保存以前的运算结果，并根据以前的结果对当前 进行选择，有回退功能。 二分查找 二分查找的前提 目标函数单调性(单调递增或者递减) 存在上下界(bounded) 能够通过索引访问(index accessible) 二分查找代码模版 123456789left, right = 0, len(array) - 1 while left &lt;= right: mid = (left + right) / 2 if array[mid] == target: # find the target!! break or return result elif array[mid] &lt; target: left = mid + 1 else:right = mid - 1","categories":[{"name":"算法","slug":"算法","permalink":"https://www.cqzhong.cn/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.cqzhong.cn/tags/算法/"}]},{"title":"哈希表、树、二叉树、递归","slug":"哈希表、树、二叉树、递归","date":"2019-12-21T16:00:00.000Z","updated":"2020-11-03T10:21:35.374Z","comments":true,"path":"2019/12/22/哈希表、树、二叉树、递归/","link":"","permalink":"https://www.cqzhong.cn/2019/12/22/哈希表、树、二叉树、递归/","excerpt":"hashtable 散列表也叫作哈希表（hashtable），这种数据结构提供了键（Key）和值（Value）的映射关系。只要给出一个 Key，就可以高效查找到它所匹配的 Value，时间复杂度接近于 O（1） 散列表在本质上也是一个数组。 通过哈希函数把 Key 转换成数组下标。 哈希冲突：不同的 Key 通过哈希函数获得的下标有可能是相同的。 解决哈希冲突的方法： 1.开放寻址法 2.链表法","text":"hashtable 散列表也叫作哈希表（hashtable），这种数据结构提供了键（Key）和值（Value）的映射关系。只要给出一个 Key，就可以高效查找到它所匹配的 Value，时间复杂度接近于 O（1） 散列表在本质上也是一个数组。 通过哈希函数把 Key 转换成数组下标。 哈希冲突：不同的 Key 通过哈希函数获得的下标有可能是相同的。 解决哈希冲突的方法： 1.开放寻址法 2.链表法 树 树（tree）是 n（n≥0）个节点的有限集。当 n=0 时，称为空树。在任意一个非空树中，有如下特点： 1.有且仅有一个特定的称为根的节点。 2.当 n ＞ 1 时，其余节点可分为 m（m ＞ 0）个互不相交的有限集，每一个集合本身又是一个树，并称为根的子树。 链表是特殊化的树，树是特殊化的图 (链表有环就形成了树，树有环就形成了图) 二叉树 二叉树（binarytree）是树的一种特殊形式。二叉，顾名思义，这种树的每个节点最多有 2 个孩子节点。注意，这里是最多有 2 个，也可能只有 1 个，或者没有孩子节点。 树的遍历 前序遍历 中序遍历 后序遍历 层序遍历 从更宏观的角度来看，二叉树的遍历归结为两大类 深度优先遍历 （前序遍历、中序遍历、后序遍历） 广度优先遍历 （层序遍历） 思考：树的面试题解法一般都是递归 节点的定义 重复性（自相似性） 递归 重复调用函数自身实现循环称为递归。 递归模板 terminator (递归终止条件) process (处理当前层逻辑 ) drill down (去到下一层) reverse states (清理当前层) 注意点： 1. 不要人肉递归 2. 找到最近重复子问题 3. 数学归纳法思维 Java 递归模版 1234567891011121314151617public void recur(int level, int param) &#123; // terminator if (level &gt; MAX_LEVEL) &#123; // process result return; &#125; // process current logic process(level, param); // drill down recur( level: level + 1, newParam); // restore current status&#125; 递归和迭代 从“编程之美”的角度看，可以借用一句非常经典的话：“迭代是人，递归是神！”来从宏观上对二者进行把握。 递归递归就是指程序调用自身的编程思想，即一个函数调用本身。 迭代是利用已知的变量值，根据递推公式不断演进得到变量新值得编程思想。 定义 优点 优点 递归 重复调用函数自身实现循环 a.用有限的循环语句实现无限集合； b.代码易读； c.大问题转化成小问题，减少了代码量。 | a.递归不断调用函数，浪费空间 b.容易造成堆栈溢出 | | 迭代 | 利用变量的原值推出新值；函数内某段代码实现循环。 | a.效率高，运行时间只随循环的增加而增加； b.无额外开销。 | a.代码难理解； b.代码不如递归代码简洁； c.编写复杂问题时，代码逻辑不易想出 |","categories":[{"name":"算法","slug":"算法","permalink":"https://www.cqzhong.cn/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://www.cqzhong.cn/tags/算法/"}]},{"title":"iOS使用KVO监听数组个数的变化","slug":"iOS使用KVO监听数组个数的变化","date":"2019-11-12T03:00:00.000Z","updated":"2020-11-03T10:21:35.572Z","comments":true,"path":"2019/11/12/iOS使用KVO监听数组个数的变化/","link":"","permalink":"https://www.cqzhong.cn/2019/11/12/iOS使用KVO监听数组个数的变化/","excerpt":"iOS 默认不支持对数组的 KVO,因为普通方式监听的对象的地址的变化，而数组地址不变，而是里面的值发生了改变","text":"iOS 默认不支持对数组的 KVO,因为普通方式监听的对象的地址的变化，而数组地址不变，而是里面的值发生了改变 要实现监听 KVO 监听数组个数变化，整个过程需要三个步骤(与普通监听一致) 1、建立观察者及观察的对象 2、处理 key 的变化(根据 key 的变化刷新 UI) 3、移除观察者 12345678910111213141516@interface CDDeleteModel : NSObject@property (strong,nonatomic) NSMutableSet *modelDelMutaSet;@end@implementation CDDeleteModel- (NSMutableSet *)modelDelMutaSet &#123; if (!_modelDelMutaSet) _modelDelMutaSet = [NSMutableSet set]; return _modelDelMutaSet;&#125;@end 使用方法 123456789101112131415161718192021222324252627282930313233343536373839404142#import \"CDDeleteModel.h\"@property (nonatomic, strong) CDDeleteModel *delModel;#define DEL_OPERATING_MODEL [self.delModel mutableSetValueForKeyPath:@\"modelDelMutaSet\"] [DEL_OPERATING_MODEL removeAllObjects]; [DEL_OPERATING_MODEL addObjectsFromArray:self.downloadMutaArray]; [DEL_OPERATING_MODEL addObject:_downloadMutaArray[indexPath.row]]; [DEL_OPERATING_MODEL removeObject:_downloadMutaArray[indexPath.row]]; if (![DEL_OPERATING_MODEL containsObject:self.downloadMutaArray[idxPath.row]]) &#123; [self.tableView reloadRowAtIndexPath:idxPath withRowAnimation:UITableViewRowAnimationNone]; &#125;//使用KVOController#import &lt;KVOController/KVOController.h&gt;#pragma mark - Private Method- (void)setFBKVOControllerAction &#123; @weakify(self); FBKVOController *KVOController = [FBKVOController controllerWithObserver:self]; self.KVOController = KVOController; [self.KVOController observe:self.delModel keyPath:@\"modelDelMutaSet\" options:NSKeyValueObservingOptionOld | NSKeyValueObservingOptionNew block:^(id _Nullable observer, id _Nonnull object, NSDictionary&lt;NSString *,id&gt; * _Nonnull change) &#123; @strongify(self); //change[NSKeyValueChangeNewKey] //在这里监听到 [self.downloadMutaArray count]个数的变化 &#125;];&#125;","categories":[{"name":"移动端","slug":"移动端","permalink":"https://www.cqzhong.cn/categories/移动端/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.cqzhong.cn/tags/iOS/"},{"name":"KVO","slug":"KVO","permalink":"https://www.cqzhong.cn/tags/KVO/"},{"name":"数组","slug":"数组","permalink":"https://www.cqzhong.cn/tags/数组/"}]},{"title":"Mac下Go语言环境配置","slug":"Mac下Go语言环境配置","date":"2019-11-03T03:58:06.000Z","updated":"2020-11-03T10:21:35.694Z","comments":true,"path":"2019/11/03/Mac下Go语言环境配置/","link":"","permalink":"https://www.cqzhong.cn/2019/11/03/Mac下Go语言环境配置/","excerpt":"一：插件 1、Go 2、添加 struct tag 的插件：gomodifytags","text":"一：插件 1、Go 2、添加 struct tag 的插件：gomodifytags 二、配置 Go 环境变量 GOPATH 和 GOBIN （1）打开终端，cd ~ （2）查看是否有.bash_profile 文件： ls -all （3）有则跳过此步，没有则： 1）创建：touch .bash_profile 2）编辑：open -e .bash_profile 3）自定义 GOPATH 和 GOBIN 位置： export GOPATH=/Users/hopkings/www/Go export GOBIN=GOPATH/binexportPATH=GOPATH/bin export PATH=GOPATH/binexportPATH=PATH:$GOBIN （4）编译：source .bash_profile *查看 Go 环境变量：go env 三、安装环境失败 Installing github.com/mdempsky/gocodeFAILED Installing github.com/ramya-rao-a/go-outlineFAILED Installing github.com/acroca/go-symbolsFAILED Installing golang.org/x/tools/cmd/guruFAILED Installing golang.org/x/tools/cmd/gorenameFAILED Installing github.com/stamblerre/gocodeFAILED Installing github.com/sqs/goreturnsFAILED Installing golang.org/x/lint/golintFAILED 8 tools failed to install. 解决方案： 1、设置 GOPATH ： /Users/用户 user/go 2、 在 /Users/用户 user/go/src 下创建 golang.org/x 文件夹 3、cd /Users/用户 user/go/src/golang.org/x git clone https://github.com/golang/tools.git tools git clone https://github.com/golang/lint 4、执行完以后，会多一个 tools 文件夹 、lint 文件夹 5、打开 vsCode 终端，切换到 终端，进入“%GOPATH”目录,执行 go install github.com/ramya-rao-a/go-outline go install github.com/sqs/goreturns 6、或者直接在输出下面安装插件，成功 参考：Mac 下安装与配置 Go 语言开发环境","categories":[{"name":"后端","slug":"后端","permalink":"https://www.cqzhong.cn/categories/后端/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://www.cqzhong.cn/tags/Golang/"},{"name":"Visual Studio Code","slug":"Visual-Studio-Code","permalink":"https://www.cqzhong.cn/tags/Visual-Studio-Code/"}]},{"title":"微信小程序开发问题汇总","slug":"微信小程序开发问题汇总","date":"2019-10-29T12:01:38.000Z","updated":"2020-11-03T10:21:35.216Z","comments":true,"path":"2019/10/29/微信小程序开发问题汇总/","link":"","permalink":"https://www.cqzhong.cn/2019/10/29/微信小程序开发问题汇总/","excerpt":"代码片段和问题总结","text":"代码片段和问题总结 1、display 1234567891011121314displaydisplay属性none:此元素不会被显示block：两个元素自动换行inline：两个元素靠在一起inherit：继承父类flex：多栏多列flex-direction属性column垂直分布row水平分布align-items设置item对齐方式centerleftright 2、flex 12345678910111213141516171819202122flex-wrap:nowrap(即使排不下，也不换行)wrap:(换行)wrap-reverse(换行第一行在下面)justify-content:flex-start(水平左对齐)flex-end(水平右对齐)center(居中).space(两端对齐)space-around(等间距，边距是间距的1/2)align-item:stretch(填充整个容器)flex-start(侧轴的起点对齐)flex-end(侧轴终点对齐)center(侧轴的中居中)baseline(以子元素的第一行文字对齐)flex容器属性1、flex-direction设置容器内子元素即flex-item的排列方向。2、flex-warp设置容器内子元素是否换行。3、justify-content设置子元素在横轴(即x轴)的排列位置。4、align-item设置子元素在y轴的排列位置。5、align-content设置子元素在多个主轴线上排列的位置。order、flex-grow、flex-shrink、flex-basis、align-self、displayflex。justify-content1、flex-start（水平居左对齐）2、flex-end（水平居右对齐）3、center（水平居中对齐）4、space-between（两端对齐、两端的子元素贴容器边、其他子元素之间的间隔相等）5、space-around（每个子元素的距离相等、两端的子元素距离容器的边距是元素之间间距的一半） 3、image 使用 123456&lt;image mode=\"aspectFit\" hidden='&#123;&#123;(item.title == \"昵称\" || item.title == \"我的签名\") ? true : false&#125;&#125;' class=\"mark-image\" src=\"../../../images/sanjiao@2x.png\"/&gt; 4、overflow 123456overflow：visible -默认值。内容不会被修剪，会呈现在元素框之外hidden-内容会被修剪，并且其余内容是不可见的。scroll-内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。auto-如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。inherit-规定应该从父元素继承 overflow 属性的值。 5、wx:for 使用 12345678&lt;view wx:for=\"&#123;&#123;searchRes&#125;&#125;\" wx:key=\"code\" class=\"citys-item bottom-border &#123;&#123;currentActive==='search'&amp;&amp;choosedCitys.code===item.code &amp;&amp; 'city-active'&#125;&#125;\" data-current-active=\"search\" data-choosed-citys=\"&#123;&#123;item&#125;&#125;\" catch:tap=\"setCity\"&gt;&lt;/view&gt; 6、模版的使用 12345678&lt;template is=\"publishTopic\" data=\"&#123;&#123;topicArray : topicArray, topicIndex : topicIndex, topicFn : topicFn&#125;&#125;\"&gt;&lt;/template&gt;&lt;import src=\"../publishTopic/publishTopic.wxml\" /&gt;@import \"../../../component/publishTopic/publishTopic.wxss\"; 7、block 使用 123456&lt;block wx:if=\"&#123;&#123;title == '执行中的项目'&#125;&#125;\"&gt; &lt;text class=\"offCodeNum\" style=\"color: #732FC3\"&gt;956&lt;/text&gt;&lt;/block&gt;&lt;block wx:else&gt; &lt;text class=\"offCodeNum\"&gt;956&lt;/text&gt;&lt;/block&gt; 8、画细线 12345678910111213141516171819.boder1px&#123; position: relative;&#125;.boder1px:after &#123; content: \" \"; position: absolute; width: 100%; left: 0; bottom: 0; height: 1px; border-bottom: 1px solid #E5E5E5; color: #E5E5E5; -webkit-transform-origin: 0 100%; transform-origin: 0 100%; -webkit-transform: scaleY(0.5); transform: scaleY(0.5);&#125;&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0, maximum-scale=1.0, user-scalable=0\"&gt; 加到head里 9.事件绑定 1234567891011121314151617181920212223242526272829// 事件绑定传值 设置 data-obj, 取 e.currentTarget.dataset.obj&lt;view class=\"topic-selected\" bindtap=\"&#123;&#123;topicFn&#125;&#125;\" data-keyword=\"&#123;&#123;item&#125;&#125;\"&gt; &#123;&#123;item&#125;&#125; &lt;image class=\"topic-check-image\" src=\"../../../images/Check@2x.png\" mode=\"aspectFit\" &gt;&lt;/image&gt;&lt;/view&gt;// let indexTag = e.currentTarget.dataset.keyword.id // tag&lt;block wx:for=\"&#123;&#123;tagsArray&#125;&#125;\" wx:key=\"item\" wx:for-index=\"item.id\"&gt; &lt;block wx:if=\"&#123;&#123;item.id== indexTag&#125;&#125;\"&gt; &lt;view class=\"publish-tag-selected-item\" data-keyword=\"&#123;&#123;item&#125;&#125;\" bindtap=\"selectedByTag\" &gt;&#123;&#123;item.tagName&#125;&#125;&lt;/view &gt; &lt;/block&gt; &lt;block wx:else&gt; &lt;view class=\"publish-tag-item\" data-keyword=\"&#123;&#123;item&#125;&#125;\" bindtap=\"selectedByTag\" &gt;&#123;&#123;item.tagName&#125;&#125;&lt;/view &gt; &lt;/block&gt;&lt;/block&gt; 10、返回上级界面，携带参数 1234567891011var pages = getCurrentPages();var currPage = pages[pages.length - 1]; // 当前页面var prevPage = pages[pages.length - 2]; // 上一个页面prevPage.setData(&#123; linkSource: obj.link, isChangeSource: true,&#125;); // 给上级页面的变量赋值wx.navigateBack(&#123; delta: 1,&#125;); // 返回上级页面 11、重定向一个页面，携带参数 1234wx.redirectTo(&#123; url: \"../read?bookId=\" + this.data.bookId + \"&amp;bookTitle=\" + this.data.bookTitle,&#125;); 12、微信小程序 页面隐藏导航栏 1\"navigationStyle\" : \"custom\" 13、微信小程序，绑定两个方法 1234&lt;view class=\"button\" bindtap=\"&#123;&#123;isContain ? 'removeABookcase' : 'addABookcase'&#125;&#125;\"&gt;&lt;/view&gt; 14、组件 Component 使用 1234567891011// 查看书籍详情 methods: &#123; viewBookDetail: function (e) &#123; var bookId =e.currentTarget.dataset.id this.triggerEvent(\"viewBookDetail\", &#123;bookId&#125;) &#125; &#125;\"usingComponents\": &#123; \"bookList\": \"/component/bookList/bookList\" &#125;&lt;bookList list=\"&#123;&#123;list&#125;&#125;\" isLoadmore=\"&#123;&#123;isLoadmore&#125;&#125;\" bindloadMore=\"loadRankListRequest\" bindviewBookDetail=\"viewBookDetail\" showLoad=\"&#123;&#123;showLoad&#125;&#125;\"/&gt; 15、data- 赋值时候一定要小写，写大写也会被转为小写。取值取不出来 12345678&lt;view class=\"cell-comment\" catchtap=\"onClickCommentEvent\" data-title=\"&#123;&#123;item.title&#125;&#125;\" data-pid=\"&#123;&#123;item.productionId&#125;&#125;\" data-userId=\"&#123;&#123;item.userId&#125;&#125;\" &gt;（错误，应该为小写data-userid）&lt;/view&gt; 16、继承 123456789101112131415161718192021222324function inherits(Child, Parent) &#123; var F = function () &#123;&#125;; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child;&#125;class Student &#123; constructor(name) &#123; this.name = name; &#125; hello() &#123;&#125;&#125;class PrimaryStudent extends Student &#123; constructor(name, grade) &#123; super(name); // 记得用super调用父类的构造方法! this.grade = grade; &#125; myGrade() &#123; alert(\"I am at grade \" + this.grade); &#125;&#125; 17、渐隐效果 1234567891011121314.poetry_box::after &#123; content: \"\"; display: block; width: 100%; height: 100rpx; position: absolute; left: 0; bottom: 0rpx; background-image: linear-gradient( -180deg, rgba(255, 255, 255, 0) 0%, #fff 100% );&#125; 18、微信小程序字体引入外部字体(注意是 https) 1234567891011@font-face &#123; font-family: \"fz-mw-sf\"; src: url(\"https://statics.zhuishushenqi.com/fonts/fz-mw-sf.ttf\");&#125;.read_body &#123; font-size: 16px; text-indent: 28px; line-height: 40px; font-family: \"fz-mw-sf\";&#125; 19、hidden 只能对块级元素无效 改为 display:none 12345678910111213141516171819202122232425262728.rank_sort &#123; text-align: center; vertical-align: middle; height: 40rpx; position: relative; font-size: 28rpx; color: #b0b3ba; &amp;:before &#123; content: \" \"; width: 38rpx; border-bottom: 1px solid #b0b3ba; position: absolute; left: 24%; top: 50%; transform: translateX(-50%, -24%); &#125; &amp;:after &#123; content: \" \"; width: 38rpx; border-bottom: 1px solid #b0b3ba; position: absolute; right: 24%; top: 50%; transform: translateX(-50%, -24%); &#125;&#125; 20、解析构造 1let &#123; boxList, current &#125; = this.data; 21、修改数据源 1234567891011121314151617let share_list = this.data.share_list, idx = e.currentTarget.dataset.idx;share_list[idx].share_praise_status = !share_list[idx].share_praise_status;share_list[idx].share_praise_count = share_list[idx].share_praise_status ? share_list[idx].share_praise_count + 1 : share_list[idx].share_praise_count - 1;let account = this.data.account;account.praise_count = share_list[idx].share_praise_status ? account.praise_count + 1 : account.praise_count - 1;this.setData(&#123; share_list: share_list, account: account,&#125;); 22、事件冒泡 1234微信小程序 阻止冒泡事件事情的bind 改成 catchbind 是阻止不了冒泡的例如 bindtap 改成 catchtap 23 12hidden 对于 flex布局无效。padding是自身属性，点击区域加大 24、error 123警告Do not have EventHandle handler in current page: pages/user/user. Please make sure that EventHandle handler has been defined in pages/user/user, or pages/user/user has been added into app.json各种网络回答app.json排序，未解决，后发现是wxml里。有个catchtouchmove方法在js内没执行 25、不换行 123456789// 不换行overflow: hidden;text-overflow: ellipsis;white-space: nowrap;// 换行word-break: keep-all;word-wrap: break-word;text-align: justify; 26、API 12wx.createSelectorQuery().select('#canvas-container').boundingClientRect(function(rect)&#123;&#125;).exec() 27 123456789101112wx.getSystemInfo(&#123; success: function (res) &#123; let height = res.statusBarHeight + (res.platform === \"ios\" ? 44 : 48); let rule = 750 / res.windowWidth; height = height * rule; that.setData(&#123; platform: res.platform, navHeight: height, &#125;); &#125;,&#125;); 28、自定义顶层弹窗 1234567891011.mask_box &#123; width: 100%; height: 100%; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0, 0, 0, 0.5); z-index: 9999;&#125; 29、wx.downloadFile 1234567891011121314// 下载wx.downloadFile(&#123; url: obj.backgroundImageUrl, success: (res) =&gt; &#123; console.log(\"success:\" + JSON.stringify(res, null, \"\")); if (res.statusCode == 200) &#123; this.setData(&#123; poster_bg: res.tempFilePath &#125;); console.log(\"\\n\\n\\n成功:\" + this.data.poster_bg); this.trimData(obj); &#125; else &#123; console.log(\"\\n\\n\\n失败\"); &#125; &#125;,&#125;); 30 123456789101112131415161718// 替换字符串let text = posterInfo.text;// text=text.replace(/，\\n|。\\n|！\\n|？\\n|；\\n/g,'\\n')// 去除 符号+换行text = text.replace(/，\\n/g, `，`);text = text.replace(/；\\n/g, `；`);text = text.replace(/？\\n/g, `？`);text = text.replace(/！\\n/g, `！`);text = text.replace(/。\\n/g, `。`);text = text.replace(/，/g, `，$&#123;mark&#125;`);text = text.replace(/；/g, `；$&#123;mark&#125;`);text = text.replace(/？/g, `？$&#123;mark&#125;`);text = text.replace(/！/g, `！$&#123;mark&#125;`);text = text.replace(/。/g, `。$&#123;mark&#125;`);text = text.replace(/[\\r\\n]/g, mark); 31、canvas 12345678910// canvas fillText、left, right, center 代表起始点的位置，ctx.textAlign = \"right\";ctx.fillText(`——《$&#123;info.title&#125;》`, this.rpxTopx(695), tH + this.rpxTopx(8), this.rpxTopx(640))ctx.textAlign = \"left\";ctx.fillText(`——《$&#123;info.title&#125;》`, this.rpxTopx(55), tH + this.rpxTopx(8), this.rpxTopx(640))所谓的left、right、center指的是定位参考点的位置right表示，以整段文字的最右侧作为定位点，然后这个点的位置位于上面所定义的120px（横向）位置 31、 canvas drawImage 12![canvasdrawImage](https://cqz-1256838880.cos.ap-shanghai.myqcloud.com/canvas_drawImage.jpeg) 32. calc() 函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748vh/vw vh: 相对于视窗的高度, 视窗被均分为100单位的vh; vw: 相对于视窗的宽度, 视窗被均分为100单位的vw; vmax: 相对于视窗的宽度或高度中较大的那个。其中最大的那个被均分为100单位的vmax; vmin: 相对于视窗的宽度或高度中较小的那个。其中最小的那个被均分为100单位的vmin; 视区所指为浏览器内部的可视区域大小， 即window.innerWidth/window.innerHeight大小，不包含任务栏标题栏以及底部工具栏的浏览器区域大小。calc calc是英文单词calculate(计算)的缩写，是css3的一个新增的功能，用来指定元素的长度。比如说，你可以使用calc()给元素的border、margin、pading、font-size和width等属性设置动态值。为何说是动态值呢?因为我们使用的表达式来得到的值。不过calc()最大的好处就是用在流体布局上，可以通过calc()计算得到元素的宽度。 calc是 css3提供的一个在css文件中计算值的函数：用于动态计算长度值。需要注意的是，运算符前后都需要保留一个空格，例如：width: calc(100% - 10px)；任何长度值都可以使用calc()函数进行计算；calc()函数支持 “+”, “-“, “*”, “/” 运算；calc()函数使用标准的数学运算优先级规则；calc(100vh - 10px) 表示整个浏览器窗口高度减去10px的大小calc(100vw - 10px) 表示整个浏览器窗口宽度减去10px的大小scroll-view &#123; height: calc(~&quot;100vh - 496rpx&quot;);&#125;position:absolute;left:50px;width: calc(100%-100px);.user-hd&#123; width: 100%; min-height: 400rpx; background-color: #ffffff; padding: 30rpx 20rpx;&#125;.user-hd .hd-left&#123; width: 100rpx; height: 100rpx;&#125;.user-hd .hd-right&#123; width: calc(100% - 100rpx); height: 100rpx; padding-left: 20rpx; position: relative;&#125; 33. 对齐 1234567891011121314151617181920212223242526272829303132333435363738394041424344451、 元素居中对齐 如 div display: block; margin: auto;2、文本居中对齐 text-align:center;3、图片居中对齐 要让图片居中对齐，可以使用margin: auto; 并将它放到 块 元素中 display:block; margin:auto; width: 40%;4、左右居中对齐-使用定位方式 配合margin，padding position: absolute;5、左右对齐还可以使用 float float:right; padding:10px;6、垂直居中对齐-使用padding padding:70px 0; border: 3px solid green; text-align:center;7、垂直居中 使用line-height 配合 height8、垂直居中 使用position 配合 transform margin: 0; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);9、居中垂直对齐 使用flex display: flex; justify-content: center; align-items: center; 34、 箭头函数 12345678910111213141516171819202122232425262728293031323334353637383940414243// 1、let p1 = new Promise((resolve, reject) =&gt; &#123; if (!util.isNullString(obj.headImgUrl)) &#123; wx.downloadFile(&#123; url: obj.headImgUrl, success: (res) =&gt; &#123; if (res.statusCode === 200) this.setData(&#123; poster_avater: res.tempFilePath &#125;); else this.setData(&#123; poster_avater: \"\" &#125;); resolve(); &#125;, &#125;); &#125; else &#123; this.setData(&#123; poster_avater: \"\" &#125;); resolve(); &#125;&#125;);// 头像，背景,二维码Promise.all([p1, p2, p3]).then((res) =&gt; &#123; this.trimData(obj); let options = &#123; puid: obj.userId, id: obj.productionId &#125;; this.shareClick(options);&#125;);// 2、setTimeout(() =&gt; &#123; wx.hideLoading(); this.savePoster();&#125;, 300);// 3、var countdownInterval = null;clearInterval(countdownInterval);countdownInterval = setInterval(() =&gt; &#123; t -= 1000; let count = util.countdown(t); this.setData(&#123; time: count, &#125;);&#125;, 1000); 35、动态设置 tabbar 123456wx.setTabBarItem(&#123; index: 0, text: \"text\", iconPath: \"/path/to/iconPath\", selectedIconPath: \"/path/to/selectedIconPath\",&#125;); 36、获取微信头像，昵称(不需要授权) 12345// 微信头像&lt;open-data type=\"userAvatarUrl\"&gt;&lt;/open-data&gt;// 微信昵称&lt;open-data type=\"userNickName\"&gt;&lt;/open-data&gt; 37、微信小程序字数限制 1234567891011121314&lt;input placeholder-class=\"boder1px_input\" bindinput=\"textChange\" type=\"text\" data-name=\"introduction\" placeholder=\"请输入班级情况\" value=\"&#123;&#123;introText&#125;&#125;\" name=\"introduction\"/&gt;textChange: function (e) &#123; if (e.currentTarget.dataset.name != 'introduction')return let wordNum = e.detail.value.length, introText = e.detail.value if(wordNum &gt; 40) &#123; introText = introText.substring(0, 40) wordNum =introText.length &#125; this.setData(&#123; introText : introText, wordNum: wordNum &#125;) &#125;, 38、页面传参对象 123456789let item = JSON.stringify(this.data.selectedItem);wx.navigateTo(&#123; url: `../add/index?item=$&#123;encodeURIComponent(item)&#125;`,&#125;);if (options.item) &#123; let item = JSON.parse(decodeURIComponent(options.item));&#125; 39、路由跳转 wx.redirectTo 当页面过多时，被保留页面会挤占微信分配给小程序的内存，或是达到微信所限制的 5 层页面栈。这时，我们应该考虑选择 wx.redirectTo。wx.redirectTo()用于关闭当前页面，跳转到应用内的某个页面。这样的跳转，可以避免跳转前页面占据运行内存，但返回时页面需要重新加载，增加了返回页面的显示时间。 wx.reLaunch wx.reLaunch()与 wx.redirectTo()的用途基本相同， 只是 wx.reLaunch()先关闭了内存中所有保留的页面，再跳转到目标页面。 wx.navigateTo 用于保留当前页面、跳转到应用内的某个页面，使用 wx.navigateBack 可以返回到原页面。对于页面不是特别多的小程序，通常推荐使用 wx.navigateTo 进行跳转， 以便返回原页面，以提高加载速度。当页面特别多时，则不推荐使用。 wx.switchTab 对于跳转到 tab bar 的页面，最好选择 wx.switchTab()，它会先关闭所有非 tab bar 的页面。其次，也可以选择 wx.reLaunch()，它也能实现从非 tab bar 跳转到 tab bar，或在 tab bar 间跳转，效果等同 wx.switchTab()。使用其他跳转 API 来跳转到 tab bar，则会跳转失败。 wx.navigateBack 用于关闭当前页面，并返回上一页面或多级页面。开发者可通过 getCurrentPages() 获取当前的页面栈，决定需要返回几层。这个 API 需要填写的参数只有 delta，表示要返回的页面数。若 delta 的取值大于现有可返回页面数时，则返回到用户进入小程序的第一个页面。当不填写 delta 的值时，就默认其为 1（注意，默认并非取 0），即返回上一页面。 40、 picker 点击未响应 检查下是否有变量名写错 value 一定要有值 41: 点击事件未响应 调整 z-index 42: 微信小程序 button 去除边框 1234567891011.share_p &#123; bottom: 0; left: 0; border: none; margin: 0; background-color: #ffffff;&#125;.share_p::after &#123; border: none;&#125; 43、position: fixed;居中 1234position: fixed;margin: 0 auto;left: 0;right: 0;","categories":[{"name":"前端","slug":"前端","permalink":"https://www.cqzhong.cn/categories/前端/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://www.cqzhong.cn/tags/微信小程序/"}]},{"title":"微信小程序图片上传至七牛云","slug":"微信小程序图片上传至七牛云","date":"2019-10-23T13:01:38.000Z","updated":"2020-11-03T10:21:35.068Z","comments":true,"path":"2019/10/23/微信小程序图片上传至七牛云/","link":"","permalink":"https://www.cqzhong.cn/2019/10/23/微信小程序图片上传至七牛云/","excerpt":"首先下载七牛云 在 SDK 目录下找到 qiniuUploader.js 文件，在需要使用上传功能的页面引用 qiniuUploader.js 文件， 该方法四个参数，上传成功的回调函数返回了成功上传图片的链接 获取七牛直传的 token，调取后台接口文档七牛模块的前端使用接口，获取 token 和域名. 在微信公众平台根据空间所属地添加上传服务器域名。","text":"首先下载七牛云 在 SDK 目录下找到 qiniuUploader.js 文件，在需要使用上传功能的页面引用 qiniuUploader.js 文件， 该方法四个参数，上传成功的回调函数返回了成功上传图片的链接 获取七牛直传的 token，调取后台接口文档七牛模块的前端使用接口，获取 token 和域名. 在微信公众平台根据空间所属地添加上传服务器域名。 [https://up-as0.qiniup.com](https://up-as0.qiniup.com) [https://up-na0.qiniup.com](https://up-na0.qiniup.com) [https://up-z1.qiniup.com](https://up-z1.qiniup.com) [https://up-z2.qiniup.com](https://up-z2.qiniup.com) [https://up.qiniup.com](https://up.qiniup.com) 请求封装参考微信小程序 request 封装 新建一个 qiniuUptoken.js 文件 1234567891011121314151617181920212223242526272829303132333435import qiniuUploader from \"../lib/qiniuUploader\";const request = require(\"./request.js\");// 获取七牛上传tokenconst uploadtoken = (params) =&gt; request.get(\"upload/token\", params);export const uploadYSCImage = (tmpFilePath) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; uploadtoken() .then((data) =&gt; &#123; qiniuUploader.upload( tmpFilePath, (res) =&gt; &#123; resolve(res); &#125;, (error) =&gt; &#123; reject(error); console.log(JSON.stringify(res, null, \" \")); &#125;, &#123; // 参数设置 region: \"ECN\", domain: \"\", //空间域名 key: `$&#123;new Date().valueOf()&#125;.png`, // 图片名字 uptoken: data, //后台获取到的token &#125;, (cancelTask) =&gt; &#123;&#125; ); &#125;) .catch((res) =&gt; &#123; reject(res); &#125;); &#125;);&#125;; 在需要上传图片的页面使用 1234import &#123; uploadYSCImage &#125; from \"../../../api/qiniuUptoken\";let path = \"图片地址\";uploadYSCImage(path).then((path) =&gt; &#123;&#125;);","categories":[{"name":"前端","slug":"前端","permalink":"https://www.cqzhong.cn/categories/前端/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://www.cqzhong.cn/tags/微信小程序/"},{"name":"七牛云","slug":"七牛云","permalink":"https://www.cqzhong.cn/tags/七牛云/"}]},{"title":"微信小程序request封装","slug":"微信小程序request封装","date":"2019-10-21T13:33:00.000Z","updated":"2020-11-03T10:21:35.050Z","comments":true,"path":"2019/10/21/微信小程序request封装/","link":"","permalink":"https://www.cqzhong.cn/2019/10/21/微信小程序request封装/","excerpt":"在微信小程序开发中，通过接口和后台进行交互，我们需要在每个页面的 js 文件中写：wx.request。 当接口很多时候，会在很多页面使用 request，显然我们需要对它进行一下封装。","text":"在微信小程序开发中，通过接口和后台进行交互，我们需要在每个页面的 js 文件中写：wx.request。 当接口很多时候，会在很多页面使用 request，显然我们需要对它进行一下封装。 首先新建一个 request.js 文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const request = (&#123; url = \"\", param = &#123;&#125;, ...other &#125; = &#123;&#125;) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; wx.request(&#123; url: getUrl(url), data: param, ...other, header: &#123; \"content-type\": \"application/x-www-form-urlencoded\", &#125;, success: (res) =&gt; &#123; // console.log(JSON.stringify(res, null, ' ')) if (res.data.code == 200) &#123; resolve(res.data.data); &#125; else &#123; reject(res.data); &#125; &#125;, fail: (err) =&gt; &#123; reject(err); &#125;, &#125;); &#125;);&#125;;const getUrl = (url) =&gt; &#123; if (url.indexOf(\"://\") == -1) &#123; url = \"这里是你的域名\" + url; &#125; return url;&#125;;//RequestMethodconst get = (url, param = &#123;&#125;) =&gt; &#123; return request(&#123; url, param, method: \"get\", &#125;);&#125;;const post = (url, param = &#123;&#125;) =&gt; &#123; return request(&#123; url, param, method: \"post\", &#125;);&#125;;module.exports = &#123; get, post,&#125;; 使用方法 eg：搜索接口，新建一个 search.js 文件。 123const request = require(\"./request.js\");export const hotWord = (params) =&gt; request.get(\"https://api09ecx7.zhuishushenqi.com/book/hot-word\", params); 在需要调用搜索接口页面 js 文件中 123456import &#123; hotWord &#125; from \"../api/search\";let paraM = &#123;&#125;;hotWord(paraM) .then((data) =&gt; &#123;&#125;) .catch((res) =&gt; &#123;&#125;);","categories":[{"name":"前端","slug":"前端","permalink":"https://www.cqzhong.cn/categories/前端/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://www.cqzhong.cn/tags/微信小程序/"}]},{"title":"Cocoapods 私有仓库","slug":"Cocoapods 私有仓库","date":"2019-10-14T04:58:06.000Z","updated":"2020-11-03T10:21:35.808Z","comments":true,"path":"2019/10/14/Cocoapods 私有仓库/","link":"","permalink":"https://www.cqzhong.cn/2019/10/14/Cocoapods 私有仓库/","excerpt":"一、创建存放 podspec 文件的仓库 1、创建私有 pod 仓库 Specs 2、在终端把远程的私有版本库添加到本地索引 1pod repo add Specs https://gitlab.com/ios/Specs.git","text":"一、创建存放 podspec 文件的仓库 1、创建私有 pod 仓库 Specs 2、在终端把远程的私有版本库添加到本地索引 1pod repo add Specs https://gitlab.com/ios/Specs.git 然后会要求输入账号和密码 123456Last login: Fri Mar 15 14:39:34 on ttys000caoqingzhongdeMacBook-Pro:~ caoqingzhong$ pod repo add Specs https://gitlab.com/ios/Specs.gitCloning spec repo `Specs` from `https://gitlab.com/ios/Specs.git`Username for 'https://gitlab.com': cqzPassword for 'https://cqz@gitlab.com':caoqingzhongdeMacBook-Pro:~ caoqingzhong$ master 是 cocoaPods 上版本库的列表 1open ~/.cocoapods/repos 二、创建代码仓库 1、Gitlab 上创建相关 demo 项目 2、先到要创建项目的目录然后执行。 1pod lib create NetworkReachability 1234567891011121314151617181920212223What platform do you want to use?? [ iOS / macOS ] &gt; iOSWhat language do you want to use?? [ Swift / ObjC ] （你用什么语言？） &gt; ObjCWould you like to include a demo application with your library? [ Yes / No ]（是否需要一个例子工程；） &gt; YesWhich testing frameworks will you use? [ Specta / Kiwi / None ]（选择一个测试框架；） &gt; NoneWould you like to do view based testing? [ Yes / No ]（是否基于View测试；） &gt; NoWhat is your class prefix?（类的前缀；） &gt; 3、然后本地文件夹路径会看到项目 4、替换 NetworkReachability 文件夹内的相关内容。 5、按照规范编写.podspec 文件。 6、在回到 Example 路径下，重新执行 pod install 操作 7、到相关目录验证.podspec 的正确性(如果通不过，也可以先提交至代码仓库，添加 tag，然后验证。) 121、pod lib lint 或者 pod spec lint 如果想要忽略警告：--allow-warnings eg: pod spec lint --allow-warnings2、如果有错误，查看详细信息：pod spec lint --verbose 8、当你看到 NetworkReachability.podspec passed validation 时，说明验证通过了 9、因为 podspec 文件中获取 Git 版本控制的项目还需要 tag 号，所以我们要打上一个 tag 1234567git statusgit add .git commit -m '编辑spec文件'git remote add origin https://gitlab.com:ios/NetworkReachability.git #添加远端仓库git push origin master #提交到远端git tag -m \"第一次提交\" \"0.0.1\" (要与NetworkReachability.podspec文件中的tag值保持一致)git push --tags #推送tag到远端仓库 10、向 Spec Repo 提交 podspec。执行 pod repo push 本地 repo 名 NAME.podspec --verbose --use-libraries --allow-warnings 123456789101112131415pod repo push Specs NetworkReachability.podspec当出现Validating spec -&gt; NetworkReachability (0.0.1)Updating the `Specs&apos; repoFrom https://gitlab.com/ios/Specs * [new branch] master -&gt; origin/masterAdding the spec to the `Specs&apos; repo - [Add] NetworkReachability (0.0.1)Pushing the `Specs&apos; repo 11、GitLab 端查看项目 12、查看 本地 Repos 三、私有库的使用 1、用 Xcode 打开编辑 Podfile 文件 1234567891011121314151617181920212223242526272829303132333435363738project &apos;FT_iPhone.xcodeproj&apos;# Uncomment the next line to define a global platform for your project platform :ios, &apos;9.0&apos; inhibit_all_warnings!source &apos;https://github.com/CocoaPods/Specs.git&apos;source &apos;https://github.com/aliyun/aliyun-specs.git&apos;source &apos;https://gitlab.com/ios/Specs.git&apos;target &apos;FT_iPhone&apos; do # Uncomment the next line if you&apos;re using Swift or would like to use dynamic frameworks # use_frameworks! # Pods for FT_iPhone#唱道私有库#网络监测pod &apos;NetworkReachability&apos;, &apos;~&gt; 0.0.2&apos;pod &apos;Font&apos;, &apos;~&gt; 0.0.3&apos;endpost_install do |installer| installer.pods_project.targets.each do |target| target.build_configurations.each do |config| config.build_settings[&apos;IPHONEOS_DEPLOYMENT_TARGET&apos;] = &apos;9.0&apos; # Pod文件在Debug模式下不进行编译优化,提升编译速度 if config.name.include?(&quot;Debug&quot;) config.build_settings[&apos;GCC_OPTIMIZATION_LEVEL&apos;] = &apos;0&apos; end end endend 2、 pod search NetworkReachability 3、查看本地的 pod 库索引 pod repo 4、使用与其它第三方库一样，只是私有库版本更新维护是自己处理 四、创建私有库遇到的坑 1、pod search 搜索不到问题 1pod repo update ，如果还搜索不到: pod search EmptyView --simple 可搜到 2、提交代码以后，打上 tag。然后再去验证 spec 或者是 lib 3、打上标签 123git tag -m \"first release\" \"0.1.0\" (要与DRCategories.podspec文件中的tag值保持一致)git push --tags #推送tag到远端仓库 4、推送到远端仓库 1执行 pod repo push 本地repo名 NAME.podspec --verbose --use-libraries --allow-warnings 5、清除本地 spec 文件缓存 123456789101112131415161718//查看所有spec文件的缓存，可以直接到路径下删除文件pod cache list//删除指定库的缓存文件pod cache clean AFNetworking//运行podfile文件但不更新本地spec文件pod install --no-repo-update最好使用 pod spec lint CZFTool.podspec --verbose (打印错误信息)如果有引用到库framwork或C语言库的话必须使用pod spec lint CZFTool.podspec --use-libraries // 验证pod trunk push CZFTool.podspec --use-libraries // 上传 6、- ERROR | [iOS] unknown: Encountered an unknown error (Unable to find a specification for XSLKeyChainCache (~&gt; 0.1.0) depended upon by XSLOpenUDID) during validation. 说明在你的本地 repo 里没有存在 XSLKeyChainCache 私有库 解决方案 pod repo update 更新本地的私有库 指定私有库路径 pod sepc lint 文件名.podspec --sources=‘https://gitlab.com/ios/LyricParser.git,https://gitlab.com/ios/Specs.git’ 7、本地私有 pods 1234#自定义的第三方#pod &apos;XLForm&apos;, :path =&gt; &apos;../../&apos;pod &apos;FPS&apos;, :path =&gt; &apos;./Programme/ThirdLibrary/FPS&apos;pod &apos;SCStackViewController&apos;, :path =&gt; &apos;./Programme/ThirdLibrary/SCStackView&apos; 8 在每一个私有库的下面写一个更新的脚本，避免繁琐的操作","categories":[{"name":"移动端","slug":"移动端","permalink":"https://www.cqzhong.cn/categories/移动端/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.cqzhong.cn/tags/iOS/"},{"name":"CocoaPods","slug":"CocoaPods","permalink":"https://www.cqzhong.cn/tags/CocoaPods/"},{"name":"组件化","slug":"组件化","permalink":"https://www.cqzhong.cn/tags/组件化/"}]},{"title":"Objective-C 中的各种遍历（迭代）方式","slug":"Objective-C 中的各种遍历（迭代）方式","date":"2019-10-12T13:41:04.000Z","updated":"2020-11-03T10:21:34.738Z","comments":true,"path":"2019/10/12/Objective-C 中的各种遍历（迭代）方式/","link":"","permalink":"https://www.cqzhong.cn/2019/10/12/Objective-C 中的各种遍历（迭代）方式/","excerpt":"使用 for 循环 要遍历字典、数组或者是集合，for 循环是最简单也用的比较多的方法，示例如下：","text":"使用 for 循环 要遍历字典、数组或者是集合，for 循环是最简单也用的比较多的方法，示例如下： 123456789101112131415161718192021222324252627282930313233343536// 普通的for循环遍历-(void)iteratorWithFor &#123; // 处理数组 NSArray *arrayM = @[@\"1\",@\"2\",@\"3\",@\"4\"]; NSInteger arrayMCount = [arrayM count]; for (int i = 0; i&lt;arrayMCount; i++) &#123; NSString *obj = arrayM[i]; NSLog(@\"%@\",obj); &#125; // 处理字典 NSDictionary *dictM = @&#123;@\"1\":@\"one\",@\"2\":@\"two\",@\"3\":@\"three\"&#125;; NSArray *dictKeysArray = [dictM allKeys]; for (int i = 0; i&lt;dictKeysArray.count; i++) &#123; NSString *key = dictKeysArray[i]; NSString *obj = [dictM objectForKey:key]; NSLog(@\"%@:%@\",key,obj); &#125; // 处理集合 NSSet * setM = [[NSSet alloc] initWithObjects:@\"one\",@\"two\",@\"three\",@\"four\", nil]; NSArray *setObjArray = [setM allObjects]; for (int i = 0; i&lt;setObjArray.count; i++) &#123; NSString *obj = setObjArray[i]; NSLog(@\"%@\",obj); &#125; // 反向遍历----降序遍历----以数组为例 NSArray *arrayM2 = @[@\"1\",@\"2\",@\"3\",@\"4\"]; NSInteger arrayMCount2 = [arrayM2 count] - 1; for (NSInteger i = arrayMCount2; i&gt;0; i--) &#123; NSString *obj = arrayM2[i]; NSLog(@\"%@\",obj); &#125;&#125; 优点：简单 缺点：由于字典和集合内部是无序的，导致我们在遍历字典和集合的时候需要借助一个新的『数组』作为中介来处理，多出了一部分开销。 二、使用 NSEnumerator 遍历 NSEnumerator 的使用和基本的 for 循环类似，不过代码量要大一些。示例如下： 12345678910111213141516171819202122232425262728293031323334353637// 使用NSEnumerator遍历-(void)iteratorWithEnumerator &#123; // 处理数组 NSArray *arrayM = @[@\"1\",@\"2\",@\"3\",@\"4\"]; NSEnumerator *arrayEnumerator = [arrayM objectEnumerator]; NSString *obj; while ((obj = [arrayEnumerator nextObject]) != nil) &#123; NSLog(@\"%@\",obj); &#125; // 处理字典 NSDictionary *dictM = @&#123;@\"1\":@\"one\",@\"2\":@\"two\",@\"3\":@\"three\"&#125;; NSEnumerator *dictEnumerator = [dictM keyEnumerator]; NSString *key; while ((key = [dictEnumerator nextObject]) != nil) &#123; NSString *obj = dictM[key]; NSLog(@\"%@\",obj); &#125; // 处理集合 NSSet * setM = [[NSSet alloc] initWithObjects:@\"one\",@\"two\",@\"three\",@\"four\", nil]; NSEnumerator *setEnumerator = [setM objectEnumerator]; NSString *setObj; while ((setObj = [setEnumerator nextObject]) != nil) &#123; NSLog(@\"%@\",setObj); &#125; // 反向遍历----降序遍历----以数组为例 NSArray *arrayM2 = @[@\"1\",@\"2\",@\"3\",@\"4\"]; NSEnumerator *arrayEnumerator2 = [arrayM2 reverseObjectEnumerator]; NSString *obj2; while ((obj2 = [arrayEnumerator2 nextObject]) != nil) &#123; NSLog(@\"%@\",obj2); &#125;&#125; 优点：对于不同的数据类型，遍历的语法相似；内部可以简单的通过 reverseObjectEnumerator 设置进行反向遍历。 缺点：代码量稍大。 三、使用 for...in 遍历 在 Objective-C 2.0 中增加了 for ...in 形式的快速遍历。此种遍历方式语法简洁，速度飞快。示例如下： 1234567891011121314151617181920212223242526// 使用for...In进行快速遍历-(void)iteratorWithForIn &#123; // 处理数组 NSArray *arrayM = @[@\"1\",@\"2\",@\"3\",@\"4\"]; for (id obj in arrayM) &#123; NSLog(@\"%@\",obj); &#125; // 处理字典 NSDictionary *dictM = @&#123;@\"1\":@\"one\",@\"2\":@\"two\",@\"3\":@\"three\"&#125;; for (id obj in dictM) &#123; NSLog(@\"%@\",dictM[obj]); &#125; // 处理集合 NSSet * setM = [[NSSet alloc] initWithObjects:@\"one\",@\"two\",@\"three\",@\"four\", nil]; for (id obj in setM) &#123; NSLog(@\"%@\",obj); &#125; // 反向遍历----降序遍历----以数组为例 NSArray *arrayM2 = @[@\"1\",@\"2\",@\"3\",@\"4\"]; for (id obj in [arrayM2 reverseObjectEnumerator]) &#123; NSLog(@\"%@\",obj); &#125;&#125; 优点： 语法简洁； 效率最高； 缺点：无法获得当前遍历操作所针对的下标。 四、基于 Block 的遍历方式 基于 Block 的方式来进行遍历是最新引入的方法。它提供了遍历数组|字典等类型数据的最佳实践。示例如下： 1234567891011121314151617181920212223242526// 基于块（block）的遍历方式-(void)iteratorWithBlock &#123; // 处理数组 NSArray *arrayM = @[@\"1\",@\"2\",@\"3\",@\"4\"]; [arrayM enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; NSLog(@\"%zd--%@\",idx,obj); &#125;]; // 处理字典 NSDictionary *dictM = @&#123;@\"1\":@\"one\",@\"2\":@\"two\",@\"3\":@\"three\"&#125;; [dictM enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key, id _Nonnull obj, BOOL * _Nonnull stop) &#123; NSLog(@\"%@:%@\",key,obj); &#125;]; // 处理集合 NSSet * setM = [[NSSet alloc] initWithObjects:@\"one\",@\"two\",@\"three\",@\"four\", nil]; [setM enumerateObjectsUsingBlock:^(id _Nonnull obj, BOOL * _Nonnull stop) &#123; NSLog(@\"%@\",obj); &#125;]; // 反向遍历----降序遍历----以数组为例 NSArray *arrayM2 = @[@\"1\",@\"2\",@\"3\",@\"4\"]; [arrayM2 enumerateObjectsWithOptions:NSEnumerationReverse usingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; NSLog(@\"%zd--%@\",idx,obj); &#125;];&#125; 优点： 遍历时可以直接从 block 中获得需要的所有信息，包括下标、值等。特别相对于字典而言，不需要做多余的编码即可同时获得 key 和 value 的值。 能够直接修改 block 中 key 或者 obj 的类型为真实类型，可以省去类型转换的工作。 可以通过NSEnumerationConcurrent枚举值开启并发迭代功能。 说明 基于 Block 的遍历方式在实现反向遍历的时候也非常简单，使用enumerateObjectsWithOptions方法，传递NSEnumerationReverse作为参数即可，在处理遍历操作的时候推荐基于 Block 的遍历方式。 五、使 GCD 中的dispatch_apply函数 使用GCD中的dispatch_apply函数也能实现字典、数组等的遍历，该函数比较适合处理耗时较长、迭代次数较多的情况。示例如下： 123456789101112// 使用GCD中的dispatch_apply函数-(void)iteratorWithApply &#123; // 处理数组 NSArray *arrayM = @[@\"1\",@\"2\",@\"3\",@\"4\"]; // 获得全局并发队列 dispatch_queue_t queue = dispatch_get_global_queue(0, 0); dispatch_apply(arrayM.count, queue, ^(size_t index) &#123; NSLog(@\"%@--%@\",arrayM[index],[NSThread currentThread]); &#125;);&#125; 优点：开启多条线程并发处理遍历任务，执行效率高。 缺点： 对于字典和集合的处理需借助数组； 无法实现反向遍历。","categories":[{"name":"移动端","slug":"移动端","permalink":"https://www.cqzhong.cn/categories/移动端/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.cqzhong.cn/tags/iOS/"},{"name":"遍历","slug":"遍历","permalink":"https://www.cqzhong.cn/tags/遍历/"}]},{"title":"Cocoapods 之组件化工具","slug":"Cocoapods 之组件化工具","date":"2019-10-12T04:58:06.000Z","updated":"2020-11-03T10:21:35.829Z","comments":true,"path":"2019/10/12/Cocoapods 之组件化工具/","link":"","permalink":"https://www.cqzhong.cn/2019/10/12/Cocoapods 之组件化工具/","excerpt":"一、Cocoapods 简介 每种语言发展到一个阶段，就会出现相应的依赖管理工具，例如 Java 语言的 Maven，nodejs 的 npm。随 着 iOS 开发者的增多，业界也出现了了为 iOS 程序提供依赖管理的工具，它的名字叫做:CocoaPods。 CocoaPods 项目是使用 Ruby 编写，源码在 Github 上管理。该项目开始于 2011 年 8 月 12 日，经过多年年发展， 现在已经成为 iOS 开发事实上的依赖管理标准工具。开发 iOS 项目不可避免地要使用第三方开源库， CocoaPods 的出现使得我们可以节省设置和更新第三方开源库的时间。","text":"一、Cocoapods 简介 每种语言发展到一个阶段，就会出现相应的依赖管理工具，例如 Java 语言的 Maven，nodejs 的 npm。随 着 iOS 开发者的增多，业界也出现了了为 iOS 程序提供依赖管理的工具，它的名字叫做:CocoaPods。 CocoaPods 项目是使用 Ruby 编写，源码在 Github 上管理。该项目开始于 2011 年 8 月 12 日，经过多年年发展， 现在已经成为 iOS 开发事实上的依赖管理标准工具。开发 iOS 项目不可避免地要使用第三方开源库， CocoaPods 的出现使得我们可以节省设置和更新第三方开源库的时间。 1.Cocoapods 官方手册 2.Cocoapods 是什么? 1Cocoapods 是 Swift 和 Objective-C Cocoa 项目依赖管理器。类似于Java 语言的 Maven， nodejs 的 npm。 3.Cocoapods 可以做什么? 1231. 集成三方项目，可以减少 Xcode 的繁琐配置，更加方便的管理项⽬依赖，解决项目依赖冲突问题。 2. 持续构建应用，减少重复编码⼯工作。3. 企业可以搭建自己的私有仓库，方便对企业内部公共组件的管理。4. 可以对不同编译环境下进行三方库依赖配置。(后续 Podfile 讲解中有举例例说明) 4.如何学习 Cocoapods ? 12建议一:网上查找解决方案;建议二:查看学习 Cocoapods 源码;(简单演示) 二、Cocoapods 安装 1.替换 Mac OS 自带 ruby 版本，推荐使用 RVM 管理 ruby 版本。【推 荐】 123说明: 如果不使用 rvm 管理 ruby 版本，请自行替换系统 ruby 版本。 如果使用系统ruby，会因系统版本过低，会导致 cocoapods 无法升级到最新版本。1. 安装 RVM `\\curl -sSL https://get.rvm.io | bash -s stable` 2. 安装 ruby 2.5.1 `rvm install 2.5.1`3. 默认使用 2.5.1 `rvm use 2.5.1 --default` 2.替换 gem 镜像源 1gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/ 3.更新、升级 gem 1sudo gem update --system 4.安装 Cocoapods 1sudo gem install cocoapods 5.替换 podspec 文件托管地址从 github 切换到国内 oschina 【可选】 123// 【先删除，再添加，再更新】pod repo remove masterpod repo add master http://git.oschina.net/akuandev/Specs.git pod repo add master https://gitcafe.com/akuandev/Specs.git pod repo update 6.设置 pod 仓库 1pod setup 7.测试 【如果有版本号，则说明已经安装成功】 1pod --version 8.利用 cocoapods 来安装第三方框架 123451. 进入要安装框架的项目的 .xcodeproj 同级文件夹 2. 在该文件夹中新建一个文件 Podfile3. 在文件中告诉 cocoapods 需要安装的框架信息 a.该框架支持的平台 b.适用的iOS版本 c.框架的名称 d.框架的版本 9.常用命令介绍 123456pod install # 安装三方库pod update # 更新三方库，会根据 Podfile 指定的版本号更新，如果没有指定版本号，会更新至目前最新版本 pod install --no-repo-update # 安装三方库，不更新本地 Repopod update --no-repo-update # 更新三方库，不更新本地 Repopod cache clean [NAME] # 清除本地三方库缓存pod cache clean --all # 清除所有本地三方库缓存pod outdated # 列列举当前 Podfile.lock 中版本过低的三方库 三、Podfile 官方文档 1.简介 12Podfile 是用于 Cocoapods 找出所有需要下载 Pod 的描述文件，是一个描述一个或多个Xcode项目的目标的依赖 关系的规范。Podfile 本质上是一个ruby文件，可在里面编写一些基本的 ruby 函数 2.创建 121. 进入需要使用 Cocoapods 管理的 .xcodeproj 项目目录下。2. 执行 pod init 命令，Cocoapods 会自动创建 Podfile 文件，并初始化一些必要参数 3.版本管理 12345= 0.1 # 版本号指定为 0.1&gt; 0.1 # 版本号大于 0.1&gt;= 0.1 # 版本号大于等于 0.1 &lt; 0.1 # 版本号小于 0.1&lt;= 0.1 # 版本号小于等于 0.1~&gt; 0.1.2 # 版本号在 0.1.2 至 0.2 之间，并且每次更新都会取 0.1.2 ~ 0.2.0 之间的最新版本，一般使用该 方式管理版本(三方库再不更新API的情况下，一般不会升级大版本。如果有API的改变，必要时需要使用 = 0.1 ) 4.编译环境配置 123451. 在 Podfile 中，可以指定对对应的编译环境进⾏行行配置依赖。(编译环境需提前在xcode中配置)举例例: 在 Debug, ADHoc 环境下，需要集成 Bugtags 来进⾏行行调试，但是在 Release 发布环境下，需要移除 Bugtags。pod &apos;Bugtags&apos;, :configurations =&gt; [&apos;Debug&apos;, &apos;ADHoc&apos;] # 多个环境pod &apos;Bugtags&apos;, :configuration =&gt; &apos;Debug&apos; # 单个环境 5.指定搜索源 source 12cocoapods 会在指定的 source 路路径下检索该三方库pod &apos;PonyDebugger&apos;, :source =&gt; &apos;https://github.com/CocoaPods/Specs.git&apos; 6.指定依赖三方库的子项目。(可以去除不必要的依赖) 12pod &apos;QueryKit/Attribute&apos;pod &apos;QueryKit&apos;, :subspecs =&gt; [&apos;Attribute&apos;, &apos;QuerySet&apos;] 7.依赖本地库。(主要用于项目组件化管理) 1pod &apos;AFNetworking&apos;, :path =&gt; &apos;~/Documents/AFNetworking&apos; 8.依赖 git 仓库下的指定资源 123pod &apos;AFNetworking&apos;, :git =&gt; &apos;https://github.com/gowalla/AFNetworking.git&apos; # master pod &apos;AFNetworking&apos;, :git =&gt; &apos;https://github.com/gowalla/AFNetworking.git&apos;, :branch =&gt; &apos;dev&apos; # dev分支pod &apos;AFNetworking&apos;, :git =&gt; &apos;https://github.com/gowalla/AFNetworking.git&apos;, :tag =&gt; &apos;0.7.0&apos; # 0.7.0 tag 版本pod &apos;AFNetworking&apos;, :git =&gt; &apos;https://github.com/gowalla/AFNetworking.git&apos;, :commit =&gt; &apos;082f8319af&apos; # 指定提交版本 9.指定依赖 podspec 文件 12会去指定的 podspec 文件查找源文件。(后续会对 podspec 文件进⾏行行讲解) pod &apos;JSONKit&apos;, :podspec =&gt; &apos;https://example.com/JSONKit.podspec&apos; 10.plugin cocoapods 插件 1234可以在 cocoapods 中使用插件，具体插件用发可参照使用的插件本身介绍。 命令介绍:1. pod plugins list # 检索当前能用的插件2. pod plugins search xxx # 搜索指定插件3. pod plugins installed # 列列举当前已经安装的插件 11.eg: 1234567891011121314151617181920212223242526platform :ios, &apos;9.0&apos; # 代表平台是 ios，版本是 9.0 inhibit_all_warnings! # 忽略所有 Pods 项目内的警告 use_frameworks! # 使用 framework 进行三方库构建# cocoapods-keys 插件，可自动生成项目依赖，加密部分参数# pod install 时会让输入各种参数配置，在项目中可以直接使用 # 例如友盟，极光，等三方平台的 AppKey 可以使用该方式进行管理 plugin &apos;cocoapods-keys&apos;, &#123; :target =&gt; &quot;TestPlugin&quot;, :keys =&gt; [ &quot;ArtsyAPIClientSecret&quot;, &quot;ArtsyAPIClientKey&quot;, &quot;HockeyProductionSecret&quot;, &quot;HockeyBetaSecret&quot;, &quot;MixpanelProductionAPIClientKey&quot;,]&#125;target &apos;MyApp&apos; do # 项目的 Target 名称pod &apos;ObjectiveSugar&apos;, &apos;~&gt; 0.5&apos; # 代表项目 MyApp 依赖 版本号在 0.5 ~ 0.x 之间的ObjectiveSugar 三方库pod &apos;SSZipArchive&apos;, :inhibit_warnings =&gt; false # 不忽略警告target &quot;MyAppTests&quot; do # 测试 Targetinherit! :search_paths # 继承父项目 MyApp 的所有 search_paths，在此项目内，可以使用ObjectiveSugarpod &apos;OCMock&apos;, &apos;~&gt; 2.0.1&apos; # 对该 Target 唯一使用的三方库end end# 此方法是在执行 pod install 之前，会调用的方法，允许在下载三方代码之后但在安装之前对Pod进行任何更改。 pre_install do |installer|installer.pods_project.targets.each do |target| puts &quot;#&#123;target.name&#125;&quot;end end# 此方法允许在生成的 Xcode 项目写入磁盘之前对其进行任何最后更改。 post_install do |installer|installer.pods_project.targets.each do |target| puts &quot;#&#123;target.name&#125;&quot;end end 四、Podspec 文件介绍 1.简介 1podspec 文件规范描述了了 Pod 库的一个版本。它包括有关应从何处获取源，要使用的文件，要应⽤的构建设置以及其 他常规元数据(如名称，版本和说明)的详细信息。 2.创建 1方法一:直接拷⻉现有的 podspec 文件进⾏修改 方法二:使用 pod 命令 `pod spec create xxx` 创建 3.podspec 内字段含义介绍 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#### ==========配置============ #### s.name = &quot;Demo&quot; # 必须和文件名保持一致 s.version = &quot;0.0.1&quot; # 版本号 s.summary = &quot;LLBPayManager&quot; # 简单描述 s.description = &lt;&lt;-DESC # 详细描述 LLBPayManager DESC s.homepage = &quot;http://gitlab.langlib.io/clientlib_ios/LLBPayManager.git&quot; # 主页 s.license = &quot;MIT&quot; # 许可协议 s.author = &#123; &quot;Minlison&quot; =&gt; &quot;yuanhang@langlib.com&quot; &#125; # 作者，可多个 s.platform = :ios, &quot;8.0&quot; # 平台 tvos, ios, osx s.ios.deployment_target = &apos;8.0&apos; # 与platform 中的版本号相同 s.source = &#123; :git =&gt; &quot;http://gitlab.langlib.io/clientlib_ios/LLBPayManager.git&quot;, :tag =&gt; &quot;#&#123;s.version&#125;&quot; &#125; # 源文件存放地址 git, http, svn ,支持 tag, commit, sha1 算法匹配 s.documentation_url = &quot;http://gitlab.langlib.io/clientlib_ios/LLBPayManager.git/LLBPayManager/docs/index.html&quot; # 文档 s.requires_arc = true # 是否是 ARC # s.requires_arc = &quot;Classes/Arc&quot; # arc 的文件 # s.requires_arc = [&quot;Classes/Arc&quot;,&quot;Classes/Arc.mm&quot;] # arc 文件数组 s.default_subspec = &quot;Default&quot; # 默认子模块 s.default_subspecs = &quot;Default&quot; # 默认子模块 s.static_framework = true # 是否使用静态 framework s.swift_version = &quot;4.2&quot; # swift 版本号 s.cocoapods_version = &quot;&gt;= 1.5.3&quot; # cocoapods 版本号 s.social_media_url = &quot;https://twitter.com/cocoapods&quot; # 视频 s.screenshot = &quot;http://dl.dropbox.com/u/378729/MBProgressHUD/1.png&quot; # 截图 # s.screenshots = [ &quot;http://dl.dropbox.com/u/378729/MBProgressHUD/1.png&quot;] # 截图 s.prepare_command = &quot;ruby build_files.rb&quot; # 安装该库之前执行的脚本 s.deprecated = false # 是否已经废弃 s.ios.framework = &quot;CFNetwork&quot; # 依赖系统 framework ，可以指定平台 # s.frameworks = &quot;CoreData&quot; # 依赖系统framework，全部平台 s.weak_framework = &quot;UserNotifications&quot; # 弱链接，比如说一个项目同时兼容iOS6和iOS7，但某一个framework只在iOS7上有，这时候如果用强链接，那么在iOS7上运行就会crash，使用weak_frameworks可以避免这种情况。 # s.weak_frameworks = [&quot;UserNotifications&quot;, &quot;SafariServices&quot;] s.ios.vendored_frameworks = &quot;A.framework&quot; # 自定义framework 只针对iOS平台 # s.vendored_frameworks = &quot;A.framework&quot;, &quot;B.framework&quot; # 自定义framework ，全部平台 s.ios.library = &quot;xml2&quot; # 系统静态库，可以指定平台 # s.libraries = &quot;xml2&quot;, &apos;z&apos; # 系统静态库数组，全部平台 s.ios.vendored_library = &quot;libTest.a&quot; # 自定义静态库 只针对iOS平台 # s.vendored_libraries = &quot;libTest1.a&quot;, &quot;libTest2.a&quot; # 自定义静态库，全部平台 s.compiler_flags = &apos;-DOS_OBJECT_USE_OBJC=0&apos;, &apos;-Wno-format&apos; # 编译参数，在BuildSetting 中可设置 s.xcconfig = &#123; &apos;OTHER_LDFLAGS&apos; =&gt; &apos;-lObjC&apos; &#125; # 针对整个项目 s.pod_target_xcconfig = &#123; &apos;OTHER_LDFLAGS&apos; =&gt; &apos;-lObjC&apos; &#125; # pod 的 target 项目配置 s.user_target_xcconfig = &#123; &apos;MY_SUBSPEC&apos; =&gt; &apos;YES&apos; &#125; # 主工程的 target 配置 s.prefix_header_contents = &quot;#import &lt;UIKit/UIKit.h&gt;&quot;, &quot;#import &lt;Foundation/Foundation.h&gt;&quot; # pch 文件内容 s.prefix_header_file = &apos;iphone/include/prefix.pch&apos; # pch 文件 s.module_name = &apos;Demo&apos; # swift 模块名 s.header_dir = &apos;Header&apos; # 头文件存放位置，主要目的是为项目中引用头文件时使用 &lt;&gt; 找不到报错，React 中就有用到 s.header_mappings_dir = &apos;src/include&apos; # 头文件文件夹目录结构 s.script_phase = &#123; :name =&gt; &apos;Hello World&apos;, :script =&gt; &apos;echo &quot;Hello World&quot;&apos; &#125; # 编译时执行的脚本 # s.script_phases = [ &#123; :name =&gt; &apos;Hello World&apos;, :script =&gt; &apos;echo &quot;Hello World&quot;&apos; &#125; ] s.source_files = &quot;Classes/**/*.&#123;h,m&#125;&quot; # 源文件路径，是只相对 podspec 文件所在文件夹的路径，匹配正则 s.public_header_files = &quot;Headers/Plublic/*.h&quot; # 公开头文件 s.private_header_files = &quot;Headers/Private/*.h&quot; # 私有头文件，不会对外暴露 s.ios.resource_bundle = &#123;&quot;Box&quot; =&gt; &quot;Image/*.png&quot;&#125; # bundle 资源文件 # s.resource_bundles = &#123;&quot;Box&quot; =&gt; [&quot;Image/*.png&quot;,&quot;Text/*.txt&quot;], &quot;OtherBox&quot; =&gt; [&quot;Image1/*.png&quot;]&#125; # bundle 资源文件 s.resource = &quot;Resources/HockeySDK.bundle&quot; # 资源文件，支持所有文件，bundle，imageasset，png, jpg, gif, ttf 等 s.resources = [&quot;image/*.png&quot;,&quot;font/*.ttf&quot;] s.ios.exclude_files = &apos;Classes/osx&apos; # 不包含文件，多用于跨平台 # s.exclude_files = &apos;Classes/**/unused.&#123;h,m&#125;&apos; s.preserve_path = &quot;aa.txt&quot; # 受保护的文件，下载以后，不会被删除, Cocoapods 默认会删除 podspec 没有引用到的文件， 多用与静态库，framework，资源文件等 s.module_map = &apos;source/module.modulemap&apos; # modulemap 文件，Cocoapods 默认会自己创建 s.subspec &quot;Demo1&quot; do |ss| # 上述属性大多数子模块都可使用 ss.dependency &quot;JSONKit&quot; # 依赖，此处可以是公开库，私有库，本地库（前提是在主工程安装） ss.subspec &quot;Demo11&quot; do |sss| ss.dependency &quot;AFNetworking&quot;, &quot;~&gt; 1.0.0&quot; end end 五、Cocoapods 私有仓库 简介 1Cocoapods 私有仓库，本质是一个git仓库，只用来存放 podspec 文件 2.作⽤ 1统一管理公司内部依赖库的版本号，并且可作为历史回归，可以让不同App使⽤不同的版本; 3.创建 11. 在gitlab，gitoschina，github等平台，创建一个公开(私有需要分配响应的权限)的git仓库; 2. 在本地使用 pod repo add $&#123;REPO_NAME&#125; $&#123;SOURCE_URL&#125; 添加私有仓库即可; 4.推送 podspec 文件到私有仓库 1231. 在新建的podspec 文件夹下，使用 pod spec lint xxx.podspec 检验podspec文件格式是否正确;2. 检验私有库是否编译成功，pod lib lint xxx.podspec3. 推送到私有仓库 pod repo push $&#123;REPO_NAME&#125; xxx.podspec # 如果是公开库，需要配置 trunk (另 说) 12345678910小技巧:某些时候，会遇到 podspec 文件依赖本地库，或者是依赖别的三方比较难下载和验证的时候，或者是没有包含i386, x86_64 的静态库，就会一直报错;这时候，如果能保证库本身没有问题，可以改本地 cocoapods 源码，绕过验证，直接推送到私有仓库1. which pod 找到 pod 命令所在位置2. pod --version 打印当前cocoapods 版本3. 在pod 命令所在的上级文件夹，找 cocoapods指定版本的源码文件存放位置4. 找到 lib/cocoapods/validator.rb 并找到函数 def validate ，在 @results = [] 下方直接return true 即可 六、几个问题 一、pod search xxx 查找不到，但是确定是有该库 1解决办法: 删除 ~/Library/Caches/CocoaPods/search_index.json 二、pod install 不更新库文件 12345678910解决办法:删除需要更新文件的仓库缓存1. pod cache clean xxx2. 删除 ~/Library/Caches/CocoaPods/Pods 目录下的指定⼯工程的缓存//查看所有spec文件的缓存，可以直接到路径下删除文件pod cache list//删除指定库的缓存文件pod cache clean AFNetworking//运行podfile文件但不更新本地spec文件pod install --no-repo-update","categories":[{"name":"移动端","slug":"移动端","permalink":"https://www.cqzhong.cn/categories/移动端/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.cqzhong.cn/tags/iOS/"}]},{"title":"iOS定时器总结","slug":"iOS定时器总结","date":"2019-10-11T03:41:00.000Z","updated":"2020-11-03T10:21:35.523Z","comments":true,"path":"2019/10/11/iOS定时器总结/","link":"","permalink":"https://www.cqzhong.cn/2019/10/11/iOS定时器总结/","excerpt":"iOS 中常用的定时器有三种，分别是 NSTimer，CADisplayLink 和 GCD。","text":"iOS 中常用的定时器有三种，分别是 NSTimer，CADisplayLink 和 GCD。 NSTimer 两种方式创建 创建方式 1 1234NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:2 target:self selector:@selector(test) userInfo:nil repeats:YES]; // 停止定时器 [timer invalidate]; timer == nil 创建方式 2 123456NSTimer *timer = [NSTimer timerWithTimeInterval:2 target:self selector:@selector(test) userInfo:nil repeats:YES]; // 将定时器添加到runloop中，否则定时器不会启动 [[NSRunLoop mainRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; // 停止定时器 [timer invalidate]; timer == nil 方式 1 会自动将创建的定时器以默认方式添加到当前线程 runloop 中，而无需手动添加。但是在此种模式下，当滚动屏幕时 runloop 会进入另外一种模式，定时器会暂停，为了解决这种问题，可以像方式 2 那样把定时器添加到 NSRunLoopCommonModes 模式下。 方式 1 和方式 2 在设置后都会在间隔设定的时间（本例中设置为 2s）后执行 test 方法，如果需要立即执行可以使用下面的代码。 [time fire]; 不过，NSTimer 相对来说是不精确的，参考苹果官方文档介绍 timer 问题 1.NSTimer 加在 main runloop 中，模式是 NSDefaultRunLoopMode，main 负责所有主线程事件，例如 UI 界面的操作，复杂的运算，这样在同一个 runloop 中 timer 就会产生阻塞。 2.模式的改变。主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。 当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个 ScrollView 时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作。所以就会影响到 NSTimer 不准的情况。 PS:DefaultMode 是 App 平时所处的状态，rackingRunLoopMode 是追踪 ScrollView 滑动时的状态。 解决办法 123456789101112131415方案1.在主线程中进行NSTimer操作，但是将NSTimer实例加到main runloop的特定mode（模式）中。避免被复杂运算操作或者UI界面刷新所干扰。NSTimer *timer = [NSTimer timerWithTimeInterval:1 target:self selector:@selector(test) userInfo:nil repeats:YES];[[NSRunLoop currentRunLoop] addTimer:timer forMode:NSRunLoopCommonModes];方案2.在子线程中进行NSTimer的操作，再在主线程中修改UI界面显示操作结果；- (void)timer2 &#123; NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(newThread) object:nil]; [thread start];&#125;- (void)newThread &#123; @autoreleasepool &#123; [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(showTime) userInfo:nil repeats:YES]; [[NSRunLoop currentRunLoop] run]; &#125;&#125; CADisplayLink 12345678CADisplayLink *displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(test:)]; // 将创建的displaylink添加到runloop中，否则定时器不会执行 [displayLink addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode]; // 停止定时器 [displayLink invalidate]; displayLink = nil;当把CADisplayLink对象add到runloop中后，selector就能被周期性调用，类似于重复的NSTimer被启动了；执行invalidate操作时，CADisplayLink对象就会从runloop中移除，selector调用也随即停止，类似于NSTimer的invalidate方法 注意点： iOS 并不能保证能以每秒 60 次的频率调用回调方法，这取决于： 1、CPU 的空闲程度 如果 CPU 忙于其它计算，就没法保证以 60HZ 执行屏幕的绘制动作，导致跳过若干次调用回调方法的机会，跳过次数取决 CPU 的忙碌程度。 2、执行回调方法所用的时间 如果执行回调时间大于重绘每帧的间隔时间，就会导致跳过若干次回调调用机会，这取决于执行时间长短。 总结： 从原理上不难看出，CADisplayLink 使用场合相对专一，适合做界面的不停重绘，比如视频播放的时候需要不停地获取下一帧用于界面渲染。 GCD 定时器 一次性定时 1234567dispatch_time_t timer = dispatch_time(DISPATCH_TIME_NOW, 1.0 * NSEC_PER_SEC); dispatch_after(timer, dispatch_get_main_queue(), ^(void)&#123; NSLog(@\"GCD-----%@\",[NSThread currentThread]); &#125;); 重复执行的定时器 1234567891011121314151617181920212223242526272829303132&#123; //0.创建队列 dispatch_queue_t queue = dispatch_get_main_queue(); //1.创建GCD中的定时器 /* 第一个参数:创建source的类型 DISPATCH_SOURCE_TYPE_TIMER:定时器 第二个参数:0 第三个参数:0 第四个参数:队列 */ dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue); //2.设置时间等 /* 第一个参数:定时器对象 第二个参数:DISPATCH_TIME_NOW 表示从现在开始计时 第三个参数:间隔时间 GCD里面的时间最小单位为 纳秒 第四个参数:精准度(表示允许的误差,0表示绝对精准) */ dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 1.0 * NSEC_PER_SEC, 0 * NSEC_PER_SEC); //3.要调用的任务 dispatch_source_set_event_handler(timer, ^&#123; NSLog(@\"GCD-----%@\",[NSThread currentThread]); &#125;); //4.开始执行 dispatch_resume(timer); // self.timer = timer;&#125; 注意的地方： 此处注意一定要强引用定时器 ，否则定时器执行到 } 后将会被释放，无定时效果。GCD 定时器时间非常精准，最小的定时时间可以达到 1 纳秒，所以用在非常精确的定时场合。 NSObject 的方法也有类似功能的方法 12- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay;","categories":[{"name":"移动端","slug":"移动端","permalink":"https://www.cqzhong.cn/categories/移动端/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.cqzhong.cn/tags/iOS/"},{"name":"定时器","slug":"定时器","permalink":"https://www.cqzhong.cn/tags/定时器/"}]},{"title":"iOS 统计用户来源数据","slug":"iOS 统计用户来源数据","date":"2019-09-19T06:04:11.000Z","updated":"2020-11-03T10:21:35.294Z","comments":true,"path":"2019/09/19/iOS 统计用户来源数据/","link":"","permalink":"https://www.cqzhong.cn/2019/09/19/iOS 统计用户来源数据/","excerpt":"用户获取来源包括 App Store 浏览、App Store 搜索、App 引荐来源和网页引荐来源。 当顾客在 App Store 中浏览或搜索时查看了您的 App，“展示次数”和“产品页面查看次数”便归因于“App Store 浏览”或“App Store 搜索”。 当顾客通过轻点某个 App 中或网页中的链接访问您的 App Store 产品页，随即产生的“产品页面查看次数”便归因于引荐的 App 或网页。如果顾客随后首次轻点下载了 App，则产生的“App 购买量”也会归因于引荐的 App 或网页。","text":"用户获取来源包括 App Store 浏览、App Store 搜索、App 引荐来源和网页引荐来源。 当顾客在 App Store 中浏览或搜索时查看了您的 App，“展示次数”和“产品页面查看次数”便归因于“App Store 浏览”或“App Store 搜索”。 当顾客通过轻点某个 App 中或网页中的链接访问您的 App Store 产品页，随即产生的“产品页面查看次数”便归因于引荐的 App 或网页。如果顾客随后首次轻点下载了 App，则产生的“App 购买量”也会归因于引荐的 App 或网页。 一、使用苹果 ItunesConnect 后台的营销活动 1、 登录 itunesconnect —&gt;App 分析 —&gt;点击任一款 app —&gt;来源 —&gt;App 引荐来源。通过这几个步骤就能看到不同 app 的引荐来源。另外，还能看到网页的引荐来源： 2、生成一个营销活动链接 打开 itunesconnect ，然后登录开发者账号。然后点击 App 分析 点击你要进行营销推广的 App 点击来源，然后选中营销活动 点击右上角的生成营销活动链接 输入营销互动，然后在下面的营销活动链接里面复制此营销活动特有的 AppStore 链接。 生辰的链接用于投放，这样，我们就能统计到不同渠道的下载量了。 3、激活 5 个以上才能在 iTunes Connect 上展示，数据展示一般是有 1 天的时间延迟。 二、使用 SFSafariViewController 传递参数 1SFSafariViewController 是 iOS 9.0 出现的，可以通过 Safari 对应的 cookier 传递参数，跨App与Safari共享数据。但是 openurl 失败率还是很高，并且有系统版本、浏览器等限制，比如微信等第三方 App 的内置浏览器就不能很好实现。 三、通过 IDFA 进行追踪 Google Analytics 常用的比如谷歌官方的 Google Analytics，它的获取原理就是通过获取设备的 IDFA ，来作为唯一标示符号，然后根据你的渠道来源提供数据，通过比对的方式进行渠道定位。弊端在于，用户重置系统，或者关闭广告跟踪的话，这种方法就会失效。 目前用户的隐私保护意识也在逐渐觉醒，只要用户手握这个开关，IDFA 的统计误差就始终存在。 另一方面，Google Analytics 的 iOS 安装跟踪功能仅适用于通过移动广告网络（例如投放应用内广告的 AdMob）投放的广告。也就是如果渠道是从线下扫二维码或者 web 上的推广链接下载是不能通过这种方法跟踪到的，这时就需要其它工具作为补充。 四、采用第三方 SDK 追踪 1、神策数据：App 渠道追踪 2、openinstall","categories":[{"name":"移动端","slug":"移动端","permalink":"https://www.cqzhong.cn/categories/移动端/"},{"name":"其它","slug":"移动端/其它","permalink":"https://www.cqzhong.cn/categories/移动端/其它/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.cqzhong.cn/tags/iOS/"},{"name":"AppStore","slug":"AppStore","permalink":"https://www.cqzhong.cn/tags/AppStore/"}]},{"title":"约定式提交规范","slug":"约定式提交规范","date":"2019-09-19T06:04:11.000Z","updated":"2020-11-03T10:21:35.030Z","comments":true,"path":"2019/09/19/约定式提交规范/","link":"","permalink":"https://www.cqzhong.cn/2019/09/19/约定式提交规范/","excerpt":"约定式提交规范 注：scope 选填，body 选填 footer 选填","text":"约定式提交规范 注：scope 选填，body 选填 footer 选填 feat：新功能（feature） fix：修补 bug docs：文档（documentation） style： 格式（不影响代码运行的变动） refactor：重构（即不是新增功能，也不是修改 bug 的代码变动） perf: 优化相关，比如提升性能、体验 test：增加测试 chore：构建过程或辅助工具的变动，改变构建流程、或者增加依赖库、工具等 improvement： 用于对当前实现进行改进而没有添加新功能或修复错误的提交 revert: 回滚到上一个版本","categories":[{"name":"其它","slug":"其它","permalink":"https://www.cqzhong.cn/categories/其它/"}],"tags":[{"name":"规范","slug":"规范","permalink":"https://www.cqzhong.cn/tags/规范/"}]},{"title":"iOS获取AppStore的ipa，以及包内资源","slug":"iOS获取AppStore的ipa，以及包内资源","date":"2019-09-13T13:41:04.000Z","updated":"2020-11-03T10:21:35.468Z","comments":true,"path":"2019/09/13/iOS获取AppStore的ipa，以及包内资源/","link":"","permalink":"https://www.cqzhong.cn/2019/09/13/iOS获取AppStore的ipa，以及包内资源/","excerpt":"1、获取 Apple Configurator 2 2、打开 Apple Configurator 2，并连接 iPhone，点击 Apple Configurator 2 菜单中-&gt;账户-&gt;登录（用连接设备的 Apple ID）","text":"1、获取 Apple Configurator 2 2、打开 Apple Configurator 2，并连接 iPhone，点击 Apple Configurator 2 菜单中-&gt;账户-&gt;登录（用连接设备的 Apple ID） 3、选中界面中的手机画面，这时候“添加”按钮变为可点击状态 4、点击上图中的应用，选择你要下载的 app 5、等待下载完成 6、当下载出现下图提示时候，不要进行操作，直接进入以下目录查找已经下载的 ipa 1~/Library/Group Containers/K36BKF7T3D.group.com.apple.configurator/Library/Caches/Assets/TemporaryItems/MobileApps/ 7、将 ipa 拷贝出来，关闭 Apple Configurator 2 8、解压获取 ipa 内的内容。 9、找到.car 文件 10、解压 Assets.car 下载一个 cartool 11、执行编译获取 cartool 文件 12、打开终端 依次拖入 （1）cartool 文件 （2）Assets.car 文件 （3）解压至图片的文件夹. 回车执行，获取所有图片","categories":[{"name":"移动端","slug":"移动端","permalink":"https://www.cqzhong.cn/categories/移动端/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.cqzhong.cn/tags/iOS/"},{"name":"cartool","slug":"cartool","permalink":"https://www.cqzhong.cn/tags/cartool/"},{"name":"ipa","slug":"ipa","permalink":"https://www.cqzhong.cn/tags/ipa/"}]},{"title":"React Native介绍","slug":"React Native介绍","date":"2019-08-16T02:00:00.000Z","updated":"2020-11-03T10:21:35.278Z","comments":true,"path":"2019/08/16/React Native介绍/","link":"","permalink":"https://www.cqzhong.cn/2019/08/16/React Native介绍/","excerpt":"一、背景 原生（Native）应用因其性能优秀、体验较好而获得了广大用户和开发者的欢迎。但是，原生应用开发周期长、支持设备有限等问题也困扰着开发者和商户，因而，跨平台移动应用开发成为技术开发者的重要追求。 由于 Apple 严格的审核标准，iOS 应用的发版很受影响，这对于大多数团队来说是不能接受的，所以热更新对于 iOS 应用来说就显得尤其重要。","text":"一、背景 原生（Native）应用因其性能优秀、体验较好而获得了广大用户和开发者的欢迎。但是，原生应用开发周期长、支持设备有限等问题也困扰着开发者和商户，因而，跨平台移动应用开发成为技术开发者的重要追求。 由于 Apple 严格的审核标准，iOS 应用的发版很受影响，这对于大多数团队来说是不能接受的，所以热更新对于 iOS 应用来说就显得尤其重要。 二、React Native 介绍 React Native (简称 RN)是 Facebook 于 2015 年 4 月开源的跨平台移动应用开发框架，是 Facebook 早先开源的 JS 框架 React 在原生移动应用平台的衍生产物，目前支持 iOS 和安卓两大平台。 使用语言：Javascript，类似于 HTML 的 JSX，以及变异 CSS 来开发移动应用。 React Native 是以 iOS 或者 Anroid 原生控件为后端，但以 React component 的方式 Expose 出来进行视图渲染的。所以能够达到界面流畅的效果。 编辑器：Visual Studio Code、 Xcode、Android Studio 三、React Native 的应用场景 1、纯 RN 的 App，适用于一些界面比较少，功能比较简单的 App。 2、APP 只有部分页面是由 React Native 实现的，比如：我们常用的携程 App，它的首页下的很多模块都是由 React Native 实现的，这种开发模式被称为混合开发 3、采用 React Native 可以实现热更新。 四、React Native 混合开发（iOS 篇） 配置好 React Native 依赖和项目结构。 配置项目目录结构: 首先创建一个空目录用于存放 React Native 项目，然后在其中创建一个/ios 子目录，把你现有的 iOS 项目拷贝到/ios 子目录中。 安装 JavaScript 依赖包，创建 package.json 的空文本文件。执行以下命令 1yarn add react-native 所有 JavaScript 依赖模块都会被安装到项目根目录下的 node_modules/目录中（这个目录我们原则上不复制、不移动、不修改、不上传，随用随装）。 iOS 原生应用内，使用 CocoaPods 倒入相关组件 1234567891011121314151617181920212223242526pod 'React', :path =&gt; '../node_modules/react-native/'pod 'React-Core', :path =&gt; '../node_modules/react-native/React'pod 'React-DevSupport', :path =&gt; '../node_modules/react-native/React'pod 'React-fishhook', :path =&gt; '../node_modules/react-native/Libraries/fishhook'pod 'React-RCTActionSheet', :path =&gt; '../node_modules/react-native/Libraries/ActionSheetIOS'pod 'React-RCTAnimation', :path =&gt; '../node_modules/react-native/Libraries/NativeAnimation'pod 'React-RCTBlob', :path =&gt; '../node_modules/react-native/Libraries/Blob'pod 'React-RCTImage', :path =&gt; '../node_modules/react-native/Libraries/Image'pod 'React-RCTLinking', :path =&gt; '../node_modules/react-native/Libraries/LinkingIOS'pod 'React-RCTNetwork', :path =&gt; '../node_modules/react-native/Libraries/Network'pod 'React-RCTSettings', :path =&gt; '../node_modules/react-native/Libraries/Settings'pod 'React-RCTText', :path =&gt; '../node_modules/react-native/Libraries/Text'pod 'React-RCTVibration', :path =&gt; '../node_modules/react-native/Libraries/Vibration'pod 'React-RCTWebSocket', :path =&gt; '../node_modules/react-native/Libraries/WebSocket'pod 'React-cxxreact', :path =&gt; '../node_modules/react-native/ReactCommon/cxxreact'pod 'React-jsi', :path =&gt; '../node_modules/react-native/ReactCommon/jsi'pod 'React-jsiexecutor', :path =&gt; '../node_modules/react-native/ReactCommon/jsiexecutor'pod 'React-jsinspector', :path =&gt; '../node_modules/react-native/ReactCommon/jsinspector'pod 'yoga', :path =&gt; '../node_modules/react-native/ReactCommon/yoga'pod 'DoubleConversion', :podspec =&gt; '../node_modules/react-native/third-party-podspecs/DoubleConversion.podspec'pod 'glog', :podspec =&gt; '../node_modules/react-native/third-party-podspecs/glog.podspec'pod 'Folly', :podspec =&gt; '../node_modules/react-native/third-party-podspecs/Folly.podspec' 1pod install 添加入口内文件：index.ios.js (注意 index.js、 index.ios.js、 index.android.js、index.native.js 含义不同 参见 特定平台代码 ) 在入口类文件中 import 相关 js 页面，打包生成 jsbundle 文件时候，是从入口类文件里面找它所有 import 的文件然后合并导出到 main.jsbundle 将 main.jsbundle 导入到 Xcode 工程内。 iOS 加载 React Native 页面 （在开发、测试环境调试时候，需要本地开启一个 nodejs 的服务， 开发完成后将 js 打包为 jsbundle 文件集成到项目中） 12345678910111213141516171819202122#import &lt;React/RCTBundleURLProvider.h&gt;#import &lt;React/RCTRootView. NSURL *jsCodeLocation = [self sourceURL]; RCTRootView *rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation moduleName:@\"purchased_ios\" initialProperties:nil launchOptions:nil]; [self.view addSubview:rootView]; [rootView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.right.equalTo(self.view); make.top.equalTo(self.view).offset(SafeAreaTopHeight); make.bottom.equalTo(self.view).offset(-SafeAreaBottomHeight); &#125;];- (NSURL *)sourceURL &#123;#if defined(DEBUG) || defined(CDTEST) return [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@\"src/purchased.ios\" fallbackResource:nil];#else return [[NSBundle mainBundle] URLForResource:@\"main\" withExtension:@\"jsbundle\"];#endif&#125; 执行命令生成 jsbundle 文件： 12345678// 需要在 node_modules同级目录中新建：release_ios文件夹react-native bundle --entry-file index.ios.js --platform ios --dev false --bundle-output release_ios/main.jsbundle --assets-dest release_ios//** 选择生成的asset文件夹与 main.jsbundle文件，拖拽至 Xcode 的项目导航面板中* 运行打包，摆脱对本地nodejs服务器的依赖*/ 五、React Native 混合开发（Android 篇） 1、提前安装所需配置 Java SDK AndroidStudio Node 2、android 的集成 React Native 新建 android 项目或者在现有项目的 terminal 中执行命令 1234567891011npm initpackage name: (rnappdemo) 输入项目名称，全部小写：rnappdemoversion: (1.0.0) 输入版本号，可以直接回车，也可以输入自己想要的初始版本号description 输入项目描述，随便输入：first reactnativeappentry point: (index.js)输入reactnative的入口文件：index.android.jstest command: 输入：nogit repository: 输入：nokeywords: 输入：noauthor: 输入作者信息license: (ISC) 输入许可 默认ISC 在终端窗口执行:npm install --save react react-native 安装 React 和 React Native 执行完成会在项目根目录多出 node_modules 目录，说明安装成功 在项目根目录下新建一个名为.flowconfig 的文件，将 [https://raw.githubusercontent.com/facebook/react-native/master/.flowconfig](https://raw.githubusercontent.com/facebook/react-native/master/.flowconfig) 网页的内容复制到.flowconfig 文件中 在 package.json 文件中的 script 标签里添加&quot;start&quot;: “nodenode_modules/react-native/local-cli/cli.js start” 在 app 模块 build.gradle 文件中添加在 android-&gt;defaultConfig 最后添加 NDK 支持： ndk { abiFilters “armeabi-v7a”, “x86” } 在 android 里面添加如下两个配置： packagingOptions { exclude “lib/arm64-v8a/librealm-jni.so” } 在 dependencies 里面添加 reactnative 依赖：（+最好使用 0.60 以下版本） compile “com.facebook.react:react-native:+” 项目的 build.gradle 配置 在 allprojects-&gt;respositories 中添加以下内容，加载最新的 react-native 库，然后点击右上角的 Sync now 同步 maven { // All of React Native (JS, Android binaries) is installed from npm url “$rootDir/node_modules/react-native/android” } 配置 app 模块 AndroidManifest.xml 文件 添加网络权限： &lt;uses-permissionandroid:name=&quot;android.permission.INTERNET&quot; /&gt; 添加弹窗权限：（这个可以再上线后取消掉） &lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot;/&gt; 在 application 里添加 reactnative 弹窗内置页面 activity，否则摇晃手机并打开开发者菜单后，点击 Dev Setting，会直接 Crash： &lt;activityandroid:name=&quot;com.facebook.react.devsupport.DevSettingsActivity&quot;/&gt; 在项目根目录下添加 index.android.js 文件 12345678910111213141516171819202122232425262728import React from 'react'; import &#123; AppRegistry, StyleSheet, Text, View &#125; from 'react-native'; class HelloWorld extends React.Component &#123; render() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.hello&#125;&gt;第一个混合RNAPP&lt;/Text&gt; &lt;/View&gt; ) &#125; &#125; var styles = StyleSheet.create(&#123; container: &#123; flex: 1, justifyContent: 'center', &#125;, hello: &#123; fontSize: 20, textAlign: 'center', margin: 10, &#125;, &#125;); AppRegistry.registerComponent('HelloWorld', () =&gt; HelloWorld); 新建 MyReactActivity 12345678910111213141516171819202122232425public class MainApplication extends Application implements ReactApplication &#123; private final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) &#123; @Override public boolean getUseDeveloperSupport() &#123; return BuildConfig.DEBUG; &#125; @Override protected List&lt;ReactPackage&gt; getPackages() &#123; return Arrays.&lt;ReactPackage&gt;asList( new MainReactPackage() ); &#125; &#125;; @Override public ReactNativeHost getReactNativeHost() &#123; return mReactNativeHost; &#125; @Override public void onCreate() &#123; super.onCreate(); SoLoader.init(this,false); &#125;&#125; 3、打包运行 手动生成 bundle 文件 在 app/src/main 下新建 assets 目录，在终端窗口 Terminal 中执行： react-native bundle --platform android --dev false–entry-file index.js --bundle-output app/src/main/assets/index.android.bundle–assets-dest app/src/main/res/ 说明： –platform：平台 –dev：开发模式 –entry-file：条目文件 –bundle-output：bundle 文件生成的目录 –assets-dest：资源文件生成的目录 执行完成后，会在 assets 目录下生成两个文件：index.android.bundle 运行 app 即可看到效果 热更新 一、CodePush 热更新 CodePush server：[http://www.code-push.com/](http://www.code-push.com/) 参考：[https://www.jianshu.com/p/6a5e00d22723](https://www.jianshu.com/p/6a5e00d22723) 二、pushy 进行热更新 参考：[https://blog.csdn.net/xiangzhihong8/article/details/73201421](https://blog.csdn.net/xiangzhihong8/article/details/73201421) 参考文档：[https://github.com/reactnativecn/react-native-pushy/blob/master/docs/guide.md](https://github.com/reactnativecn/react-native-pushy/blob/master/docs/guide.md) 都是将 jsbundle 文件提交至对应的服务器上，都支持强制更新，动态更新，更新失败回滚，在各自项目中编写更新代码（不建议用弹窗提醒用户更新的方式，这样 iOS 审核会被拒）","categories":[{"name":"移动端","slug":"移动端","permalink":"https://www.cqzhong.cn/categories/移动端/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.cqzhong.cn/tags/iOS/"},{"name":"Android","slug":"Android","permalink":"https://www.cqzhong.cn/tags/Android/"},{"name":"react native","slug":"react-native","permalink":"https://www.cqzhong.cn/tags/react-native/"}]},{"title":"MAC下安装Nginx","slug":"MAC下安装Nginx","date":"2019-08-04T04:40:17.000Z","updated":"2020-11-03T10:21:35.434Z","comments":true,"path":"2019/08/04/MAC下安装Nginx/","link":"","permalink":"https://www.cqzhong.cn/2019/08/04/MAC下安装Nginx/","excerpt":"使用工具工具 Homebrew 安装完成后打开终端","text":"使用工具工具 Homebrew 安装完成后打开终端 查看 nginx 信息 1brew search nginx 如果显示对号，证明已经安装过了。否则执行安装命令 1brew install nginx 安装完成 主页的文件在/usr/local/var/www 文件夹下 对应的配置文件地址在/usr/local/etc/nginx/nginx.conf 运行 nginx 1nginx 重新启动 nginx 1nginx -s reload 浏览器查看 http://localhost:8080","categories":[{"name":"其它","slug":"其它","permalink":"https://www.cqzhong.cn/categories/其它/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.cqzhong.cn/tags/Nginx/"}]},{"title":"TCP状态","slug":"TCP状态","date":"2019-07-30T04:46:21.000Z","updated":"2020-11-03T10:21:35.322Z","comments":true,"path":"2019/07/30/TCP状态/","link":"","permalink":"https://www.cqzhong.cn/2019/07/30/TCP状态/","excerpt":"建立连接协议（三次握手） 客户端发送一个带 SYN 标志的 TCP 报文到服务器。这是三次握手过程中的报文 1。","text":"建立连接协议（三次握手） 客户端发送一个带 SYN 标志的 TCP 报文到服务器。这是三次握手过程中的报文 1。 服务器端回应客户端的，这是三次握手中的第 2 个报文，这个报文同时带 ACK 标志和 SYN 标志。因此它表示对刚才客户端 SYN 报文的回应；同时又标志 SYN 给客户端，询问客户端是否准备好进行数据通讯。 客户必须再次回应服务段一个 ACK 报文，这是报文段 3。 连接终止协议（四次释放） 由于 TCP 连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个 FIN 来终止这个方向的连接。收到一个 FIN 只意味着这一方向上没有数据流动，一个 TCP 连接在收到一个 FIN 后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。 TCP 客户端发送一个 FIN，用来关闭客户到服务器的数据传送（报文段 4） 服务器收到这个 FIN，它发回一个 ACK，确认序号为收到的序号加 1（报文段 5）。和 SYN 一样，一个 FIN 将占用一个序号。 服务器关闭客户端的连接，发送一个 FIN 给客户端（报文段 6）。 客户段发回 ACK 报文确认，并将确认序号设置为收到序号加 1（报文段 7）。 TIME_WAIT：通信双方建立 TCP 连接后，主动关闭连接的一方就会进入 TIME_WAIT 状态。客户端主动关闭连接时，会发送最后一个 ack 后，然后会进入 TIME_WAIT 状态，再停留 2 个 MSL 时间(后有 MSL 的解释)，进入 CLOSED 状态。 下图是以客户端主动关闭连接为例，说明这一过程的。 CLOSE_WAIT: 这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方 close 一个 SOCKET 后发送 FIN 报文给自己，你系统毫无疑问地会回应一个 ACK 报文给对方，此时则进入到 CLOSE_WAIT 状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以 close 这个 SOCKET，发送 FIN 报文给对方，也即关闭连接。所以你在 CLOSE_WAIT 状态下，需要完成的事情是等待你去关闭连接。 MSL：就是 maximum segment lifetime(最大分节生命期），这是一个 IP 数据包能在互联网上生存的最长时间，超过这个时间 IP 数据包将在网络中消失 。 TIME_WAIT状态维持时间：TIME_WAIT 状态维持时间是两个 MSL 时间长度，也就是在 1-4 分钟。Windows 操作系统就是 4 分钟。 A 与 B 建立了正常连接后，从未相互发过数据，这个时候 B 突然机器重启，问 A 此时处于 TCP 什么状态？如何消除服务器程序中的这个状态？ 答：A 处于 ESTABLISHED 状态，B 突然重启，A 感知不到 B 的状态，可以通过心跳来探测对方状态。","categories":[{"name":"其它","slug":"其它","permalink":"https://www.cqzhong.cn/categories/其它/"}],"tags":[{"name":"tcp","slug":"tcp","permalink":"https://www.cqzhong.cn/tags/tcp/"}]},{"title":"iOS高版本备份恢复到低版本系统手机上","slug":"iOS高版本备份恢复到低版本系统手机上","date":"2019-07-30T03:46:52.000Z","updated":"2020-11-03T10:21:35.916Z","comments":true,"path":"2019/07/30/iOS高版本备份恢复到低版本系统手机上/","link":"","permalink":"https://www.cqzhong.cn/2019/07/30/iOS高版本备份恢复到低版本系统手机上/","excerpt":"找到路径 ‎⁨Mac Launch⁩ ▸ ⁨ 用户 ⁩ ▸ 用户名 ▸ ⁨ 资源库 ⁩ ▸ ⁨Application Support⁩ ▸ ⁨MobileSync⁩ ▸ ⁨Backup⁩ 下的备份","text":"找到路径 ‎⁨Mac Launch⁩ ▸ ⁨ 用户 ⁩ ▸ 用户名 ▸ ⁨ 资源库 ⁩ ▸ ⁨Application Support⁩ ▸ ⁨MobileSync⁩ ▸ ⁨Backup⁩ 下的备份 找到备份内的 Info.plist 文件 修改 Product Version 字段下的版本信息。&gt;=将要回复备份的手机版本号 保存 重启 iTunes 检查恢复备份","categories":[{"name":"移动端","slug":"移动端","permalink":"https://www.cqzhong.cn/categories/移动端/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.cqzhong.cn/tags/iOS/"}]},{"title":"自顶向下的编程风格","slug":"自顶向下的编程风格","date":"2019-07-29T11:00:00.000Z","updated":"2020-11-03T10:21:34.309Z","comments":true,"path":"2019/07/29/自顶向下的编程风格/","link":"","permalink":"https://www.cqzhong.cn/2019/07/29/自顶向下的编程风格/","excerpt":"本文转载自 wikioi_bai 自顶向下的编程风格： 所谓自顶向下的编程风格，我感觉和我们平时所见过的分治与递归的思想较为类似， 为什么这样说呢，是因为这种编程风格也是将一个大问题转换为许多小问题来进行解决 比如，就在这道画格子的题目中，我们发现，对于一个图来说，我们最朴素的想法肯定是 先画所有的竖线，然后再画所有的横线，或者说是先画所有的横线，再画所有的竖线。 画横线的方法： 1.写出一专门用来画横线的函数，该函数包括以下参数（数组名，开始的行号，开始的列标，结束的列标） 2.画竖线的函数与画横线的函数思路类似，只是对于函数的参数要发生一定的变化 （数组名，开始的列号，开始的行号，结束的行号） 该题目一开始是将这些字符全部存入到一个叫做 cache 的缓冲区中，因为我们知道如果直接在 控制台上写入这些字符，从第一行写到第五行的时候，如果再对第一行的字符进行操作那将会 是一件很困难的事情，所以我们先将他写入缓冲区中，然后对于缓冲区中的字符进行相对应的 操作，将最终希望得到的结果显示出来就可以了。","text":"本文转载自 wikioi_bai 自顶向下的编程风格： 所谓自顶向下的编程风格，我感觉和我们平时所见过的分治与递归的思想较为类似， 为什么这样说呢，是因为这种编程风格也是将一个大问题转换为许多小问题来进行解决 比如，就在这道画格子的题目中，我们发现，对于一个图来说，我们最朴素的想法肯定是 先画所有的竖线，然后再画所有的横线，或者说是先画所有的横线，再画所有的竖线。 画横线的方法： 1.写出一专门用来画横线的函数，该函数包括以下参数（数组名，开始的行号，开始的列标，结束的列标） 2.画竖线的函数与画横线的函数思路类似，只是对于函数的参数要发生一定的变化 （数组名，开始的列号，开始的行号，结束的行号） 该题目一开始是将这些字符全部存入到一个叫做 cache 的缓冲区中，因为我们知道如果直接在 控制台上写入这些字符，从第一行写到第五行的时候，如果再对第一行的字符进行操作那将会 是一件很困难的事情，所以我们先将他写入缓冲区中，然后对于缓冲区中的字符进行相对应的 操作，将最终希望得到的结果显示出来就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/*$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ $ $ $ $ $ $ $ $$ $ $ $ $ $ $ $ $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ $ $ $ $ $ $ $ $$ $ $ $ $ $ $ $ $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ $ $ $ $ $ $ $ $$ $ $ $ $ $ $ $ $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ 自顶向下的编程风格： 所谓自顶向下的编程风格，我感觉和我们平时所见过的分治与递归的思想较为类似， 为什么这样说呢，是因为这种编程风格也是将一个大问题转换为许多小问题来进行解决 比如，就在这道画格子的题目中，我们发现，对于一个图来说，我们最朴素的想法肯定是 先画所有的竖线，然后再画所有的横线，或者说是先画所有的横线，再画所有的竖线。 画横线的方法： 1.写出一专门用来画横线的函数，该函数包括以下参数（数组名，开始的行号，开始的列标，结束的列标） 2.画竖线的函数与画横线的函数思路类似，只是对于函数的参数要发生一定的变化 （数组名，开始的列号，开始的行号，结束的行号） 该题目一开始是将这些字符全部存入到一个叫做 cache的缓冲区中，因为我们知道如果直接在 控制台上写入这些字符，从第一行写到第五行的时候，如果再对第一行的字符进行操作那将会 是一件很困难的事情，所以我们先将他写入缓冲区中，然后对于缓冲区中的字符进行相对应的 操作，将最终希望得到的结果显示出来就可以了。*/# include&lt;cstdio&gt;# include&lt;iostream&gt;# include&lt;cstring&gt;# include&lt;cmath&gt;# include&lt;algorithm&gt;using namespace std;void print( char a[20][50])&#123; for ( int i = 0;i &lt; 20;i++ ) &#123; for ( int j = 0;j &lt; 50;j++ ) &#123; if ( a[i][j] == 0 ) printf(\" \"); else printf(\"%c\",a[i][j]); &#125; printf(\"\\n\"); &#125;&#125;void line_h( char a[20][50],int row ,int col1,int col2 )&#123; for ( int i = col1;i &lt;= col2;i++ ) a[row][i] = '$';&#125;void line_v( char a[20][50],int col,int row1,int row2 )&#123; for ( int i = row1;i &lt;= row2;i++ ) a[i][col] = '$';&#125;int main(void)&#123; char cache[20][50]; memset(cache,0,sizeof(cache)); for ( int i = 0;i &lt; 4;i++ )line_h( cache,i*3,0,32 ); for ( int i = 0;i &lt; 9;i++ )line_v( cache,i*4,0,9 ); print(cache); return 0;&#125;","categories":[{"name":"其它","slug":"其它","permalink":"https://www.cqzhong.cn/categories/其它/"}],"tags":[{"name":"规范","slug":"规范","permalink":"https://www.cqzhong.cn/tags/规范/"}]},{"title":"OC内联函数 inline","slug":"OC内联函数 inline","date":"2019-07-12T04:46:52.000Z","updated":"2020-11-03T10:21:35.854Z","comments":true,"path":"2019/07/12/OC内联函数 inline/","link":"","permalink":"https://www.cqzhong.cn/2019/07/12/OC内联函数 inline/","excerpt":"在 iOS 开发过程中经常会使用 static inline 关键字组合","text":"在 iOS 开发过程中经常会使用 static inline 关键字组合 Static 关键字理解 Static 修饰局部变量 当 static 关键字修饰局部变量时，只会初始化一次且在程序中只有一份内存； 关键字 static 不可以改变局部变量的作用域，但可延长局部变量的生命周期（直到程序结束才销毁）。 Static 修饰全局变量 当 static 关键字修饰全局变量时，作用域仅限于当前文件，外部类是不可以访问到该全局变量的（即使在外部使用 extern 关键字也无法访问）。 inline 内联函数 1234567891011121314static inline CGFloatremoveFloatMin(CGFloat floatValue) &#123; return floatValue == CGFLOAT_MIN ? 0 : floatValue;&#125;static inline CGFloatflatSpecificScale(CGFloat floatValue, CGFloat scale) &#123; floatValue = removeFloatMin(floatValue); scale = scale ?: ScreenScale; CGFloat flattedValue = ceil(floatValue * scale) / scale; return flattedValue;&#125; 虽然 static inline 修饰的是函数.但它在这里就是宏的作用,你可以将 removeFloatMin 当作一个宏. 当然 inline 函数与宏有区别,inline 可以: 解决函数调用效率的问题； 函数之间调用，是内存地址之间的调用，当函数调用完毕之后还会返回原来函数执行的地址。函数调用有时间开销，内联函数就是为了解决这一问题。 不用 inline 修饰的函数, 汇编时会出现 call 指令.调用 call 指令就是就需要： 1.将下一条指令的所在地址入栈 2.并将子程序的起始地址送入 PC（于是 CPU 的下一条指令就会转去执行子程序）. inline 优点 inline 函数避免了普通函数的,在汇编时必须调用 call 的缺点:取消了函数的参数压栈，减少了调用的开销,提高效率.所以执行速度确比一般函数的执行速度要快. 集成了宏的优点,使用时直接用代码替换(像宏一样); 1.避免了宏的缺点:需要预编译.因为 inline 内联函数也是函数,不需要预编译. 2.编译器在调用一个内联函数时，会首先检查它的参数的类型，保证调用正确。然后进行一系列的相关检查，就像对待任何一个真正的函数一样。这样就消除了它的隐患和局限性。 3.可以使用所在类的保护成员及私有成员。 inline 使用总结 内联函数只是我们向编译器提供的申请,编译器不一定采取 inline 形式调用函数. 内联函数不能承载大量的代码.如果内联函数的函数体过大,编译器会自动放弃内联. 内联函数内不允许使用循环语句或开关语句. 内联函数的定义须在调用之前.","categories":[{"name":"移动端","slug":"移动端","permalink":"https://www.cqzhong.cn/categories/移动端/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.cqzhong.cn/tags/iOS/"},{"name":"内联函数","slug":"内联函数","permalink":"https://www.cqzhong.cn/tags/内联函数/"}]},{"title":"Vue.js的主要特点","slug":"Vue.js的主要特点","date":"2019-07-07T12:00:00.000Z","updated":"2020-11-03T10:21:34.419Z","comments":true,"path":"2019/07/07/Vue.js的主要特点/","link":"","permalink":"https://www.cqzhong.cn/2019/07/07/Vue.js的主要特点/","excerpt":"1.轻量级的框架 Vue.js 能够自动追踪依赖的模板表达式和计算属性，提供 MVVM 数据绑定和一个可组合的组件系统，具有简单、灵活的 API，使读者更加容易理解，能够更快上手。","text":"1.轻量级的框架 Vue.js 能够自动追踪依赖的模板表达式和计算属性，提供 MVVM 数据绑定和一个可组合的组件系统，具有简单、灵活的 API，使读者更加容易理解，能够更快上手。 2.双向数据绑定声明式渲染是数据双向绑定的主要体现，同样也是 Vue.js 的核心，它允许采用简洁的模板语法将数据声明式渲染整合进 DOM。 3.指令 Vue.js 与页面进行交互，主要就是通过内置指令来完成的，指令的作用是当其表达式的值改变时相应地将某些行为应用到 DOM 上。 4.组件化组件（Component）是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。在 Vue 中，父子组件通过 props 传递通信，从父向子单向传递。子组件与父组件通信，通过触发事件通知父组件改变数据。这样就形成了一个基本的父子通信模式。在开发中组件和 HTML、JavaScript 等有非常紧密的关系时，可以根据实际的需要自定义组件，使开发变得更加便利，可大量减少代码编写量。组件还支持热重载（hotreload）。当我们做了修改时，不会刷新页面，只是对组件本身进行立刻重载，不会影响整个应用当前的状态。CSS 也支持热重载。 5.客户端路由 Vue-router 是 Vue.js 官方的路由插件，与 Vue.js 深度集成，用于构建单页面应用。Vue 单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来，传统的页面是通过超链接实现页面的切换和跳转的。 6.状态管理状态管理实际就是一个单向的数据流，State 驱动 View 的渲染，而用户对 View 进行操作产生 Action，使 State 产生变化，从而使 View 重新渲染，形成一个单独的组件。最新发行的 Vue 2.X 比 Vue 1.X 更轻、更快，不仅在 Vue 1.X 基础上有很大的提升，相比于其他框架还有很大的性能优势。Vue 学起来比较简单，更容易上手。 Vue.js 的优势 Vue 与其他框架相比有什么优势呢？上面我们已经提到了 jQuery，还有其他的前端框架，如 React、Angular 等。相比较而言，Vue 最为轻量化，而且已经形成了完整的一套生态系统，可以快速迭代更新。作为前端开发人员的首选入门框架，Vue 有很多优势。 （1）Vue.js 可以进行组件化开发，使代码编写量大大减少，读者更加易于理解。 （2）Vue.js 最突出的优势在于可以对数据进行双向绑定（在之后的编写中我们会明显地感觉到这个特点的便捷）。 （3）使用 Vue.js 编写出来的界面效果本身就是响应式的，这使网页在各种设备上都能显示出非常好看的效果。 （4）相比传统的页面通过超链接实现页面的切换和跳转，Vue 使用路由不会刷新页面。说明 Vue 必须在 ES5 版本以上的环境下使用，一些不支持 ES5 的旧浏览器中无法运行 Vue。","categories":[{"name":"前端","slug":"前端","permalink":"https://www.cqzhong.cn/categories/前端/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.cqzhong.cn/tags/vue/"}]},{"title":"HTTP， HTTPS","slug":"HTTP， HTTPS","date":"2019-04-26T03:40:00.000Z","updated":"2020-11-03T10:21:35.681Z","comments":true,"path":"2019/04/26/HTTP， HTTPS/","link":"","permalink":"https://www.cqzhong.cn/2019/04/26/HTTP， HTTPS/","excerpt":"一、HTTP 主要有这些不足，例举如下 通信使用明文（不加密），内容可能会被窃听 不验证通信方的身份，因此有可能遭遇伪装 无法验证报文的完整性，所以有可能已遭篡改 因此不论在任何时候，都应该将服务置于 HTTPS 上，因为它可以避免中间人攻击的问题，还采用了共享密钥加密和公开密钥加密两者并用的混合加密机制，在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密的方式。","text":"一、HTTP 主要有这些不足，例举如下 通信使用明文（不加密），内容可能会被窃听 不验证通信方的身份，因此有可能遭遇伪装 无法验证报文的完整性，所以有可能已遭篡改 因此不论在任何时候，都应该将服务置于 HTTPS 上，因为它可以避免中间人攻击的问题，还采用了共享密钥加密和公开密钥加密两者并用的混合加密机制，在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密的方式。 二、HTTPS 是身披 SSL 外壳的 HTTP HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用 SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替而已。在采用 SSL 后，HTTP 就拥有了 HTTPS 的加密，证书，和完整性保护这些功能。 HTTPS 交互原理 简答说，HTTPS 就是 HTTP 协议加了一层 SSL 协议的加密处理，SSL 证书就是遵守 SSL 协议，由受信任的数字证书颁发机构 CA（如 GlobalSign，wosign），在验证服务器身份后颁发，这是需要花钱滴，签发后的证书作为公钥一般放在服务器的根目录下，便于客户端请求返回给客户端，私钥在服务器的内部中心保存，用于解密公钥。 HTTPS 客户端与服务器交互过程： 1、客户端发送请求，服务器返回公钥给客户端。 2、客户端生成对称加密秘钥，用公钥对其进行加密后，返回给服务器。 3、服务器收到后，利用私钥解开得到对称加密秘钥，保存。 4、之后的交互都使用对称加密后的数据进行交互。 三、HTTP/1 对比 HTTP/2 参考文章 解读 HTTP/2 与 HTTP/3 的新特性 HTTP/2 相比于 HTTP/1.1，可以说是大幅度提高了网页的性能，只需要升级到该协议就可以减少很多之前需要做的性能优化工作，当然兼容问题以及如何优雅降级应该是国内还不普遍使用的原因之一。 一、HTTP/1.1 的缺陷 1.高延迟–带来页面加载速度的降低 2.无状态特性–带来的巨大 HTTP 头部 3.明文传输–带来的不安全性 4.不支持服务器推送消息 两个主要的缺点：安全不足和性能不高 二、HTTP/2 新特性 1.二进制传输 2.Header 压缩 3.多路复用 4.Server Push 5.提高安全性","categories":[{"name":"移动端","slug":"移动端","permalink":"https://www.cqzhong.cn/categories/移动端/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://www.cqzhong.cn/tags/面试/"}]},{"title":"微信小程序单页面自定义导航栏","slug":"微信小程序单页面自定义导航栏","date":"2019-04-23T03:00:00.000Z","updated":"2020-11-03T10:21:35.077Z","comments":true,"path":"2019/04/23/微信小程序单页面自定义导航栏/","link":"","permalink":"https://www.cqzhong.cn/2019/04/23/微信小程序单页面自定义导航栏/","excerpt":"如果小程序内只有某个页面需要用到自定义的导航栏，只需要 1、在 index.json 中配置 1234&#123; &quot;navigationStyle&quot;: &quot;custom&quot;, &quot;usingComponents&quot;: &#123;&#125;&#125;","text":"如果小程序内只有某个页面需要用到自定义的导航栏，只需要 1、在 index.json 中配置 1234&#123; &quot;navigationStyle&quot;: &quot;custom&quot;, &quot;usingComponents&quot;: &#123;&#125;&#125; 2、在 index.js 文件中获取当前手机的导航栏高度。 12345678910111213141516//取得导航栏高度phoneNavHeight: function () &#123; let that = this; wx.getSystemInfo(&#123; success: function(res) &#123; let height = res.statusBarHeight + (res.platform === \"ios\" ? 44 : 48); let rule = 750/res.windowWidth; height = height * rule; that.setData(&#123; navHeight: height &#125;) &#125; &#125;)&#125; 3、在 index.wxml 文件中定义 view 123&lt;view class=\"rank_nav\" style=\"height:&#123;&#123;navHeight&#125;&#125;rpx;\"&gt; &lt;view class=\"nav_title\"&gt;标题&lt;/view&gt;&lt;/view&gt;","categories":[{"name":"前端","slug":"前端","permalink":"https://www.cqzhong.cn/categories/前端/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://www.cqzhong.cn/tags/微信小程序/"}]},{"title":"相册选中iCloud上的视频和照片","slug":"相册选中iCloud上的视频和照片","date":"2019-03-29T03:46:52.000Z","updated":"2020-11-03T10:21:35.857Z","comments":true,"path":"2019/03/29/相册选中iCloud上的视频和照片/","link":"","permalink":"https://www.cqzhong.cn/2019/03/29/相册选中iCloud上的视频和照片/","excerpt":"1、判断图片来源的枚举","text":"1、判断图片来源的枚举 1234567891011typedef NS_OPTIONS(NSUInteger, PHAssetSourceType) &#123; PHAssetSourceTypeNone = 0, PHAssetSourceTypeUserLibrary = (1UL &lt;&lt; 0), PHAssetSourceTypeCloudShared = (1UL &lt;&lt; 1), PHAssetSourceTypeiTunesSynced = (1UL &lt;&lt; 2),&#125; PHOTOS_AVAILABLE_IOS_TVOS(9_0, 10_0); 2、判断是否是 iCloud 视频 12345678910111213141516171819202122PHVideoRequestOptions* options = [[PHVideoRequestOptions alloc] init];//是否允许蜂窝数据下缓存视频options.networkAccessAllowed = true;options.version = PHVideoRequestOptionsVersionCurrent;options.deliveryMode = PHVideoRequestOptionsDeliveryModeAutomatic;options.progressHandler = ^(double progress, NSError *error, BOOL *stop, NSDictionary *info) &#123; //视频正在从iCloud缓存到本地相册，进度回调 &#125;;PHAsset *phAsset = (PHAsset *)asset.phAsset;[[[QMUIAssetsManager sharedInstance] phCachingImageManager] requestAVAssetForVideo:phAsset options:options resultHandler:^(AVAsset * _Nullable asset, AVAudioMix * _Nullable audioMix, NSDictionary * _Nullable info) &#123; //视频缓存完成之后的回调，如果视频是从iCloud上下载下来的，点击选中视频也会进入这个回调&#125;];","categories":[{"name":"移动端","slug":"移动端","permalink":"https://www.cqzhong.cn/categories/移动端/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.cqzhong.cn/tags/iOS/"}]},{"title":"使用BeeHive独立出一个推送模块","slug":"使用BeeHive独立出一个推送模块","date":"2019-03-24T05:06:53.000Z","updated":"2020-11-03T10:21:35.776Z","comments":true,"path":"2019/03/24/使用BeeHive独立出一个推送模块/","link":"","permalink":"https://www.cqzhong.cn/2019/03/24/使用BeeHive独立出一个推送模块/","excerpt":"废话不多说，直接上代码。这里以阿里推送 pod ‘AlicloudPush’, ‘~&gt; 1.9.8’ 为例 CDAPNSModule.h","text":"废话不多说，直接上代码。这里以阿里推送 pod ‘AlicloudPush’, ‘~&gt; 1.9.8’ 为例 CDAPNSModule.h 12345678910111213141516/** * 基类 Moudle * 每创建一个模块时, 需要继承该类, 并在Moudle 头文件中, 引入该模块的所有暴露的头文件 * 可以使用 BH_EXPORT_MODULE(NO) 是否异步加载 Moudle (该方法是在 +load 方法内调用, 需要写到 @implementation 和 @end 之间) * 也可以使用 @BeeHiveMod(BaseModule) 来注册 Moudlle (该方法是在应用启动前, 加载符号文件时候调用) */#define MOUDLE_REGISTER(moudle_imp) BeeHiveMod(moudle_imp)#define MOUDLE_EXPORT(async) BH_EXPORT_MODULE(async)@interface CDAPNSModule : NSObject &lt;BHModuleProtocol&gt;@end CDAPNSModule.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267#import \"CDAPNSModule.h\"#import &lt;CloudPushSDK/CloudPushSDK.h&gt;#ifdef NSFoundationVersionNumber_iOS_9_x_Max#import &lt;UserNotifications/UserNotifications.h&gt;#endifstatic NSString *const CCPDidChannelConnectedSuccess = @\"CCPDidChannelConnectedSuccess\";static NSString *const CCPDidReceiveMessageNotification = @\"CCPDidReceiveMessageNotification\";//@BeeHiveMod(CDAPNSModule)@interface CDAPNSModule () &lt;UNUserNotificationCenterDelegate&gt;@end@implementation CDAPNSModule+ (void)load &#123; // 使用动态注册的方法。 [BeeHive registerDynamicModule:[self class]];&#125;//BH_EXPORT_MODULE(NO)//- (NSInteger)modulePriority &#123;// return CGFLOAT_MAX;//&#125;//- (void)basicModuleLevel &#123;////&#125;- (void)modInit:(BHContext *)context &#123;&#125;- (void)modSetUp:(BHContext *)context &#123; // APNs注册，获取deviceToken并上报 [self registerAPNS:context.application]; // 初始化SDK [self initCloudPush]; // 监听推送通道打开动作 [self listenerOnChannelOpened]; // 监听推送消息到达 [self registerMessageReceive]; [CloudPushSDK sendNotificationAck:context.launchOptions];&#125;- (void)modDidRegisterForRemoteNotifications:(BHContext *)context &#123; // 注册APNS成功, 注册deviceToken// NSString *deviceId = [[NSString alloc] initWithData:context.notificationsItem.deviceToken encoding:NSUTF8StringEncoding];// NSString *deviceTokenString = [[[[context.notificationsItem.deviceToken description] stringByReplacingOccurrencesOfString: @\"&lt;\" withString: @\"\"]stringByReplacingOccurrencesOfString: @\"&gt;\" withString: @\"\"]stringByReplacingOccurrencesOfString: @\" \" withString: @\"\"];//// CDDLog(@\"token---:%@\",deviceTokenString); [CloudPushSDK registerDevice:context.notificationsItem.deviceToken withCallback:^(CloudPushCallbackResult *res) &#123; if (res.success) &#123; CDDLog(@\"Register deviceToken success, deviceToken: %@\", [CloudPushSDK getApnsDeviceToken]); CDDLog(@\"Register deviceToken success, deviceToken: %@\", [CloudPushSDK getApnsDeviceToken]); CDDLog(@\"Register getDeviceId success, getDeviceId: %@\", [CloudPushSDK getDeviceId]); &#125; else &#123; CDDLog(@\"Register deviceToken failed, error: %@\", res.error); &#125; &#125;];&#125;- (void)modDidFailToRegisterForRemoteNotifications:(BHContext *)context &#123; // 注册APNS失败. optional CDDLog(@\"did Fail To Register For Remote Notifications With Error: %@\", context.notificationsItem.notificationsError);&#125;- (void)modDidEnterBackground:(BHContext *)context &#123; [self clearBageNum:context.application];&#125;- (void)modWillEnterForeground:(BHContext *)context &#123; [self clearBageNum:context.application];&#125;//MARK: 打开通知//iOS (3_0, 10_0) App 处于前台,如果收到 远程通知 则调用该处理方法- (void)modDidReceiveRemoteNotification:(BHContext *)context &#123; //打开激活app // NSDictionary *userInfoDict1 = [context.launchOptions objectForKey:UIApplicationLaunchOptionsRemoteNotificationKey]; UIApplicationState state = [UIApplication sharedApplication].applicationState; if (state == UIApplicationStateActive) &#123; return; &#125; //在前台,在后台 NSDictionary *userInfoDict = context.notificationsItem.userInfo; [self parsingTheSkipInfo:userInfoDict]; context.application.applicationIconBadgeNumber = 0; [CloudPushSDK sendNotificationAck:context.notificationsItem.userInfo];&#125;//MARK: -跳转规则- (void)parsingTheSkipInfo:(NSDictionary *)userInfoDict &#123;&#125;//- (void)modDidBecomeActive:(BHContext *)context &#123;//// BOOL isOpenNotify = [self isAllowedNotification];// if (isOpenNotify) &#123;//推送被关闭// [[UIApplication sharedApplication] unregisterForRemoteNotifications];// &#125; else &#123; //已经开启推送// [[UIApplication sharedApplication] registerForRemoteNotifications];// &#125;//&#125;//-(void)modWillResignActive:(BHContext *)context &#123;////&#125;//MARK: APNs Register/**向APNs注册，获取deviceToken用于推送@param application application description*/- (void)registerAPNS:(UIApplication *)application &#123; if (@available(iOS 10.0, *)) &#123; // 请求推送权限 [[UNUserNotificationCenter currentNotificationCenter] requestAuthorizationWithOptions:UNAuthorizationOptionAlert | UNAuthorizationOptionBadge | UNAuthorizationOptionSound completionHandler:^(BOOL granted, NSError * _Nullable error) &#123; if (granted) &#123; // 向APNs注册，获取deviceToken dispatch_async(dispatch_get_main_queue(), ^&#123; [application registerForRemoteNotifications]; &#125;); &#125; else &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [application registerForRemoteNotifications]; &#125;); &#125; &#125;]; [self getNotificationSettingStatus]; &#125; else &#123;#pragma clang diagnostic push#pragma clang diagnostic ignored\"-Wdeprecated-declarations\" [application registerUserNotificationSettings: [UIUserNotificationSettings settingsForTypes: (UIUserNotificationTypeSound | UIUserNotificationTypeAlert | UIUserNotificationTypeBadge) categories:nil]]; dispatch_async(dispatch_get_main_queue(), ^&#123; [application registerForRemoteNotifications]; &#125;);#pragma clang diagnostic pop &#125;&#125;/*** 主动获取设备通知是否授权(iOS 10+)*/- (void)getNotificationSettingStatus NS_AVAILABLE_IOS(10_0) &#123; [[UNUserNotificationCenter currentNotificationCenter] getNotificationSettingsWithCompletionHandler:^(UNNotificationSettings * _Nonnull settings) &#123; if (settings.authorizationStatus == UNAuthorizationStatusAuthorized) &#123; CDDLog(@\"User authed.\"); &#125; else &#123; CDDLog(@\"User denied.\"); &#125; &#125;];&#125; ///MARK: App处于前台时收到通知(iOS 10+)- (void)modWillPresentNotification:(BHContext *)context NS_AVAILABLE_IOS(10_0) &#123; if ([context.notificationsItem.notification.request.trigger isKindOfClass:[UNPushNotificationTrigger class]]) &#123; // [self handleiOS10Notification:context.notificationsItem.notification]; &#125;context.notificationsItem.notificationPresentationOptionsHandler(UNNotificationPresentationOptionSound | UNNotificationPresentationOptionAlert | UNNotificationPresentationOptionBadge);&#125;//MARK: 触发通知动作时回调，比如点击、删除通知和点击自定义action(iOS 10+)- (void)modDidReceiveNotificationResponse:(BHContext *)context NS_AVAILABLE_IOS(10_0) &#123; if ([context.notificationsItem.notificationResponse.notification.request.trigger isKindOfClass:[UNPushNotificationTrigger class]]) &#123; [self handleiOS10Notification:context.notificationsItem.notificationResponse.notification]; &#125; context.notificationsItem.notificationCompletionHandler();&#125;//MARK: 处理iOS 10通知(iOS 10+)- (void)handleiOS10Notification:(UNNotification *)notification NS_AVAILABLE_IOS(10_0) &#123; UNNotificationRequest *request = notification.request; UNNotificationContent *content = request.content; NSDictionary *userInfo = content.userInfo; [self parsingTheSkipInfo:userInfo]; [CloudPushSDK sendNotificationAck:userInfo];&#125;#pragma mark SDK Init- (void)initCloudPush &#123;#if defined(DEBUG) || defined(CDTEST) [CloudPushSDK turnOnDebug];#endif // 请从控制台下载AliyunEmasServices-Info.plist配置文件，并正确拖入工程 [CloudPushSDK autoInit:^(CloudPushCallbackResult *res) &#123; if (res.success) &#123; CDDLog(@\"Push SDK init success, deviceId: %@.\", [CloudPushSDK getDeviceId]); &#125; else &#123; CDDLog(@\"Push SDK init failed, error: %@\", res.error); &#125; &#125;];&#125;#pragma mark Channel Opened/** 消息模块监听 */- (void)listenerOnChannelOpened &#123; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(onChannelOpened:) name:CCPDidChannelConnectedSuccess object:nil];&#125;/**推送通道打开回调@param notification 消息内容*/- (void)onChannelOpened:(NSNotification *)notification &#123; CDDLog(@\"消息通道建立成功\");&#125;//MARK: 推送消息- (void)registerMessageReceive &#123; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(onMessageReceived:) name:CCPDidReceiveMessageNotification object:nil];&#125;/**处理到来推送消息@param notification 消息内容*/- (void)onMessageReceived:(NSNotification *)notification &#123;// CCPSysMessage *message = [notification object];// CDDLog(@\"接收到的消息内容：%@\",[[NSString alloc] initWithData:message.title encoding:NSUTF8StringEncoding]);&#125;- (void)clearBageNum:(UIApplication *)application &#123; [CloudPushSDK syncBadgeNum:0 withCallback:^(CloudPushCallbackResult *res) &#123; &#125;]; dispatch_async(dispatch_get_main_queue(), ^&#123; [application setApplicationIconBadgeNumber:0]; [application cancelAllLocalNotifications]; &#125;);&#125;//MARK: 判断不同系统下用户是否在设置界面关闭了推送- (BOOL)isAllowedNotification &#123; // true关闭。false关闭 UIUserNotificationSettings *setting = [[UIApplication sharedApplication] currentUserNotificationSettings]; return (setting.types== UIUserNotificationTypeNone) ? YES : NO;&#125;@end","categories":[{"name":"移动端","slug":"移动端","permalink":"https://www.cqzhong.cn/categories/移动端/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.cqzhong.cn/tags/iOS/"},{"name":"BeeHive","slug":"BeeHive","permalink":"https://www.cqzhong.cn/tags/BeeHive/"},{"name":"推送","slug":"推送","permalink":"https://www.cqzhong.cn/tags/推送/"}]},{"title":"BeeHive的使用","slug":"BeeHive的使用","date":"2019-03-23T06:06:53.000Z","updated":"2020-11-03T10:21:35.770Z","comments":true,"path":"2019/03/23/BeeHive的使用/","link":"","permalink":"https://www.cqzhong.cn/2019/03/23/BeeHive的使用/","excerpt":"一、 BeeHive 介绍 BeeHive 是阿里巴巴公司开源的一个 iOS 框架，这个框架是 App 模块化编程的框架一种实现方案，吸收了 Spring 框架 Service 的理念来实现模块间的 API 解耦。","text":"一、 BeeHive 介绍 BeeHive 是阿里巴巴公司开源的一个 iOS 框架，这个框架是 App 模块化编程的框架一种实现方案，吸收了 Spring 框架 Service 的理念来实现模块间的 API 解耦。 BeeHive 这个名字灵感来源于蜂窝。蜂窝是世界上高度模块化的工程结构，六边形的设计能带来无限扩张的可能。所以就用了这个名字作为开源项目的名字。 二、BeeHive 使用 新建一个 AppDelegate 继承 BHAppDelegate 在 main.m 文件内修改 AppDelegate 123456int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; return UIApplicationMain(argc, argv, nil, NSStringFromClass([HPAppDelegate class])); &#125;&#125; 在 BHAppDelegate 内引用 BeeHive 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; [BHContext shareInstance].application = application; [BHContext shareInstance].launchOptions = launchOptions; /* 配置环境 BHEnvironmentType 给出定义四种环境，缺点是环境多余四种了不好扩充 */#if DEBUG [BHContext shareInstance].env = BHEnvironmentDev;#else [BHContext shareInstance].env = BHEnvironmentProd;#endif [BeeHive shareInstance].enableException = true; [[BeeHive shareInstance] setContext:[BHContext shareInstance]]; [super application:application didFinishLaunchingWithOptions:launchOptions]; id &lt;HPMainServiceProtocol&gt; mainService = [[BeeHive shareInstance] createService:@protocol(HPMainServiceProtocol)]; /* 模块化主要是 BaseServiceProtocol 和服务操作，不涉及UI。 Protocol定义该模块内的方法。在service内实现该Protocol定义的方法 */ UIViewController *vc = [mainService getController]; self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds]; [self.window setBackgroundColor:[UIColor whiteColor]]; self.window.rootViewController = vc; [self.window makeKeyAndVisible]; return YES;&#125; 模块注册 1、每一个模块对应一个 Protocol ， service，Moudle 2、所有的模块都遵守 BHModuleProtocol 协议 3、可以使用 BH_EXPORT_MODULE(NO) 是否异步加载 Moudle (该方法是在 +load 方法内调用, 需要写到 @implementation 和 @end 之间) 4、也可以使用 @BeeHiveMod(BaseMoudle) 来注册 Moudlle (该方法是在应用启动前, 加载符号文件时候调用) 5、没个 service 文件中 都必须导入该服务的协议。 123456789#import \"HPMainServiceProtocol.h\"BeeHiveService(HPMainServiceProtocol, HPMainMoudleService)@interface HPMainMoudleService () &lt;HPMainServiceProtocol&gt;@end 6、在每个 Moudle 内去实现自定义处理事件，例如可以独立出一个 推送模块 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798@implementation APNSMoudle//如果不去设置Level默认是Normal//basicModuleLevel不去实现默认Normal- (void)basicModuleLevel;//越大越优先- (NSInteger)modulePriority;- (BOOL)async- (void)modSetUp:(BHContext *)context &#123;&#125;- (void)modDidRegisterForRemoteNotifications:(BHContext *)context &#123;&#125;- (void)modDidFailToRegisterForRemoteNotifications:(BHContext *)context &#123;&#125;- (void)modDidReceiveRemoteNotification:(BHContext *)context&#123;&#125;- (void)modDidEnterBackground:(BHContext *)context &#123;&#125;- (void)modWillEnterForeground:(BHContext *)context &#123;&#125;- (void)modDidBecomeActive:(BHContext *)context &#123; BOOL isOpenNotify = [self isAllowedNotification]; if (isOpenNotify) &#123;//推送被关闭 [[UIApplication sharedApplication] unregisterForRemoteNotifications]; &#125; else &#123; //已经开启推送 [[UIApplication sharedApplication] registerForRemoteNotifications]; &#125;&#125;//MARK: 判断不同系统下用户是否在设置界面关闭了推送- (BOOL)isAllowedNotification &#123; // YES关闭。NO未关闭 UIUserNotificationSettings *setting = [[UIApplication sharedApplication] currentUserNotificationSettings]; return (setting.types== UIUserNotificationTypeNone) ? YES : NO;&#125;-(void)modWillResignActive:(BHContext *)context &#123;&#125;- (void)modOpenURL:(BHContext *)context&#123; NSDictionary *options = context.openURLItem.options; NSURL *url = context.openURLItem.openURL; BOOL result = [[UMSocialManager defaultManager] handleOpenURL:url options:options]; if (!result) &#123; // 其他如支付等SDK的回调 if ([url.host isEqualToString:@\"safepay\"]) &#123; &#125; &#125;&#125;@end","categories":[{"name":"移动端","slug":"移动端","permalink":"https://www.cqzhong.cn/categories/移动端/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.cqzhong.cn/tags/iOS/"},{"name":"BeeHive","slug":"BeeHive","permalink":"https://www.cqzhong.cn/tags/BeeHive/"}]},{"title":"iOS9以后更改状态栏颜色","slug":"iOS9以后更改状态栏颜色","date":"2019-03-19T04:58:06.000Z","updated":"2020-11-03T10:21:35.528Z","comments":true,"path":"2019/03/19/iOS9以后更改状态栏颜色/","link":"","permalink":"https://www.cqzhong.cn/2019/03/19/iOS9以后更改状态栏颜色/","excerpt":"","text":"1234567891011@property (nonatomic, assign) UIStatusBarStyle statusBarStyle;- (void)viewWillAppear:(BOOL)animated &#123; [super viewWillAppear:animated]; self.statusBarStyle = UIStatusBarStyleDefault; [self setNeedsStatusBarAppearanceUpdate];&#125;- (UIStatusBarStyle)preferredStatusBarStyle &#123; return self.statusBarStyle;&#125;","categories":[{"name":"移动端","slug":"移动端","permalink":"https://www.cqzhong.cn/categories/移动端/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.cqzhong.cn/tags/iOS/"},{"name":"StatusBarStyle","slug":"StatusBarStyle","permalink":"https://www.cqzhong.cn/tags/StatusBarStyle/"}]},{"title":"iOS后台下载注意问题","slug":"iOS后台下载注意问题","date":"2019-03-07T03:46:52.000Z","updated":"2020-11-03T10:21:35.581Z","comments":true,"path":"2019/03/07/iOS后台下载注意问题/","link":"","permalink":"https://www.cqzhong.cn/2019/03/07/iOS后台下载注意问题/","excerpt":"设置 session","text":"设置 session 12345678AppDelegate中- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; 1、启动App时候设置下载的NSURLSession，这时候如果上次下载内容未保存，会进入NSURLSessionDownloadDelegate的代理方法 URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error 2、存在error，从error中取出 NSData *resumeData = error ? [error.userInfo objectForKey:NSURLSessionDownloadTaskResumeData]:nil; 然后怼resumeData进行存储，便于恢复下载时候找到NSURLSessionDownloadTask [[CDDownloadTool sharedDownloadTool] configureBackroundSession];&#125; 设置下载标示 - (void)application:(UIApplication *)application handleEventsForBackgroundURLSession:(NSString _)identifier completionHandler:(void (^)(void))completionHandler 内设置后台下载完成标识符。 在清除缓存文件时候 注意 Library - cache - com.apple.nsurlsessiond 的文件夹，清除后一定要重建，不然会造成下载失败。","categories":[{"name":"移动端","slug":"移动端","permalink":"https://www.cqzhong.cn/categories/移动端/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.cqzhong.cn/tags/iOS/"}]},{"title":"CocoaPods问题总结","slug":"CocoaPods问题总结","date":"2019-01-21T03:00:00.000Z","updated":"2020-11-03T10:21:35.788Z","comments":true,"path":"2019/01/21/CocoaPods问题总结/","link":"","permalink":"https://www.cqzhong.cn/2019/01/21/CocoaPods问题总结/","excerpt":"解决错误信息[!] Unable to find a pod with name, author, summary, or description matching 1、检查本地有没有 repos 11、~/.cocoapods/repos","text":"解决错误信息[!] Unable to find a pod with name, author, summary, or description matching 1、检查本地有没有 repos 11、~/.cocoapods/repos 2、如果本地没有 12345678910111、删除现有基于 git 的 repo。pod repo remove master2、添加pod repo add master https://github.com/CocoaPods/Specs.git3、删除搜索缓存rm ~/Library/Caches/CocoaPods/search_index.json4、搜索第三方库pod search afnetworking 3、如果本地有 12345678// 1、更新本地repopod repo update// 2、删除搜索缓存rm ~/Library/Caches/CocoaPods/search_index.json// 3、搜索第三方库pod search afnetworking 搜索类库失败的解决办法 2 12345678910111213141、执行pod setup其实在你安装CocoaPods执行pod install时， 系统会默认操作pod setup，然而由于中国强大的墙可能会pod setup不成功。这时就需要手动执行pod setup指令，如下：终端输入：pod setup会出现Setting up CocoaPods master repo，稍等几十秒，最底下会输出Setup completed。说明执行pod setup成功。如果pod search操作还是搜索失败，如下：终端输入：pod search AFNetworking输出：Unable to find a pod with name, author, summary, or descriptionmatching &apos;AFNetworking&apos; 这时就需要继续下面的步骤了。2、删除~/Library/Caches/CocoaPods目录下的search_index.json文件pod setup成功后，依然不能pod search，是因为之前你执行pod search生成了search_index.json，此时需要删掉。终端输入：rm ~/Library/Caches/CocoaPods/search_index.json删除成功后，再执行pod search。3、执行pod search终端输入：pod search afnetworking(不区分大小写)输出：Creating search index for spec repo &apos;master&apos;.. Done!，稍等片刻······就会出现所有带有afnetworking字段的类库。 如果更新完成后还是无法获取到最新的库，那就是本地仓库没更新 更新本地仓库，本地仓库完成后，即可搜索到指定的第三方库 1pod repo update 私有库刚提交，但是搜索不到的问题 1pod search 私有库 --simple 错误：You don’t have write permissions for the /usr/bin directory. 解决方案 1sudo gem install cocoapods --pre -n /usr/local/bin 卸载错误 1sudo gem uninstall -n /usr/local/bin cocoapods","categories":[{"name":"移动端","slug":"移动端","permalink":"https://www.cqzhong.cn/categories/移动端/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.cqzhong.cn/tags/iOS/"},{"name":"CocoaPods","slug":"CocoaPods","permalink":"https://www.cqzhong.cn/tags/CocoaPods/"}]},{"title":"CocoaPods安装步骤","slug":"CocoaPods安装步骤","date":"2019-01-20T03:46:52.000Z","updated":"2020-11-03T10:21:35.835Z","comments":true,"path":"2019/01/20/CocoaPods安装步骤/","link":"","permalink":"https://www.cqzhong.cn/2019/01/20/CocoaPods安装步骤/","excerpt":"CocoaPods Blog 安装步骤 更新系统 Ruby 环境 1234# 这一步骤需要科学上网sudo gem update --system# 查看已安装的 Ruby 版本（最新版本：3.0.6，截止20200430）gem -v","text":"CocoaPods Blog 安装步骤 更新系统 Ruby 环境 1234# 这一步骤需要科学上网sudo gem update --system# 查看已安装的 Ruby 版本（最新版本：3.0.6，截止20200430）gem -v 替换镜像源 123456789101112//1、移除源sudo gem sources -r http://rubygems.org//或者gem sources --remove https://rubygems.org///2、添加源sudo gem sources -a https://rubygems.org//或者gem sources -add https://gems.ruby-china.com///3、检查源是否被替换gem sources -l 安装 cocoapods 1、安装 cocoapods 的预览版本 1sudo gem install -n /usr/local/bin cocoapods --pre 2、安装 cocoapods 到指定目录 123sudo gem install -n /usr/local/bin cocoapods// 或者sudo gem install cocoapods -n /usr/local/bin 卸载 卸载 1sudo gem uninstall cocoapods 查看安装列表 1gem list --local | grep cocoapods Demo 1234567891011121314151617181920212223242526272829303132333435363738394041424344Select gem to uninstall: 1. cocoapods-1.2.0.beta.3 2. cocoapods-1.2.0 3. cocoapods-1.2.1.beta.1 4. All versions&gt; 4Successfully uninstalled cocoapods-1.2.0.beta.3Successfully uninstalled cocoapods-1.2.0Remove executables:pod, sandbox-podin addition to the gem? [Yn] yRemoving podRemoving sandbox-podSuccessfully uninstalled cocoapods-1.2.0macminideMac-mini:~ macmini$ gem list --local | grep cocoapodscocoapods-core (1.2.0)cocoapods-deintegrate (1.0.1)cocoapods-downloader (1.1.3)cocoapods-plugins (1.0.0)cocoapods-search (1.0.0)cocoapods-stats (1.0.0)cocoapods-trunk (1.1.2)cocoapods-try (1.1.0)macminideMac-mini:~ macmini$ sudo gem uninstall cocoapods-coreSuccessfully uninstalled cocoapods-core-1.2.0ggzj@ggzjdeMacBook-Pro ~ % sudo gem uninstall cocoapods-coreSuccessfully uninstalled cocoapods-core-1.9.1ggzj@ggzjdeMacBook-Pro ~ % sudo gem uninstall cocoapods-deintegrateSuccessfully uninstalled cocoapods-deintegrate-1.0.4ggzj@ggzjdeMacBook-Pro ~ % sudo gem uninstall cocoapods-downloaderSuccessfully uninstalled cocoapods-downloader-1.3.0ggzj@ggzjdeMacBook-Pro ~ % sudo gem uninstall cocoapods-pluginsSuccessfully uninstalled cocoapods-plugins-1.0.0ggzj@ggzjdeMacBook-Pro ~ % sudo gem uninstall cocoapods-searchSuccessfully uninstalled cocoapods-search-1.0.0ggzj@ggzjdeMacBook-Pro ~ % sudo gem uninstall cocoapods-statsSuccessfully uninstalled cocoapods-stats-1.1.0ggzj@ggzjdeMacBook-Pro ~ % sudo gem uninstall cocoapods-trunkSuccessfully uninstalled cocoapods-trunk-1.4.1ggzj@ggzjdeMacBook-Pro ~ % sudo gem uninstall cocoapods-trySuccessfully uninstalled cocoapods-try-1.1.0","categories":[{"name":"移动端","slug":"移动端","permalink":"https://www.cqzhong.cn/categories/移动端/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.cqzhong.cn/tags/iOS/"},{"name":"CocoaPods","slug":"CocoaPods","permalink":"https://www.cqzhong.cn/tags/CocoaPods/"}]},{"title":"码云和GitHub Desktop建立联系","slug":"码云和GitHub Desktop建立联系","date":"2019-01-12T02:46:52.000Z","updated":"2020-11-03T10:21:35.705Z","comments":true,"path":"2019/01/12/码云和GitHub Desktop建立联系/","link":"","permalink":"https://www.cqzhong.cn/2019/01/12/码云和GitHub Desktop建立联系/","excerpt":"电脑生成 ssh 密钥 一：打开终端命令工具，输入命令：ssh-keygen -t rsa -C “这里写你邮箱”","text":"电脑生成 ssh 密钥 一：打开终端命令工具，输入命令：ssh-keygen -t rsa -C “这里写你邮箱” 注意 ssh-keygen 没有空格。屏幕输出： Generating public/private rsa key pair. Enter file in which to save the key (/Users/xxx/.ssh/id_rsa):这里输入你的 ssh 密钥文件名 Enter passphrase (empty for no passphrase): 输入密码 Enter same passphrase again: 确认密码 屏幕提示生成密钥文件成功，保存在/Users/xxx 文件夹下。 二：把 xxx.pub 中的内容加入 git@osc 的 SSH 密钥中 三：添加 SSH 并连接 输入命令：ssh-add ~/xxx ~/xxx 是刚刚生成的密钥文件路径，屏幕输出： Enter passphrase for /Users/xxx/xxx:输入密码 Identity added: /Users/xxx /xxx (/Users/xxx /xxx) 输入命令 ssh -T git@git.oschina.net 回车 屏幕显示链接成功。 四：打开 GitHub Desktop 选择 File -&gt; clone reponsitory -&gt; URL 输入项目地址，选择存放本地的项目路径。点击 clone 五：在 GitHub Desktop 上尽情地提交、同步吧！ 六：和码云、gitlab、腾讯云开发者平台、CODING 建立链接的命令 ssh-add 密钥文件路径 ssh -T git@git.oschina.net ssh -T git@gitlab.xxxx.com ssh -T git@github.com ssh -T git@git.dev.tencent.com ssh -T git@git.e.coding.net","categories":[{"name":"其它","slug":"其它","permalink":"https://www.cqzhong.cn/categories/其它/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.cqzhong.cn/tags/git/"}]},{"title":"VSCode workspace 地址修改","slug":"VSCode workspace 地址修改","date":"2019-01-11T06:00:00.000Z","updated":"2020-11-03T10:21:35.299Z","comments":true,"path":"2019/01/11/VSCode workspace 地址修改/","link":"","permalink":"https://www.cqzhong.cn/2019/01/11/VSCode workspace 地址修改/","excerpt":"新建一个.code-workspace 格式文件。然后写入以下代码 12345678&#123; \"folders\": [ &#123; \"path\": \"../wx\" &#125; ], \"settings\": &#123;&#125;&#125;","text":"新建一个.code-workspace 格式文件。然后写入以下代码 12345678&#123; \"folders\": [ &#123; \"path\": \"../wx\" &#125; ], \"settings\": &#123;&#125;&#125; path 指的是地址、指定项目路径 setings 当前 workspace 的配置 双击 service.code-workspace 文件使用 Visual Studio Code 打开项目。","categories":[{"name":"其它","slug":"其它","permalink":"https://www.cqzhong.cn/categories/其它/"}],"tags":[{"name":"VSCode","slug":"VSCode","permalink":"https://www.cqzhong.cn/tags/VSCode/"}]},{"title":"iOS自动打包fastlane配置","slug":"iOS自动打包fastlane配置","date":"2018-12-28T07:06:53.000Z","updated":"2020-11-03T10:21:35.736Z","comments":true,"path":"2018/12/28/iOS自动打包fastlane配置/","link":"","permalink":"https://www.cqzhong.cn/2018/12/28/iOS自动打包fastlane配置/","excerpt":"检查是否安装 Xcode ：xcode-select --install sudo gem install fastlane -NV //出现错误，重新安装 ruby 即可解决：brew install ruby 或者它安装：gem install fastlane 121、报错： You don&apos;t have write permissions for the /usr/bin directory. 解决：brew cask install fastlane 或者：sudo gem install cocoapods -n /usr/local/bin","text":"检查是否安装 Xcode ：xcode-select --install sudo gem install fastlane -NV //出现错误，重新安装 ruby 即可解决：brew install ruby 或者它安装：gem install fastlane 121、报错： You don&apos;t have write permissions for the /usr/bin directory. 解决：brew cask install fastlane 或者：sudo gem install cocoapods -n /usr/local/bin cd app 目录 fastlane init fastlane add_plugin pgyer //安装蒲公英插件 安装蒲公英插件出错时候 12345678910111213141516171819# 1、移除gem sources --remove https://ruby.taobao.org/# 2、添加gem sources -a https://gems.ruby-china.org/gem sources -a https://gems.ruby-china.com/# 3、查看gem sources -l# 4、修改Gemfile文件# 报错：（Installing plugin dependencies...Could not fetch specs from https://ruby.taobao.org/）# 修改Gemfile为 https://gems.ruby-china.com/source \"https://gems.ruby-china.com/\"gem \"fastlane\" vim ./fastlane/Fastfile //查看 Fastfile 文件 安装错误： 123456# 查询Xcode路径xcode-select -pxcode-select -print-path# 修改Xcode 路径：sudo xcode-select --switch /Applications/Xcode.app/sudo xcode-select --switch /Applications/你自己安装的路径 desc “打包到 pgy&quot;lane :test do |options|gym( clean:true, #打包前 clean 项目 export_method: “ad-hoc”, #导出方式 scheme:“shangshaban”, #scheme configuration: “Debug”,#环境 output_directory:”./app&quot;,#ipa 的存放目录 output_name:get_build_number()#输出 ipa 的文件名为当前的 build 号 )#蒲公英的配置 替换为自己的 api_key 和 user_keypgyer(api_key: “xxxxxxx”, user_key: “xxxxxx”,update_description: options[:desc])end 在终端用 gem 命令的时候，时常遇到的问题： 墙墙墙 通过 gem source 查看你的当前的 gem 资源库位置，如果你的当前资源库的位置为： https://rubygems.org/，不好意思，你是无法安装成功的，因为这个资源库在国外，所以你需要安装的 githug 是无法下载成功的，那我们怎么办呢，其实方法很简单，修改当前资源库的位置： 1- gem sources -r https://rubygems.org/ 删除原来的资源库位置 2- gem sources -a https://ruby.taobao.org/ 添加新的资源库位置 3- gem sources -u 更新资源库 目录权限不够 报错： ERROR: While executing gem … (Gem::FilePermissionError) You don’t have write permissions for the /Library/Ruby/Gems/2.0.0 directory. 解决： sudo chmod 777 /Library/Ruby/Gems/2.0.0 修改权限 gem 需要更新 报错： ERROR: While executing gem … (Errno::EACCES) Permission denied - /Library/Ruby/Gems/2.0.0/cache/i18n-0.7.0.gem 解决： gem update –system 如果还是不行，又想用 gem 安装怎么办？sudo gem install….","categories":[{"name":"移动端","slug":"移动端","permalink":"https://www.cqzhong.cn/categories/移动端/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.cqzhong.cn/tags/iOS/"},{"name":"fastlane","slug":"fastlane","permalink":"https://www.cqzhong.cn/tags/fastlane/"}]},{"title":"xib适配不同屏幕（等比缩放）","slug":"xib适配不同屏幕（等比缩放）","date":"2018-12-07T05:36:56.000Z","updated":"2020-11-03T10:21:35.491Z","comments":true,"path":"2018/12/07/xib适配不同屏幕（等比缩放）/","link":"","permalink":"https://www.cqzhong.cn/2018/12/07/xib适配不同屏幕（等比缩放）/","excerpt":"基本所有的 UI 效果图都是以 iPhone6 屏幕为基准来设计的，在 4.7 的屏幕上没有问题，但是到其它屏幕上，就不是 UI 图上的效果了。各个控件的上、左、下、右、宽、高约束都不是想要的比例了。这个时候就要从 xib 拉出 NSLayoutConstraint 属性来动态设置数值了。 怎样才能达到按照一个屏幕尺寸去做开发，使其它所有屏幕都是自动等比缩放呢？","text":"基本所有的 UI 效果图都是以 iPhone6 屏幕为基准来设计的，在 4.7 的屏幕上没有问题，但是到其它屏幕上，就不是 UI 图上的效果了。各个控件的上、左、下、右、宽、高约束都不是想要的比例了。这个时候就要从 xib 拉出 NSLayoutConstraint 属性来动态设置数值了。 怎样才能达到按照一个屏幕尺寸去做开发，使其它所有屏幕都是自动等比缩放呢？ 这里主要提供一种利用 xib 做开发，做到适配不同屏幕的方法。 关键字 IBInspectable 出现新的可编辑属性 和 User Defined Runtime Attributes 新建一个 NSLayoutConstraint 的类别 NSLayoutConstraint.h 12345678910111213#import &lt;UIKit/UIKit.h&gt;NS_ASSUME_NONNULL_BEGIN@interface NSLayoutConstraint (ItemEdge)// IBInspectable 出现新的可编辑属性 和 User Defined Runtime Attributes@property (nonatomic, assign) IBInspectable BOOL adapterScreen;@endNS_ASSUME_NONNULL_END NSLayoutConstraint.m 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#import \"NSLayoutConstraint+ItemEdge.h\"@implementation NSLayoutConstraint (ItemEdge)@dynamic adapterScreen;static char associateLengthKey;- (BOOL)adapterScreen &#123; return [(NSNumber *)objc_getAssociatedObject(self, &amp;associateLengthKey) boolValue];&#125;- (void)setAdapterScreen:(BOOL)adapterScreen &#123; objc_setAssociatedObject(self, &amp;associateLengthKey, @(adapterScreen), OBJC_ASSOCIATION_RETAIN_NONATOMIC); if (adapterScreen) &#123; switch (self.firstAttribute) &#123; case NSLayoutAttributeTop: &#123; self.constant = CDREALVALUE_HEIGHT(self.constant); if (CD_IS_IPHONE_X &amp;&amp; [self.identifier isEqualToString:@\"T\"]) &#123; self.constant += 24; &#125; break; &#125; case NSLayoutAttributeBottom: &#123; self.constant = CDREALVALUE_HEIGHT(self.constant); if (CD_IS_IPHONE_X &amp;&amp; [self.identifier isEqualToString:@\"B\"]) &#123; self.constant += 34; &#125; break; &#125; case NSLayoutAttributeHeight: &#123; self.constant = CDREALVALUE_HEIGHT(self.constant); break; &#125; case NSLayoutAttributeLeft: case NSLayoutAttributeRight: case NSLayoutAttributeTrailing: case NSLayoutAttributeLeading: case NSLayoutAttributeWidth: &#123; self.constant = CDREALVALUE_WIDTH(self.constant); break; &#125; default: break; &#125; &#125;&#125;@end 上面的代码牵扯到一些宏定义 CD_IS_IPHONE_X ：判断机型是否使带刘海的手机。 CDREALVALUE_HEIGHT() 根据基准机型等比缩放约束的高度。 CDREALVALUE_WIDTH() 根据基准机型等比缩放约束的宽度。 怎样在 xib 内使用 约束完成后点中 NSLayoutConstraint 约束 将 Adapter Screen 属性改为 on，这样就会进入到 setAdapterScreen 方法内，对每个约束进行你要要的缩放。","categories":[{"name":"移动端","slug":"移动端","permalink":"https://www.cqzhong.cn/categories/移动端/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.cqzhong.cn/tags/iOS/"},{"name":"Xcode","slug":"Xcode","permalink":"https://www.cqzhong.cn/tags/Xcode/"},{"name":"xib","slug":"xib","permalink":"https://www.cqzhong.cn/tags/xib/"},{"name":"iOS适配","slug":"iOS适配","permalink":"https://www.cqzhong.cn/tags/iOS适配/"}]},{"title":"App 打开微信小程序","slug":"App 打开微信小程序","date":"2018-11-30T07:06:53.000Z","updated":"2020-11-03T10:21:35.746Z","comments":true,"path":"2018/11/30/App 打开微信小程序/","link":"","permalink":"https://www.cqzhong.cn/2018/11/30/App 打开微信小程序/","excerpt":"导入 sdk 1po 'WechatOpenSDK'","text":"导入 sdk 1po 'WechatOpenSDK' 设置 URL Types weixin 加入到 LSApplicationQueriesSchemes 白名单 App Transport Security Settings、Allow Arbitrary Loads 打开 入口类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#import \"WXApi.h\"@interface CDAppDelegate : UIResponder &lt;UIApplicationDelegate, WXApiDelegate&gt;@property (strong, nonatomic) UIWindow *window;@end#import \"CDAppDelegate.h\"#import \"CDViewController.h\"@implementation CDAppDelegate- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; [WXApi registerApp:@\"wx9bda0261a717aedb\"];// [WXApi registerApp:@\"wx425878e5ac948779\"]; self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds]; self.window.backgroundColor = [UIColor whiteColor]; self.window.rootViewController = [CDViewController new]; [self.window makeKeyAndVisible]; return true;&#125;- (BOOL)application:(UIApplication *)application handleOpenURL:(NSURL *)url &#123; return [WXApi handleOpenURL:url delegate:self];&#125;- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation &#123; return [WXApi handleOpenURL:url delegate:self];&#125;-(void) onReq:(BaseReq*)req &#123;&#125;-(void) onResp:(BaseResp*)resp &#123; if ([resp isKindOfClass:[WXLaunchMiniProgramResp class]]) &#123; WXLaunchMiniProgramReq *miniProgramReq = (WXLaunchMiniProgramReq *)resp; NSString *string = miniProgramReq.extMsg; // 对应JsApi navigateBackApplication中的extraData字段数据 NSLog(@\"%@\", string); &#125;&#125;@end","categories":[{"name":"移动端","slug":"移动端","permalink":"https://www.cqzhong.cn/categories/移动端/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.cqzhong.cn/tags/iOS/"},{"name":"微信小程序","slug":"微信小程序","permalink":"https://www.cqzhong.cn/tags/微信小程序/"}]},{"title":".xcassets文件说明和解压 Assets.car文件","slug":"xcassets文件说明和解压 Assets.car文件","date":"2018-11-13T07:06:53.000Z","updated":"2020-11-03T10:21:35.933Z","comments":true,"path":"2018/11/13/xcassets文件说明和解压 Assets.car文件/","link":"","permalink":"https://www.cqzhong.cn/2018/11/13/xcassets文件说明和解压 Assets.car文件/","excerpt":"Assets.xcassets 是用来存放图像资源文件的。","text":"Assets.xcassets 是用来存放图像资源文件的。 如果图片存放在 assets 资源管理器,最终里面所以的图片会被打包成 Assets.car(用 ThemeEngine 可以把图片弄出来),其作用在于 1、 自动识别@2x，@3x 图片， 2、 根据不同的设备，不同的分辨率设置相应的图片。 3、 可以对图片进行剪裁和拉伸处理 在.car 中的图片是不能通过 imageWithContentsOfFile:来加载 imageName:加载的图片要么是 Assets.car 中的图片,要么是资源包(mainBundle)中直接存放的图片。如果用 imageNamed:从 Images.xcassets 以外的地方加载图片，必须在文件名后加扩展名，例如： UIImage *image=[UIImage imageNamed:@“plus.png”]; 将图片放在 xcassets 文件中的好处： 1、组织清晰 2、不同功用的图片有专门的格式 3、不同分辨率的图片好管理 4、工程打包后会对图片进行压缩 这里我要着重说一下第四点，包的大小，如果将图片直接放在工程目录下面，项目打包后图片文件也是散落在包里面，而且不会对图片进行压缩，而如果放在 xcassets 中，在打包后会将这些图片（除了 AppIcon 和 LaunchImage，这两种图片是直接放在包中的）统一压缩成一个 Assets.car 的文件，大大减小包的大小，具体是几倍的关系我记不清了，但是相当的可观。 说完 Assets.xcassets，那么说说由它生成的 Assets.car 文件，这个文件是一种压缩文件。 我们在开发过程中肯定会遇到一种情况就是把一个 ipa 的包解压出来看看里面有哪些图片，不管是不是自己的项目，总可能会有这种需求，那如果图片都在 Assets.car 中该怎么获取呢，直接解压是不行的，这时候就需要用到一个命令行工具叫 cartool，这是一个开源软件，可以从 github 下载，这里给出 github 地址：https://github.com/steventroughtonsmith/cartool 解压方法 1、打开终端 2、拖入 cartool 文件 空格 Assets.car 空格 目标文件路径","categories":[{"name":"移动端","slug":"移动端","permalink":"https://www.cqzhong.cn/categories/移动端/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.cqzhong.cn/tags/iOS/"},{"name":"cartool","slug":"cartool","permalink":"https://www.cqzhong.cn/tags/cartool/"},{"name":"Asset.car","slug":"Asset-car","permalink":"https://www.cqzhong.cn/tags/Asset-car/"}]},{"title":"AlicloudHTTPDNS接入","slug":"AlicloudHTTPDNS接入","date":"2018-11-08T06:04:11.000Z","updated":"2020-11-03T10:21:35.758Z","comments":true,"path":"2018/11/08/AlicloudHTTPDNS接入/","link":"","permalink":"https://www.cqzhong.cn/2018/11/08/AlicloudHTTPDNS接入/","excerpt":"一、pods 导入 1pod 'AlicloudHTTPDNS', '~&gt; 1.6.17'","text":"一、pods 导入 1pod 'AlicloudHTTPDNS', '~&gt; 1.6.17' 二、启动配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107@interface CDConfigMoudle () &lt;HttpDNSDegradationDelegate&gt;@end- (void)modSetUp:(BHContext *)context &#123;[self configurationHttpDNSService:(context.env == BHEnvironmentDev || context.env == BHEnvironmentTest)];[self configurationNetwork:context];&#125;//MARK: - DNS配置- (void)configurationHttpDNSService:(BOOL)debug &#123;HttpDnsService *httpdns = [[HttpDnsService alloc] autoInit];// 为HTTPDNS服务设置降级机制[httpdns setDelegateForDegradationFilter:self];// 允许返回过期的IP[httpdns setExpiredIPEnabled:true];[httpdns setLogEnabled:debug];[httpdns setHTTPSRequestEnabled:true];NSArray* preResolveHosts = @[@\"sapi.changguwen.com\", @\"m.changguwen.com\"];// 设置预解析域名列表[httpdns setPreResolveHosts:preResolveHosts];NSDictionary *IPRankingDatasource = @&#123;@\"sapi.changguwen.com\" : @80,@\"m.changguwen.com\" : @80&#125;;// IP 优选功能，设置后会自动对IP进行测速排序，可以在调用 `-getIpByHost` 等接口时返回最优IP。[httpdns setIPRankingDatasource:IPRankingDatasource];&#125;///MARK: HttpDNSDegradationDelegate- (BOOL)shouldDegradeHTTPDNS:(NSString *)hostName &#123;//存在网络代理if ([[CDNetworkReachability manager] configureProxies]) &#123;return true;&#125;return false;&#125;//MARK: - 配置请求- (void)configurationNetwork:(BHContext *)context &#123;YTKNetworkConfig *config = [YTKNetworkConfig sharedConfig];config.securityPolicy.allowInvalidCertificates = true;[config.securityPolicy setValidatesDomainName:false];switch (context.env) &#123;case BHEnvironmentDev: &#123;config.baseUrl = kRequestURLBaseDebug;break;&#125;case BHEnvironmentTest: &#123;config.baseUrl = kRequestURLBaseTest;break;&#125;case BHEnvironmentStage: &#123;config.baseUrl = kRequestURLBaseAdHoc;break;&#125;case BHEnvironmentProd: &#123;config.baseUrl = kRequestURLBaseRelease;break;&#125;default:break;&#125;[CDSQLiteManager manager].debugURLBase = config.baseUrl;dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;// if (context.env == BHEnvironmentStage ||// context.env == BHEnvironmentProd) &#123;NSURL *baseUrl = [NSURL URLWithString:config.baseUrl];NSString *ip = [[HttpDnsService sharedInstance] getIpByHostAsyncInURLFormat:baseUrl.host];if (ip.length ==0) return ;NSRange hostFirstRange = [baseUrl.absoluteString rangeOfString:baseUrl.host];if (NSNotFound != hostFirstRange.location) &#123;NSString *newUrl = [baseUrl.absoluteString stringByReplacingCharactersInRange:hostFirstRange withString:ip];config.baseUrl = newUrl;&#125;// &#125;&#125;);// config.cdnUrl = @\"\";[config addUrlFilter:[CDRequestURLFilter filter]];YTKNetworkAgent *agent = [YTKNetworkAgent sharedAgent];[agent setValue: [NSSet setWithObjects:@\"application/json\", @\"text/html\",@\"text/json\",@\"text/javascript\", @\"text/plain\",@\"text/xml\",@\"image/*\", nil]forKeyPath:@\"jsonResponseSerializer.acceptableContentTypes\"];&#125; 三、网络变化 1234567891011121314151617181920212223- (void)callBackForCurrentStatus&#123;#if defined(DEBUG) || defined(CDTEST)#elsedispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;NSURL *baseUrl = [NSURL URLWithString:CDSQLITE_MANAGER.debugURLBase];NSString *ip = [[HttpDnsService sharedInstance] getIpByHostAsyncInURLFormat:baseUrl.host];if (ip.length ==0) return ;NSRange hostFirstRange = [baseUrl.absoluteString rangeOfString:baseUrl.host];if (NSNotFound != hostFirstRange.location) &#123;NSString *newUrl = [baseUrl.absoluteString stringByReplacingCharactersInRange:hostFirstRange withString:ip];[YTKNetworkConfig sharedConfig].baseUrl = newUrl;&#125;&#125;);#endif&#125; 四、返回参数 1234567891011[文件名:CDBaseRequest.m] [函数名:-[CDBaseRequest requestCompleteFilter]] [第212行: 打印网络请求：&#123;&lt;CDCodeRequest: 0x2807ce800&gt;== 网络内容 ==接口===https://112.124.157.220/v1/information/shipmes?phone=13162079587请求头===&#123;\"Client-Method\":\"GET\",\"Accept-Language\":\"zh-Hans-CN;q=1\",\"Client-Platform\":\"ios\",\"Client-Platform-Version\":\"12.0\",\"Client-Token\":\"\",\"Client-Deviceid\":\"1efee266151c70b689355ed83559bba6\",\"Host\":\"sapi.changguwen.com\",\"Client-Source\":\"app\",\"Client-Network\":\"Wi-Fi\",\"User-Agent\":\"CDProgramme\\/1.0.1 (iPad; iOS 12.0; Scale\\/2.00)\",\"Client-Version\":\"1.0.1\"&#125;参数===&#123;\"phone\":\"13162079587\"&#125;内容===&#123;\"msg\" : \"请求成功\",\"data\" : 0,\"code\" : 0&#125;&#125;]","categories":[{"name":"移动端","slug":"移动端","permalink":"https://www.cqzhong.cn/categories/移动端/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.cqzhong.cn/tags/iOS/"}]},{"title":"iOS数组排序(Objective-C)","slug":"iOS数组排序(Objective-C)","date":"2018-10-14T04:58:06.000Z","updated":"2020-11-03T10:21:35.937Z","comments":true,"path":"2018/10/14/iOS数组排序(Objective-C)/","link":"","permalink":"https://www.cqzhong.cn/2018/10/14/iOS数组排序(Objective-C)/","excerpt":"iOS 数组排序的几种方法","text":"iOS 数组排序的几种方法 123456789101112131415161718192021222324252627281）self.products = [myProducts sortedArrayUsingComparator:^NSComparisonResult(id _Nonnull obj1, id _Nonnull obj2) &#123; SKProduct *pro1 = (SKProduct *)obj1; SKProduct *pro2 = (SKProduct *)obj2; return pro1.price.integerValue &lt; pro2.price.integerValue ? NSOrderedAscending : NSOrderedDescending;&#125;];（2）比较大小排序 从小到大排序 NSArray *sortedArray = [keyArr sortedArrayUsingComparator:^NSComparisonResult(NSString *obj1, NSString *obj2) &#123; if ([obj1 intValue] &lt; [obj2 intValue]) &#123; return NSOrderedAscending; &#125; else &#123; return NSOrderedDescending; &#125; &#125;];（3） 系统自带方法NSArray *arrays = [moneyArrays sortedArrayUsingSelector:@selector(compare:)];（4）NSArray 快速求总和 最大值 最小值 和 平均值NSArray *array = [NSArray arrayWithObjects:@\"2.0\", @\"2.3\", @\"3.0\", @\"4.0\", @\"10\", nil];CGFloat sum = [[array valueForKeyPath:@\"@sum.floatValue\"] floatValue];CGFloat avg = [[array valueForKeyPath:@\"@avg.floatValue\"] floatValue];CGFloat max =[[array valueForKeyPath:@\"@max.floatValue\"] floatValue];CGFloat min =[[array valueForKeyPath:@\"@min.floatValue\"] floatValue];NSLog(@\"%fn%fn%fn%f\",sum,avg,max,min);","categories":[{"name":"移动端","slug":"移动端","permalink":"https://www.cqzhong.cn/categories/移动端/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.cqzhong.cn/tags/iOS/"},{"name":"数组排序","slug":"数组排序","permalink":"https://www.cqzhong.cn/tags/数组排序/"}]},{"title":"app获取在AppStore的信息","slug":"app获取在AppStore的信息","date":"2018-10-13T04:58:06.000Z","updated":"2020-11-03T10:21:35.921Z","comments":true,"path":"2018/10/13/app获取在AppStore的信息/","link":"","permalink":"https://www.cqzhong.cn/2018/10/13/app获取在AppStore的信息/","excerpt":"","text":"[https://itunes.apple.com/cn/lookup?bundleId=(app](https://itunes.apple.com/cn/lookup?bundleId=(app)的bundleID) [https://itunes.apple.com/lookup?bundleId=com.(app](https://itunes.apple.com/lookup?bundleId=com.(app)的bundleID) [https://itunes.apple.com/lookup?id=(app](https://itunes.apple.com/lookup?id=(app)在开发者账号下的ID数字)","categories":[{"name":"移动端","slug":"移动端","permalink":"https://www.cqzhong.cn/categories/移动端/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.cqzhong.cn/tags/iOS/"},{"name":"AppStore","slug":"AppStore","permalink":"https://www.cqzhong.cn/tags/AppStore/"}]},{"title":"YTKNetwork 的使用总结(自定义请求、上传图片、取消请求)","slug":"YTKNetwork 的使用总结(自定义请求、上传图片、取消请求)","date":"2018-09-08T04:58:06.000Z","updated":"2020-11-03T10:21:35.476Z","comments":true,"path":"2018/09/08/YTKNetwork 的使用总结(自定义请求、上传图片、取消请求)/","link":"","permalink":"https://www.cqzhong.cn/2018/09/08/YTKNetwork 的使用总结(自定义请求、上传图片、取消请求)/","excerpt":"YTKNetwork 的配置","text":"YTKNetwork 的配置 1234567891011121314151617181920212223242526272829//MARK: - 配置请求- (void)configurationNetwork:(BHContext *)context &#123;YTKNetworkConfig *config = [YTKNetworkConfig sharedConfig];//根据环境配置请求的IP，可以在工程内获取baseURL： [YTKNetworkConfig sharedConfig].baseUrl;if (context.env == BHEnvironmentDev) &#123;config.baseUrl = kRequestURLBaseTest;&#125; else &#123;config.baseUrl = kRequestURLBaseProduct;&#125;// config.cdnUrl = @\"\";//过滤非法请求[config addUrlFilter:[HPRequestURLFilter filter]];YTKNetworkAgent *agent = [YTKNetworkAgent sharedAgent];//请求响应参数的类型[agent setValue: [NSSet setWithObjects:@\"application/json\", @\"text/html\",@\"text/json\",@\"text/javascript\", @\"text/plain\",@\"text/xml\",@\"image/*\", nil]forKeyPath:@\"jsonResponseSerializer.acceptableContentTypes\"];&#125; 取消请求 123[[YTKNetworkAgent sharedAgent] cancelAllRequests];[[YTKNetworkAgent sharedAgent] cancelRequest:]; 上传图片（单张、多张） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#import \"HPBaseRequest.h\"#import \"HPImageInfoModel.h\"// HPBaseRequest继承 YTKRequest 里面添加了一些自定义的方法。@interface HPHeadUploadRequest : HPBaseRequest &lt;HPImageInfoModel *&gt;+ (instancetype)requestWithImage:(UIImage *)image delegate:(id&lt;YTKRequestDelegate&gt;)delegate;@end#import \"HPHeadUploadRequest.h\"#import \"AFNetworking.h\"@interface HPHeadUploadRequest ()@property (nonatomic, strong) UIImage *image;@end@implementation HPHeadUploadRequest+ (instancetype)requestWithImage:(UIImage *)image delegate:(id&lt;YTKRequestDelegate&gt;)delegate &#123;HPHeadUploadRequest *request = [[HPHeadUploadRequest alloc] initWithParams:@&#123;&#125;];request.delegate = delegate;request.image = image;[request start];return request;&#125;- (NSMutableDictionary *)defaultParams &#123;return [NSMutableDictionary dictionaryWithObjectsAndKeys: HPRequestAliyunOSSAccount,HPRequestKeyPath ,HPRequestKeyImageType,HPRequestKeyType, nil];&#125;- (NSString *)requestUrl &#123;return @\"service-uploads-uploadfile.server\";&#125;- (AFConstructingBlock)constructingBodyBlock &#123;return ^(id&lt;AFMultipartFormData&gt; formData) &#123;NSDateFormatter *formatter = [[NSDateFormatter alloc] init];formatter.dateFormat = @\"yyyyMMddHHmmss\";NSString *str = [formatter stringFromDate:[NSDate date]];NSString *fileName = [NSString stringWithFormat:@\"%@.jpg\", str];NSData *data = UIImageJPEGRepresentation(self.image, 0.5);NSString *name = HPRequestKeyFileName;NSString *type = @\"image/jpeg/png/jpg\";[formData appendPartWithFileData:data name:name fileName:fileName mimeType:type];&#125;;&#125;- (YTKRequestMethod)requestMethod &#123;return YTKRequestMethodPOST;&#125;- (BOOL)contentIsArray &#123;return false;&#125;- (Class)contentType &#123;return [HPImageInfoModel class];&#125;@end 多张图片上传 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#import \"HPBaseRequest.h\"#import \"HPImageInfoModel.h\"@interface HPBatchUploadRequest : HPBaseRequest+ (instancetype)requestWithImage:(NSArray&lt;UIImage *&gt; *)imageM delegate:(id&lt;YTKRequestDelegate&gt;)delegate;@end#import \"HPBatchUploadRequest.h\"#import \"AFNetworking.h\"@interface HPBatchUploadRequest ()@property (nonatomic, strong) NSArray &lt;UIImage *&gt; *imageM;@end@implementation HPBatchUploadRequest+ (instancetype)requestWithImage:(NSArray&lt;UIImage *&gt; *)imageM delegate:(id&lt;YTKRequestDelegate&gt;)delegate &#123;HPBatchUploadRequest *request = [[HPBatchUploadRequest alloc] initWithParams:@&#123;&#125;];request.delegate = delegate;request.imageM = imageM;[request start];return request;&#125;- (NSMutableDictionary *)defaultParams &#123;return [NSMutableDictionary dictionaryWithObjectsAndKeys: HPRequestAliyunOSSAccount,HPRequestKeyPath ,HPRequestKeyImageType,HPRequestKeyType, nil];&#125;- (NSString *)requestUrl &#123;return @\"service-uploads-batchuploadfile.server\";&#125;- (AFConstructingBlock)constructingBodyBlock &#123;return ^(id&lt;AFMultipartFormData&gt; formData) &#123;for (int i = 0;i &lt;[self.imageM count] ;i ++) &#123;NSDateFormatter *formatter = [[NSDateFormatter alloc] init];formatter.dateFormat = @\"yyyyMMddHHmmss\";NSString *str = [formatter stringFromDate:[NSDate date]];NSString *fileName = [NSString stringWithFormat:@\"%@.jpg\", str];UIImage *image = self.imageM[i];NSData *data = UIImageJPEGRepresentation(image, 0.5);NSString *name = HPRequestKeyMoreFileName;NSString *type = @\"image/jpeg/png/jpg\";[formData appendPartWithFileData:data name:name fileName:fileName mimeType:type];&#125;&#125;;&#125;- (YTKRequestMethod)requestMethod &#123;return YTKRequestMethodPOST;&#125;- (BOOL)contentIsArray &#123;return false;&#125;@end YTKNetwork 自定义 request 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422#import \"BIMBaseRequest.h\"typedef NS_ENUM(NSInteger, BIMUploadRequestStatus) &#123;BIMUploadRequestStatusOverallCheck = 0,BIMUploadRequestStatusLeadershipShift = 1,&#125;;extern NSString * const BimImageGuidName;extern NSString * const BIMAmrGuidName;@interface BIMBatchUploadRequest : BIMBaseRequest+ (instancetype)requestStatus:(BIMUploadRequestStatus)status withImage:(NSArray *)imageDictionaryArraywithRecordFile:(NSArray*)amrDictionaryArray withParams:(NSMutableDictionary *)Paramsdelegate:(id&lt;YTKRequestDelegate&gt;)delegate;@end#import \"BIMBatchUploadRequest.h\"#import \"AFNetworking.h\"#import \"HPAudioRecorderTool.h\"#import \"LeaderPhotoFormCell.h\"#import \"LeaderRecordFormCell.h\"NSString *const BimImageGuidName = @\"&#123;guid1&#125;.jpg\";NSString *const BIMAmrGuidName = @\"&#123;guid2&#125;.amr\";@interface BIMBatchUploadRequest ()@property (nonatomic, assign)BIMUploadRequestStatus status;@property (nonatomic, strong) NSArray *imageDictionaryArray;@property (nonatomic, strong) NSArray *amrDictionaryArray;@property (nonatomic, strong) NSMutableDictionary *params;@end@implementation BIMBatchUploadRequest+ (instancetype)requestStatus:(BIMUploadRequestStatus)status withImage:(NSArray *)imageDictionaryArraywithRecordFile:(NSArray*)amrDictionaryArray withParams:(NSMutableDictionary *)Paramsdelegate:(id&lt;YTKRequestDelegate&gt;)delegate &#123;// BIMBatchUploadRequest *request = [[BIMBatchUploadRequest alloc] initWithParams:Params];BIMBatchUploadRequest *request = [[BIMBatchUploadRequest alloc] init];// BIMBatchUploadRequest *request = [[BIMBatchUploadRequest alloc]initWithParams:Params];request.params = Params;request.status = status;request.delegate = delegate;request.imageDictionaryArray = imageDictionaryArray;request.amrDictionaryArray = amrDictionaryArray;// request = (BIMBatchUploadRequest *)[request buildCustomUrlRequest];[request start];return request;&#125;- (NSString *)requestUrl &#123;if (_status == BIMUploadRequestStatusOverallCheck) &#123;return @\"api/App/CreateOverallCheck\";&#125;return @\"api/App/CreateLeadershipShift\";&#125;/* url : 本地文件路径* name : 与服务端约定的参数* fileName : 自己随便命名的* mimeType : 文件格式类型 [mp3 : application/octer-stream application/octet-stream] [mp4 : video/mp4]*/- (AFConstructingBlock)constructingBodyBlock &#123;return ^(id&lt;AFMultipartFormData&gt; formData) &#123;// [self.paraDict enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key, id _Nonnull obj, BOOL * _Nonnull stop) &#123;//// if ([obj isKindOfClass:[NSArray class]]) &#123;//// NSData *jsonData = [NSJSONSerialization dataWithJSONObject:obj options:NSJSONWritingPrettyPrinted error:nil];//// [formData appendPartWithFormData:jsonData name:key];// &#125;//// if ([obj isKindOfClass:[NSString class]]) &#123;//// NSData *stringData = [obj dataUsingEncoding:NSUTF8StringEncoding];// [formData appendPartWithFormData:stringData name:key];// &#125;// &#125;];// for (NSInteger i = 0;i &lt;[self.imageDictionaryArray count] ;i ++) &#123;//// NSDictionary *fileDictionary = self.imageDictionaryArray[i];//// NSString *fileName = fileDictionary[photoImageNameTag];//// UIImage *image = fileDictionary[photoImageTag];// NSData *data = UIImageJPEGRepresentation(image, 0.5);// NSString *name = BimImageGuidName;// NSString *type = @\"image/jpeg/png/jpg\";// [formData appendPartWithFileData:data name:name fileName:fileName mimeType:type];// &#125;&#125;;&#125;- (NSURLRequest *)buildCustomUrlRequest &#123;NSMutableData *body = [NSMutableData data];NSString *BOUNDARY = @\"0xKhTmLbOuNdArY\";/** 遍历字典将字典中的键值对转换成请求格式:--Boundary+72D4CD655314C423Content-Disposition: form-data; name=\"empId\"254--Boundary+72D4CD655314C423Content-Disposition: form-data; name=\"shopId\"18718*///表单数据 param[self.params enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123;NSMutableString *fieldStr = [NSMutableString string];[fieldStr appendString:[NSString stringWithFormat:@\"--%@\\r\\n\", BOUNDARY]];[fieldStr appendString:[NSString stringWithFormat:@\"Content-Disposition: form-data; name=\\\"%@\\\"\\r\\n\\r\\n\", key]];[fieldStr appendString:[NSString stringWithFormat:@\"%@\", obj]];NSLog(@\"file=====%@\",fieldStr);[body appendData:[fieldStr dataUsingEncoding:NSUTF8StringEncoding]];// [body appendData:[obj dataUsingEncoding:NSUTF8StringEncoding]];// NSData *data = [NSKeyedArchiver archivedDataWithRootObject:obj];// [body appendData:data];[body appendData:[@\"\\r\\n\" dataUsingEncoding:NSUTF8StringEncoding]];&#125;];//文件逻辑for (NSDictionary *fileDictionary in self.imageDictionaryArray) &#123;NSString *fileName = fileDictionary[photoImageNameTag];UIImage *image = fileDictionary[photoImageTag];NSData *data = UIImageJPEGRepresentation(image, 0.5);NSString *name = BimImageGuidName;NSString *type = @\"image\";NSString *param = [NSString stringWithFormat:@\"--%@\\r\\nContent-Disposition: form-data; name=\\\"%@\\\";filename=\\\"%@\\\"\\r\\nContent-Type: application/octet-stream\\r\\n\\r\\n\",BOUNDARY,[NSString stringWithFormat:@\"%@%@\",name,type],fileName,nil];[body appendData:[param dataUsingEncoding:NSUTF8StringEncoding]];[body appendData:data];[body appendData:[@\"\\r\\n\" dataUsingEncoding:NSUTF8StringEncoding]];&#125;for (NSDictionary *fileDictionary in self.amrDictionaryArray) &#123;NSString *filePath = fileDictionary[recordPathTag];NSString *fileName = [NSString stringWithFormat:@\"%@.amr\",fileDictionary[recordNameTag]];NSData *data = [[NSData alloc]initWithContentsOfURL:[NSURL fileURLWithPath:filePath]];NSString *name = BIMAmrGuidName;NSString *type = @\"amr\";NSString *param = [NSString stringWithFormat:@\"--%@\\r\\nContent-Disposition: form-data; name=\\\"%@\\\";filename=\\\"%@\\\"\\r\\nContent-Type: application/octet-stream\\r\\n\\r\\n\",BOUNDARY,[NSString stringWithFormat:@\"%@%@\",name,type],fileName,nil];[body appendData:[param dataUsingEncoding:NSUTF8StringEncoding]];[body appendData:data];[body appendData:[@\"\\r\\n\" dataUsingEncoding:NSUTF8StringEncoding]];&#125;NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:[NSString stringWithFormat:@\"%@%@\",[YTKNetworkConfig sharedConfig].baseUrl,self.requestUrl]]];NSString *endString = [NSString stringWithFormat:@\"--%@--\",BOUNDARY];[body appendData:[endString dataUsingEncoding:NSUTF8StringEncoding]];[request setHTTPBody:body];// 设置请求类型为post请求request.HTTPMethod = @\"post\";// 设置request的请求体request.HTTPBody = body;// 设置头部数据，标明上传数据总大小，用于服务器接收校验[request setValue:[NSString stringWithFormat:@\"%ld\", body.length] forHTTPHeaderField:@\"Content-Length\"];[request setValue:[BIMSQLiteManager manager].cookieToken forHTTPHeaderField:BIMRequestKeyCookie];// 设置头部数据，指定了http post请求的编码方式为multipart/form-data（上传文件必须用这个）。[request setValue:[NSString stringWithFormat:@\"multipart/form-data; boundary=%@\",BOUNDARY] forHTTPHeaderField:@\"Content-Type\"];//token 放请求头// [request setValue:@\"\" forHTTPHeaderField:@\"Authorization\"];return request;&#125;- (YTKRequestMethod)requestMethod &#123;return YTKRequestMethodPOST;&#125;- (BOOL)contentIsArray &#123;return false;&#125;","categories":[{"name":"移动端","slug":"移动端","permalink":"https://www.cqzhong.cn/categories/移动端/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.cqzhong.cn/tags/iOS/"},{"name":"YTKNetwork","slug":"YTKNetwork","permalink":"https://www.cqzhong.cn/tags/YTKNetwork/"}]},{"title":"xib设置边框属性(颜色，宽度，圆角)","slug":"xib设置边框属性(颜色，宽度，圆角)","date":"2018-09-07T14:36:56.000Z","updated":"2020-11-03T10:21:35.480Z","comments":true,"path":"2018/09/07/xib设置边框属性(颜色，宽度，圆角)/","link":"","permalink":"https://www.cqzhong.cn/2018/09/07/xib设置边框属性(颜色，宽度，圆角)/","excerpt":"storyboard 或者 Xib 给 View 设置边框属性(颜色，宽度，圆角)","text":"storyboard 或者 Xib 给 View 设置边框属性(颜色，宽度，圆角) 写一个 CALayer 类别，用于给 xib 设置边框颜色 1234567891011121314151617181920212223#import &lt;QuartzCore/QuartzCore.h&gt; #import &lt;UIKit/UIKit.h&gt; @interface CALayer (JKBorderColor)@property(nonatomic, assign) UIColor \\*jk_borderColor; @end#import \"CALayer+JKBorderColor.h\"@implementation CALayer (JKBorderColor)-(void)setJk_borderColor:(UIColor \\*)jk_borderColor&#123; self.borderColor = jk_borderColor.CGColor; &#125;- (UIColor\\*)jk_borderColor &#123; return [UIColor colorWithCGColor:self.borderColor]; &#125;@end","categories":[{"name":"移动端","slug":"移动端","permalink":"https://www.cqzhong.cn/categories/移动端/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.cqzhong.cn/tags/iOS/"},{"name":"Xcode","slug":"Xcode","permalink":"https://www.cqzhong.cn/tags/Xcode/"},{"name":"xib","slug":"xib","permalink":"https://www.cqzhong.cn/tags/xib/"}]},{"title":"iOS 修改UserAgent","slug":"iOS 修改UserAgent","date":"2018-09-04T03:55:05.000Z","updated":"2020-11-03T10:21:35.505Z","comments":true,"path":"2018/09/04/iOS 修改UserAgent/","link":"","permalink":"https://www.cqzhong.cn/2018/09/04/iOS 修改UserAgent/","excerpt":"首部字段 User-Agent 会将创建请求的浏览器信息和用户代理等信息传达给服务器。 由网络爬虫发起请求时，有可能会在字段哪添加爬虫作者等电子邮箱地址。此外，如果请求经过代理，那么中间也很可能被添加上代理服务器名称","text":"首部字段 User-Agent 会将创建请求的浏览器信息和用户代理等信息传达给服务器。 由网络爬虫发起请求时，有可能会在字段哪添加爬虫作者等电子邮箱地址。此外，如果请求经过代理，那么中间也很可能被添加上代理服务器名称 WKWebView 设置 navigator.userAgent 123456789101112131415161718- (void)setupWebViewUserAgent &#123; @weakify(self); [_webView evaluateJavaScript:@\"navigator.userAgent\" completionHandler:^(id result, NSError *error) &#123; @strongify(self); NSString * userAgent= [NSString stringWithFormat:@\"%@\", result]; if (![userAgent qmui_includesString:kWebViewUserAgent]) &#123; NSString *newAgent = [NSString stringWithFormat:@\"%@%@\",userAgent, kWebViewUserAgent]; NSDictionary *dictionary = @&#123;@\"UserAgent\": newAgent&#125;; [[NSUserDefaults standardUserDefaults] registerDefaults:dictionary]; [[NSUserDefaults standardUserDefaults] synchronize]; [self.webView setCustomUserAgent:newAgent]; &#125; &#125;];&#125; UIWebView 设置 navigator.userAgent 123456789101112//MARK: 配置浏览器信息- (void)configNavigatorUserAgent &#123; NSString *userAgent = [[UIWebView new] stringByEvaluatingJavaScriptFromString:@\"navigator.userAgent\"]; if (![userAgent qmui_includesString:kWebViewUserAgent]) &#123; userAgent = [NSString stringWithFormat:@\"%@%@\",userAgent, kWebViewUserAgent]; NSDictionary *dictionary = @&#123;@\"UserAgent\": userAgent&#125;; [[NSUserDefaults standardUserDefaults] registerDefaults:dictionary]; [[NSUserDefaults standardUserDefaults] synchronize]; &#125;&#125;","categories":[{"name":"移动端","slug":"移动端","permalink":"https://www.cqzhong.cn/categories/移动端/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.cqzhong.cn/tags/iOS/"},{"name":"WebView","slug":"WebView","permalink":"https://www.cqzhong.cn/tags/WebView/"}]},{"title":"WKWebView(UIWebView)的携带cookie","slug":"WKWebView(UIWebView)的携带cookie","date":"2018-09-04T03:55:05.000Z","updated":"2020-11-03T10:21:35.946Z","comments":true,"path":"2018/09/04/WKWebView(UIWebView)的携带cookie/","link":"","permalink":"https://www.cqzhong.cn/2018/09/04/WKWebView(UIWebView)的携带cookie/","excerpt":"JS 携带 cookie 的形式 1234567891011121314 WKUserScript * cookieScript = [[WKUserScript alloc] initWithSource:self.documentCookie injectionTime:WKUserScriptInjectionTimeAtDocumentStart forMainFrameOnly:false]; [self.webView.configuration.userContentController addUserScript:cookieScript]; [webView evaluateJavaScript:self.documentCookie completionHandler:^(id result, NSError *error) &#123; &#125;];- (NSString *)cookieHeaderField &#123; return CDSQLITE_MANAGER.isLogin ? [NSString stringWithFormat:@\"%@=%@;%@=%@;\",CDRequestKeyDeviceID, [self uuid], CDRequestKeyToken, CDSQLITE_MANAGER.token] : @\"\";&#125;- (NSString *)uuid &#123; return [RMUUid getUUid];&#125;- (NSString *)documentCookie &#123; //max-age=60*60';domain=m-test.changguwen.com return [NSString stringWithFormat:@\"document.cookie='%@path=/';\",[self cookieHeaderField]];&#125;","text":"JS 携带 cookie 的形式 1234567891011121314 WKUserScript * cookieScript = [[WKUserScript alloc] initWithSource:self.documentCookie injectionTime:WKUserScriptInjectionTimeAtDocumentStart forMainFrameOnly:false]; [self.webView.configuration.userContentController addUserScript:cookieScript]; [webView evaluateJavaScript:self.documentCookie completionHandler:^(id result, NSError *error) &#123; &#125;];- (NSString *)cookieHeaderField &#123; return CDSQLITE_MANAGER.isLogin ? [NSString stringWithFormat:@\"%@=%@;%@=%@;\",CDRequestKeyDeviceID, [self uuid], CDRequestKeyToken, CDSQLITE_MANAGER.token] : @\"\";&#125;- (NSString *)uuid &#123; return [RMUUid getUUid];&#125;- (NSString *)documentCookie &#123; //max-age=60*60';domain=m-test.changguwen.com return [NSString stringWithFormat:@\"document.cookie='%@path=/';\",[self cookieHeaderField]];&#125; 2、PHP 携带 cookie 的形式 123456NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:self.urlString] cachePolicy:NSURLRequestReturnCacheDataElseLoad timeoutInterval:60];// NSDictionary *requestHeader = [NSHTTPCookie requestHeaderFieldsWithCookies:[NSHTTPCookieStorage sharedHTTPCookieStorage].cookies];// [request setAllHTTPHeaderFields:requestHeader];[request addValue:[self cookieHeaderField] forHTTPHeaderField:@\"Cookie\"]; 3、wk 插入 cookie 1234567891011121314151617181920212223242526272829303132333435- (void)setupHTTPCookieStorage &#123; NSString *host = [NSURL URLWithString:CDSQLITE_MANAGER.baseH5url].host; NSMutableDictionary *deviceCookieProperties = [NSMutableDictionary dictionary]; [deviceCookieProperties setObject:CDRequestKeyDeviceID forKey:NSHTTPCookieName]; [deviceCookieProperties setObject:[RMUUid getUUid] forKey:NSHTTPCookieValue]; [deviceCookieProperties setObject:host forKey:NSHTTPCookieDomain]; [deviceCookieProperties setObject:@\"/\" forKey:NSHTTPCookiePath]; [deviceCookieProperties setObject:[[NSDate date] dateByAddingTimeInterval:2592000] forKey:NSHTTPCookieExpires];// [[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:[NSHTTPCookie cookieWithProperties:deviceCookieProperties]]; NSMutableDictionary *tokenCookieProperties = [NSMutableDictionary dictionary]; [tokenCookieProperties setObject:CDRequestKeyToken forKey:NSHTTPCookieName]; [tokenCookieProperties setValue:CDSQLITE_MANAGER.token forKey:NSHTTPCookieValue]; [tokenCookieProperties setObject:host forKey:NSHTTPCookieDomain]; [tokenCookieProperties setObject:@\"/\" forKey:NSHTTPCookiePath]; [tokenCookieProperties setObject:[[NSDate date] dateByAddingTimeInterval:2592000] forKey:NSHTTPCookieExpires];// [[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:[NSHTTPCookie cookieWithProperties:tokenCookieProperties]]; if (@available(iOS 11.0, *)) &#123; WKHTTPCookieStore *cookieStore = self.configuration.websiteDataStore.httpCookieStore; [cookieStore setCookie:[NSHTTPCookie cookieWithProperties:deviceCookieProperties] completionHandler:^&#123; &#125;]; [cookieStore setCookie:[NSHTTPCookie cookieWithProperties:tokenCookieProperties] completionHandler:^&#123; &#125;]; &#125; else &#123;// [[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:[NSHTTPCookie cookieWithProperties:deviceCookieProperties]];// [[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:[NSHTTPCookie cookieWithProperties:tokenCookieProperties]]; &#125;&#125; 设置 cookies 存储 123456789101112131415161718192021222324252627282930313233343536373839+ (void)resetHTTPCookieStorage &#123; @synchronized (self) &#123; //清理NSHTTPCookieStorage存储的cookies NSHTTPCookieStorage *cookieJar = [NSHTTPCookieStorage sharedHTTPCookieStorage]; NSArray *cookieArray = [NSArray arrayWithArray:[cookieJar cookies]]; for (id obj in cookieArray) &#123; [cookieJar deleteCookie:obj]; &#125; if (!CDSQLITE_MANAGER.isLogin) return; CDDLog(@\"[RMUUid getUUid]: %@\", [RMUUid getUUid]); NSString *host = [NSURL URLWithString:CDSQLITE_MANAGER.baseH5url].host; NSMutableDictionary *deviceCookieProperties = [NSMutableDictionary dictionary]; [deviceCookieProperties setObject:CDRequestKeyDeviceID forKey:NSHTTPCookieName]; [deviceCookieProperties setObject:[RMUUid getUUid] forKey:NSHTTPCookieValue]; [deviceCookieProperties setObject:host forKey:NSHTTPCookieDomain]; [deviceCookieProperties setObject:@\"/\" forKey:NSHTTPCookiePath]; [deviceCookieProperties setObject:[[NSDate date] dateByAddingTimeInterval:2592000] forKey:NSHTTPCookieExpires]; [[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:[NSHTTPCookie cookieWithProperties:deviceCookieProperties]]; NSMutableDictionary *tokenCookieProperties = [NSMutableDictionary dictionary]; [tokenCookieProperties setObject:CDRequestKeyToken forKey:NSHTTPCookieName]; [tokenCookieProperties setValue:CDSQLITE_MANAGER.token forKey:NSHTTPCookieValue]; [tokenCookieProperties setObject:host forKey:NSHTTPCookieDomain]; [tokenCookieProperties setObject:@\"/\" forKey:NSHTTPCookiePath]; [tokenCookieProperties setObject:[[NSDate date] dateByAddingTimeInterval:2592000] forKey:NSHTTPCookieExpires]; [[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:[NSHTTPCookie cookieWithProperties:tokenCookieProperties]]; &#125;&#125; 查询响应后的 cookie 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#pragma mark - WKNavigationDelegate// 在收到响应后，决定是否跳转- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler&#123; if (@available(iOS 12.0, *)) &#123;//iOS11也有这种获取方式，但是我使用的时候iOS11系统可以在response里面直接获取到，只有iOS12获取不到 @weakify(self); WKHTTPCookieStore *cookieStore = webView.configuration.websiteDataStore.httpCookieStore; [cookieStore getAllCookies:^(NSArray* cookies) &#123; @strongify(self); [self queryCookies:cookies]; &#125;]; &#125;else &#123; NSHTTPURLResponse *response = (NSHTTPURLResponse *)navigationResponse.response; NSArray *cookies =[NSHTTPCookie cookiesWithResponseHeaderFields:[response allHeaderFields] forURL:response.URL]; [self queryCookies:cookies]; &#125; //允许跳转,这句是必须加上的，不然会异常 decisionHandler(WKNavigationResponsePolicyAllow); //不允许跳转 //decisionHandler(WKNavigationResponsePolicyCancel);&#125;-(void)queryCookies:(NSArray *)cookies &#123;// if (cookies.count == 0) &#123;//// [WKWebView resetHTTPCookieStorage];// return;// &#125;// BOOL isHasDevice = false; BOOL isHasToken = false; for (NSHTTPCookie *cookie in cookies) &#123; CDDLog(@\"name: %@ ; value: %@; count: %ld\", cookie.name, cookie.value, cookies.count); if ([cookie.name isEqualToString:CDRequestKeyDeviceID] &amp;&amp; [cookie.value isEqualToString:[self uuid]]) &#123; isHasDevice = true; &#125; if ([cookie.name isEqualToString:CDRequestKeyToken]) &#123; isHasToken = true; &#125; &#125;//// if (!isHasDevice || !isHasToken) [WKWebView resetHTTPCookieStorage];&#125; UIWebView 的 cookies 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#import \"CDFoundViewController.h\"@interface CDFoundViewController () &lt;UIWebViewDelegate&gt;@property (nonatomic, strong) UIWebView *webView;@end@implementation CDFoundViewController- (void)viewDidLoad &#123; [super viewDidLoad]; [self setCookie]; [self.view addSubview:self.webView];// NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:[NSURL URLWithString:@\"https://m-test.changguwen.com/msgt-ceping\"]]; NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@\"https://m-test.changguwen.com/active?t=4l7MXdyJjgNn2V7XdZb5Pq3KwLYWmQ1E\"] cachePolicy:NSURLRequestReturnCacheDataElseLoad timeoutInterval:60];// NSArray *cookies = [NSHTTPCookieStorage sharedHTTPCookieStorage].cookies;//// NSDictionary *requestHeader = [NSHTTPCookie requestHeaderFieldsWithCookies:cookies];// [request setAllHTTPHeaderFields:requestHeader]; [request addValue:@\"deviceid=db7ed8b2a0e77f1c14dad174315958e8; token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1aWQiOiJYS3h5WU44TEQ5cmRCajVtWVJaNW0xYlI0M1pHN1dQcCIsImV4cCI6MTU2MzQxNTc5NCwiaXNzIjoiZGI3ZWQ4YjJhMGU3N2YxYzE0ZGFkMTc0MzE1OTU4ZTgifQ.0FEOpxg9mVl99L_jesQ684qo7F_nk5BNJ2ksWdaySqY\" forHTTPHeaderField:@\"Cookie\"]; [_webView loadRequest:request];&#125;- (void)setCookie&#123; NSMutableArray *arr = [NSMutableArray array]; NSMutableDictionary *cookieProperties1 = [NSMutableDictionary dictionary]; [cookieProperties1 setObject:@\"deviceid\" forKey:NSHTTPCookieName]; [cookieProperties1 setObject:@\"db7ed8b2a0e77f1c14dad174315958e8\" forKey:NSHTTPCookieValue]; [cookieProperties1 setObject:@\"m-test.changguwen.com\" forKey:NSHTTPCookieDomain]; [cookieProperties1 setObject:@\"/\" forKey:NSHTTPCookiePath];// [cookieProperties setObject:@\"0\" forKey:NSHTTPCookieVersion];// [cookieProperties1 setObject:[[NSDate date] dateByAddingTimeInterval:2629743] forKey:NSHTTPCookieExpires]; NSHTTPCookie *cookieuser1 = [NSHTTPCookie cookieWithProperties:cookieProperties1]; [arr addObject:cookieuser1]; NSMutableDictionary *cookieProperties2 = [NSMutableDictionary dictionary]; [cookieProperties2 setObject:@\"token\" forKey:NSHTTPCookieName]; [cookieProperties2 setObject:@\"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1aWQiOiJYS3h5WU44TEQ5cmRCajVtWVJaNW0xYlI0M1pHN1dQcCIsImV4cCI6MTU2MzQxNTc5NCwiaXNzIjoiZGI3ZWQ4YjJhMGU3N2YxYzE0ZGFkMTc0MzE1OTU4ZTgifQ.0FEOpxg9mVl99L_jesQ684qo7F_nk5BNJ2ksWdaySqY\" forKey:NSHTTPCookieValue]; [cookieProperties2 setObject:@\"m-test.changguwen.com\" forKey:NSHTTPCookieDomain]; [cookieProperties2 setObject:@\"/\" forKey:NSHTTPCookiePath]; // [cookieProperties setObject:@\"0\" forKey:NSHTTPCookieVersion];// [cookieProperties2 setObject:[[NSDate date] dateByAddingTimeInterval:2629743] forKey:NSHTTPCookieExpires]; NSHTTPCookie *cookieuser2 = [NSHTTPCookie cookieWithProperties:cookieProperties2]; [arr addObject:cookieuser2]; [[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookies:arr forURL:[NSURL URLWithString:@\"https://m-test.changguwen.com/active?t=4l7MXdyJjgNn2V7XdZb5Pq3KwLYWmQ1E\"] mainDocumentURL:nil];&#125;//MARK: UIWebViewDelegate- (void)webViewDidStartLoad:(UIWebView *)webView &#123;&#125;- (void)webViewDidFinishLoad:(UIWebView *)webView &#123;&#125;- (void)webView:(UIWebView *)webView didFailLoadWithError:(NSError *)error &#123;&#125;- (UIWebView *)webView &#123; if (!_webView) &#123; _webView = [[UIWebView alloc] initWithFrame:CGRectMake(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT)]; _webView.backgroundColor = [UIColor whiteColor]; _webView.delegate = self; _webView.allowsLinkPreview = true; &#125; return _webView;&#125;/*#pragma mark - Navigation// In a storyboard-based application, you will often want to do a little preparation before navigation- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender &#123; // Get the new view controller using [segue destinationViewController]. // Pass the selected object to the new view controller.&#125;*/@end","categories":[{"name":"移动端","slug":"移动端","permalink":"https://www.cqzhong.cn/categories/移动端/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.cqzhong.cn/tags/iOS/"},{"name":"WebView","slug":"WebView","permalink":"https://www.cqzhong.cn/tags/WebView/"}]},{"title":"react native 部分使用总结","slug":"react native 部分使用总结","date":"2018-08-14T04:58:06.000Z","updated":"2020-11-03T10:21:35.555Z","comments":true,"path":"2018/08/14/react native 部分使用总结/","link":"","permalink":"https://www.cqzhong.cn/2018/08/14/react native 部分使用总结/","excerpt":"混合开发 配置好 React Native 依赖和项目结构。 1、事件绑定 传参","text":"混合开发 配置好 React Native 依赖和项目结构。 1、事件绑定 传参 1234567891011121314151617181920212223242526272829303132正确 不被立即执行 &lt;Text &lt;Text style=&#123;styles.text&#125; onPress=&#123;this.press0&#125; &gt;&#123;this.state.data0&#125;&lt;/Text&gt;--------------------- &lt;Text style=&#123;styles.text&#125; onPress=&#123;() =&gt; this.press1()&#125; &gt;&#123;this.state.data1&#125;&lt;/Text&gt;--------------------- &lt;Text style=&#123;styles.text&#125; onPress=&#123;this.press2.bind(this)&#125; &gt;&#123;this.state.data2&#125;&lt;/Text&gt;--------------------- &lt;Text style=&#123;styles.text&#125; onPress=&#123;this.press3.bind(this, 2222)&#125; &gt;&#123;this.state.data3&#125;&lt;/Text&gt; &lt;Text style=&#123;styles.text&#125; onPress=&#123;()=&gt;this.press4(2222)&#125; &gt;&#123;this.state.data4&#125;&lt;/Text&gt;--------------------- 2、原生跳转至 RN 123456789101112131415161718192021222324252627#import &lt;React/RCTRootView.h&gt;- (IBAction)highScoreButtonPressed:(id)sender &#123; NSLog(@\"High Score Button Pressed\"); NSURL *jsCodeLocation = [NSURL URLWithString:@\"http://localhost:8081/index.bundle?platform=ios\"]; RCTRootView *rootView = [[RCTRootView alloc] initWithBundleURL: jsCodeLocation moduleName: @\"RNHighScores\" initialProperties: @&#123; @\"scores\" : @[ @&#123; @\"name\" : @\"Alex\", @\"value\": @\"42\" &#125;, @&#123; @\"name\" : @\"Joel\", @\"value\": @\"10\" &#125; ] &#125; launchOptions: nil]; UIViewController *vc = [[UIViewController alloc] init]; vc.view = rootView; [self presentViewController:vc animated:YES completion:nil];&#125; // 3、指定平台 12345678910111213141516171819202122232425row: &#123; flex: 1, flexDirection: 'row', justifyContent: \"center\", alignItems: \"center\", backgroundColor: '#FFFFFF', width: 686, height: 264, marginLeft: 16, marginRight: 16, marginTop: 32, ...Platform.select(&#123; ios: &#123; shadowColor: '#000000', shadowOffset: &#123;h: 0, w: 0&#125;, shadowRadius: 5, shadowOpacity: 0.1, &#125;, android: &#123; &#125; &#125;)&#125;, // 4、判断控件 显示和隐藏 1234567891011121314151617181920212223242526272829303132333435 // 渲染购买数据 renderPurchased(&#123; item &#125;) &#123; if (item.class_name) &#123; return ( &lt;View style=&#123;styles.section&#125;&gt; &lt;Text style=&#123;styles.section_text&#125;&gt;&#123;item.class_name&#125;&lt;/Text&gt; &lt;/View&gt; ) &#125; return ( &lt;View style=&#123;styles.row&#125;&gt; &lt;View style=&#123;styles.corner&#125;&gt; &lt;Image source=&#123;&#123; uri: item.album_small_cover&#125;&#125; style=&#123;styles.corner_img&#125;/&gt; &lt;View style=&#123;styles.corner_right&#125;&gt; &lt;Text style=&#123;styles.corner_right_title&#125;&gt;&#123;item.album_title&#125;&lt;/Text&gt; &lt;Text style=&#123;styles.corner_right_date&#125;&gt;&#123;item.goods_time&#125;&lt;/Text&gt; &#123;item.studied_count &gt;= 0 ? hiddenProgress(item) : null&#125; &lt;/View&gt; &lt;/View&gt; &lt;/View&gt; ); &#125; // 判断是否显示进度条var hiddenProgress = (item) =&gt; &#123; return ( &lt;Text style=&#123;styles.corner_right_progress&#125; hidden=\"\"&gt;&#123;`学习进度 $&#123;item.studied_count&#125; / $&#123;item.album_total_num&#125;`&#125;&lt;/Text&gt; )&#125; // 5、属性计算 12345678910111213141516171819202122232425262728293031323334// 判断是否显示进度条var hiddenProgress = (item) =&gt; &#123; if (item.studied_count &gt;= 0) &#123; return ( &lt;View style=&#123;styles.corner_right_bottom_view&#125;&gt; &lt;Text style=&#123;[styles.corner_right_date, styles.corner_right_progress]&#125; hidden=\"\" &gt;&#123;`学习进度 $&#123;item.studied_count&#125; / $&#123;item.album_total_num&#125;`&#125;&lt;/Text&gt; &lt;View style=&#123;styles.corner_right_bottom_progressView&#125;&gt; &lt;View style=&#123;[ styles.corner_right_top_progress, &#123; width: calculateProgress( item.studied_count, item.album_total_num ), &#125;, ]&#125; &gt;&lt;/View&gt; &lt;/View&gt; &lt;/View&gt; ); &#125; return null;&#125;;// 计算进度条valuevar calculateProgress = (count, total) =&gt; &#123; let num = (count / total) * 100; return `$&#123;num.toString()&#125;%`;&#125;; // 6、引入图片 123456789101112131415&lt;Image source=&#123;require('./img/check.png')&#125; /&gt;// 引入asset内图片 不带后缀，只写图片名&lt;Image source=&#123;&#123;uri: 'app_icon'&#125;&#125; style=&#123;&#123;width: 40, height: 40&#125;&#125; /&gt;// 引入 @2x @3x 内的图片├── button.js└── img ├── check.png ├── check@2x.png └── check@3x.png&lt;Image source=&#123;require('./img/check.png')&#125; /&gt; // 7、指定读取缓存 1234567&lt;Image source=&#123;&#123; uri: \"https://facebook.github.io/react/logo-og.png\", cache: \"only-if-cached\", &#125;&#125; style=&#123;&#123; width: 400, height: 400 &#125;&#125;/&gt; // 8、设置图片变量 1234var icon = this.props.active ? require(\"./my-icon-active.png\") : require(\"./my-icon-inactive.png\");&lt;Image source=&#123;icon&#125; /&gt;; // 9、使用 base64 的图片 123456789101112// 请记得指定宽高！&lt;Image style=&#123;&#123; width: 51, height: 51, resizeMode: \"contain\", &#125;&#125; source=&#123;&#123; uri: \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADMAAAAzCAYAAAA6oTAqAAAAEXRFWHRTb2Z0d2FyZQBwbmdjcnVzaEB1SfMAAABQSURBVGje7dSxCQBACARB+2/ab8BEeQNhFi6WSYzYLYudDQYGBgYGBgYGBgYGBgYGBgZmcvDqYGBgmhivGQYGBgYGBgYGBgYGBgYGBgbmQw+P/eMrC5UTVAAAAABJRU5ErkJggg==\", &#125;&#125;/&gt; 10 运行 1234567// 查看模拟器列表xcrun simctl list devices// 选择模拟器运行react-native run-ios --simulator \"iPhone 4s\" 11、原生传值 加载 rn 1234567891011121314151617181920212223242526272829303132- (void)viewDidLoad&#123; [...] RCTRootView *rootView = [[RCTRootView alloc] initWithBridge:bridge moduleName:appName initialProperties:props]; rootView.frame = CGRectMake(0, 0, self.view.width, 200); [self.view addSubview:rootView];&#125;- (instancetype)initWithFrame:(CGRect)frame&#123; [...] _rootView = [[RCTRootView alloc] initWithBridge:bridge moduleName:@\"FlexibilityExampleApp\" initialProperties:@&#123;&#125;]; _rootView.delegate = self; _rootView.sizeFlexibility = RCTRootViewSizeFlexibilityHeight; _rootView.frame = CGRectMake(0, 0, self.frame.size.width, 0);&#125;#pragma mark - RCTRootViewDelegate- (void)rootViewDidChangeIntrinsicSize:(RCTRootView *)rootView&#123; CGRect newFrame = rootView.frame; newFrame.size = rootView.intrinsicContentSize; rootView.frame = newFrame;&#125; 12、TouchableOpacity 点击事件 12345&lt;TouchableOpacity onPress=&#123;() =&gt; &#123; Alert.alert(`$&#123;item.album_title&#125;`); &#125;&#125;&gt;&lt;/TouchableOpacity&gt;","categories":[{"name":"移动端","slug":"移动端","permalink":"https://www.cqzhong.cn/categories/移动端/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.cqzhong.cn/tags/iOS/"},{"name":"react native","slug":"react-native","permalink":"https://www.cqzhong.cn/tags/react-native/"}]},{"title":"ifdef 宏定义","slug":"ifdef 宏定义","date":"2018-08-10T03:55:05.000Z","updated":"2020-11-03T10:21:35.684Z","comments":true,"path":"2018/08/10/ifdef 宏定义/","link":"","permalink":"https://www.cqzhong.cn/2018/08/10/ifdef 宏定义/","excerpt":"1234567#ifdef LUMBERJACK#else /* LUMBERJACK */#endif /* LUMBERJACK */","text":"1234567#ifdef LUMBERJACK#else /* LUMBERJACK */#endif /* LUMBERJACK */ 1234567891011121314151617181920212223#ifdef CDTEST NSLog(@\"CDTEST\");#elif ADHOC NSLog(@\"ADHOC\");#elif DEBUG NSLog(@\"DEBUG\");#else NSLog(@\"release\");#endif#if defined(DEBUG) || defined(CDTEST) NSLog(@\"DEBUG, CDTEST\");#else NSLog(@\"release\");#endif 12345678910111213141516#if (APP_Type == 0)// Debug#define a @\"000000\"#elif (APP_Type == 1)// Release#define a @\"111111\"#elif (APP_Type == 2)// TestA#define a @\"222222\"#elif (APP_Type == 3)// TestB![Uploading CA914A5C-31B3-48FB-A5F1-71CCB3B37B80_595336.png . . .]#define a @\"333333\" 123456#if defined (__i386__) || defined (__x86_64__) //模拟器下执行#else //真机下执行#endif 123456789#ifdef CDTHEME_COLOR NSLog(@\"\\n\\n\\n\\n CDTHEME_COLOR 被宏定义过 \\n\\n\\n\\n\\n\\n\\n\");#else NSLog(@\"\\n\\n\\n\\n CDTHEME_COLOR 未被宏定义过 \\n\\n\\n\\n\\n\\n\\n\");#endif","categories":[{"name":"移动端","slug":"移动端","permalink":"https://www.cqzhong.cn/categories/移动端/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.cqzhong.cn/tags/iOS/"},{"name":"宏定义","slug":"宏定义","permalink":"https://www.cqzhong.cn/tags/宏定义/"}]},{"title":"iOS团队协作之Xcode模版","slug":"iOS团队协作之Xcode模版","date":"2018-08-06T00:56:59.000Z","updated":"2020-11-03T10:21:35.501Z","comments":true,"path":"2018/08/06/iOS团队协作之Xcode模版/","link":"","permalink":"https://www.cqzhong.cn/2018/08/06/iOS团队协作之Xcode模版/","excerpt":"当我们在 Xcode 里新建文件时，Xcode 默认提供了多种文件模板，并且不同的 class，模板里默认提供的内容也不一样。","text":"当我们在 Xcode 里新建文件时，Xcode 默认提供了多种文件模板，并且不同的 class，模板里默认提供的内容也不一样。 为什么要自定义 Xcode 模版 在团队开发过程中， 我们要遵守一定的代码规范，例如控制器中需要用#pragma mark -来分割各个方法 12345678910111213141516#pragma mark - Life Cycle Methods#pragma mark - Intial Methods#pragma mark - Network Methods#pragma mark - Target Methods#pragma mark - Public Methods#pragma mark - Private Method#pragma mark - External Delegate#pragma mark - Setter Getter Methods 但是如果每次创建类，都要一个一个的去添加这些代码，就会浪费很多时间。所以这个时候我们就要用到自定义 Xcode 模版。使用 Xcode 模版对于一个团队而言，能加快不少效率。 自定义 Xcode 模版 打开 Xcode 模板存放路径： 1open /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/Library/Xcode/Templates/File\\ Templates/Source 参考 Cocoa Touch Class.xctemplate 内的 Xcode 模版 创建文件夹：CD Class.xctemplate， 仿照 Cocoa Touch Class.xctemplate 内的 TemplateInfo 创建 TemplateInfo.plist 文件，理解 plist 文件字段的含义，尤其注意 options 字段， 创建有 xib 和没有 xib 的基类。 模版是利用几个系统的预处理宏定义，包括 12345678910111213___FILEBASENAMEASIDENTIFIER___ ：类名___VARIABLE_cocoaTouchSubclass___：基类名___FILENAME___：文件名___PROJECTNAME___：工程名___FULLUSERNAME___：用户名___DATE___：当前日期___COPYRIGHT___：版权声明 把自定义好的 Xcode 模版 CD Class.xctemplate，放到 Xcode 模版路径下，无需重启 Xcode，直接新建文件，即可看到“CD Class”的模板可供选择，如下图","categories":[{"name":"移动端","slug":"移动端","permalink":"https://www.cqzhong.cn/categories/移动端/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.cqzhong.cn/tags/iOS/"},{"name":"Xcode","slug":"Xcode","permalink":"https://www.cqzhong.cn/tags/Xcode/"}]},{"title":"Mac重装系统","slug":"Mac重装系统","date":"2018-07-30T03:12:00.000Z","updated":"2020-11-03T10:21:35.429Z","comments":true,"path":"2018/07/30/Mac重装系统/","link":"","permalink":"https://www.cqzhong.cn/2018/07/30/Mac重装系统/","excerpt":"恢复出厂设置 第一种 开机 commond + R，进入 recover 模式。 选择磁盘工具 显示所有设备 抹掉硬盘、格式选择 (1):Mac OS 扩展（日志式）。 (2): Mac OS Extend(Journaled)。 完成 退出磁盘工具。 重新安装系统。","text":"恢复出厂设置 第一种 开机 commond + R，进入 recover 模式。 选择磁盘工具 显示所有设备 抹掉硬盘、格式选择 (1):Mac OS 扩展（日志式）。 (2): Mac OS Extend(Journaled)。 完成 退出磁盘工具。 重新安装系统。 第二种（磁盘为空时候进入 recover 模式） option + command + R 开机 直到出现小地球松手 按照步骤操作。 忘记开机密码 开机 Command+S，出现命令行提示符后输入如下三个命令，每一行是一个命令，输入完一个命令以后都记得按回车。 123456/sbin/mount空格-uawrm空格/var/db/.AppleSetupDonereboot 2.重启后即可像刚安装完系统一样选择国家、语言，设置用户名和密码了！ 修复磁盘错误 同时按 Command+S+电源键，直至出现文字界面才可松开），机器自检并出现提示：是进入磁盘修复还是重新启动机器，毫不犹豫地选择磁盘修复，即在系统提示符下输入： /sbin/fsck -fy 然后按回车键，系统进行磁盘检测，一大串英文提示之后（大体意思有：磁盘错误、文件夹出现错误、文件目录有错误等），几分钟后系统告知成功修复，此时输入：REBOOT 后按回车键，系统重新启动并正常开机进入 FINDER。 未能创建用于 APFS 安装的预启动宗卷 打开终端运行：diskutil cs delete 开机键盘，Command+R+Option 等待小地球转完重启。 重新格式化磁盘，又可以选择格式了。 选取 Mac OS 扩展（日志式），选取“GUID 分区图”。","categories":[{"name":"其它","slug":"其它","permalink":"https://www.cqzhong.cn/categories/其它/"}],"tags":[{"name":"Mac","slug":"Mac","permalink":"https://www.cqzhong.cn/tags/Mac/"}]},{"title":"shell片段","slug":"shell片段","date":"2018-07-29T11:26:04.000Z","updated":"2020-11-03T10:21:35.742Z","comments":true,"path":"2018/07/29/shell片段/","link":"","permalink":"https://www.cqzhong.cn/2018/07/29/shell片段/","excerpt":"关键代码：去除 文件中的多行注释和 单行注释,空格行，并生成文件 12345678sed '/^[ \\t]*\\/\\*/,/.*\\*\\//d' $&#123;localize_path&#125;|sed '/^[ \\t]*\\/\\//d'|\\sed '/^[[:space:]]*$/d' &gt; $&#123;tmp_file&#125;//因为使用了管道的问题，变量外的值接收不到外面的值。cat $&#123;tmp_file&#125; | while read line;doecho $&#123;line&#125;done","text":"关键代码：去除 文件中的多行注释和 单行注释,空格行，并生成文件 12345678sed '/^[ \\t]*\\/\\*/,/.*\\*\\//d' $&#123;localize_path&#125;|sed '/^[ \\t]*\\/\\//d'|\\sed '/^[[:space:]]*$/d' &gt; $&#123;tmp_file&#125;//因为使用了管道的问题，变量外的值接收不到外面的值。cat $&#123;tmp_file&#125; | while read line;doecho $&#123;line&#125;done 写入多行文件 123456789cat &gt; $&#123;localize_file_path_h&#125; &lt;&lt;EOL//// This is a generated file, do not edit!//#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UIKit.h&gt;// 工程国际化@interface NSString ($&#123;localize_name&#125;)EOL 自动打包 12345678910111213141516171819202122232425262728293031#!/bin/sh#!/bin/bash# 跳转到脚本所在目录pushd `dirname $0` &gt; /dev/null#另一种写法：cd $(dirname \"$0\")；``等同于$()work_path=`pwd`popd &gt; /dev/nulldeclare -a array_environmentsarray_environments=('Debug' 'Test' 'AdHoc' 'Release')read -p $'请输入打包环境：\\n1.开发环境 \\n2.测试环境\\n3.预发布环境\\n4.发布环境\\n' indexecho \"你选择的打包环境是：$&#123;index&#125;\"let arr_len=\"$&#123;#array_environments[@]&#125;\"if [ $&#123;index&#125; -gt $&#123;arr_len&#125; ] || [ $&#123;index&#125; -lt 1 ]; thenindex=1fiipa_environment=$&#123;array_environments[index-1]&#125;echo $&#123;ipa_environment&#125;# cd $&#123;work_path&#125;/CDPlaceholder_iphonecd /Users/caoqingzhong/Desktop/GitLab/FT_iPhone/FT_iPhonefastlane $&#123;ipa_environment&#125; 逐行读取文件内容，并允许外部访问变量 123456789101112131415161718192021222324252627282930# 读取文件内容index=0unset TOTAL_STRINGS_KEYSunset TOTAL_STRINGS_VALUESwhile read line;do#命令行内容array=($&#123;line//=/ &#125;)if [ \"$&#123;#array[@]&#125;\" -eq 2 ]; thenkey=$&#123;array[0]&#125;value=$&#123;array[1]&#125;let lenKey=\"$&#123;#key&#125;\"-2let lenValue=\"$&#123;#value&#125;\"-3key=$&#123;key:1 :lenKey&#125;value=$&#123;value:1 : lenValue&#125;TOTAL_STRINGS_KEYS[index]=$&#123;key&#125;TOTAL_STRINGS_VALUES[index]=$&#123;value&#125;let index++fidone &lt; $&#123;tmp_file&#125;reorganizationFile localize_name TOTAL_STRINGS_KEYS TOTAL_STRINGS_VALUES 判断数字相等 12345if [ $index -eq 3 ]; thenecho \"ADHOC\"elseecho \"打包完成，下载地址是：https://www.pgyer.com/gmcT\"fi","categories":[{"name":"其它","slug":"其它","permalink":"https://www.cqzhong.cn/categories/其它/"}],"tags":[{"name":"shell","slug":"shell","permalink":"https://www.cqzhong.cn/tags/shell/"}]},{"title":"iOS内购总结","slug":"iOS内购总结","date":"2018-07-21T04:58:06.000Z","updated":"2020-11-03T10:21:35.884Z","comments":true,"path":"2018/07/21/iOS内购总结/","link":"","permalink":"https://www.cqzhong.cn/2018/07/21/iOS内购总结/","excerpt":"内购逻辑图","text":"内购逻辑图 1、内购的四种类型 消耗性项目：在支付成功以后，苹果后台就不会再返回该物品的票据信息。 非消耗性项目：支付成功以后，会永久保留该票据信息，每次校验都会返回。 自动续期订阅：支付成功以后，每次都会自动续期，每次订单都是同一个 ID，但标识不同，每次续期成功后返回该 ID 非续期订阅：支付成功以后，在有效期内，每次校验订单信息，都会返回处于有效期内订单信息，有效期过期之后不再返回。 2、发起支付 此处是拿 iTunes 注册的商品 ID 去像苹果服务器支付 3、 苹果服务器返回票据信息给 App 4、App 将返回的票据信息发送给自家服务器 5、App 服务器携带票据信息，向苹果服务器验证。（应放到服务端去进行验证，此处给一个例子 app 端向服务端验证） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394- (void)verifyReceipt:(NSData *)receipt purchaseWithPaymentTransaction:(SKPaymentTransaction *)transaction isTestServer:(BOOL)flag &#123; //交易验证 NSError *error; NSDictionary *requestContents = @&#123; @\"receipt-data\": [receipt base64EncodedStringWithOptions:0] &#125;; NSData *requestData = [NSJSONSerialization dataWithJSONObject:requestContents options:0 error:&amp;error]; //In the test environment, use https://sandbox.itunes.apple.com/verifyReceipt //In the real environment, use https://buy.itunes.apple.com/verifyReceipt NSString *serverString = @\"https://buy.itunes.apple.com/verifyReceipt\"; if (flag) &#123; serverString = @\"https://sandbox.itunes.apple.com/verifyReceipt\"; &#125; NSURL *storeURL = [NSURL URLWithString:serverString]; NSMutableURLRequest *storeRequest = [NSMutableURLRequest requestWithURL:storeURL]; [storeRequest setHTTPMethod:@\"POST\"]; [storeRequest setHTTPBody:requestData]; NSOperationQueue *queue = [[NSOperationQueue alloc] init]; [NSURLConnection sendAsynchronousRequest:storeRequest queue:queue completionHandler:^(NSURLResponse *response, NSData *data, NSError *connectionError) &#123; if (connectionError) &#123; // 无法连接服务器,购买校验失败 [self finished:transaction content:nil withError:connectionError]; &#125; else &#123; NSError *error; NSDictionary *jsonResponse = [NSJSONSerialization JSONObjectWithData:data options:0 error:&amp;error]; if (!jsonResponse) &#123; // 苹果服务器校验数据返回为空校验失败 NSError *recepitErr = [NSError errorWithDomain:PayiTunesErrorDomain code:-1 userInfo:@&#123;NSLocalizedDescriptionKey : ErrorDesForCode(PayiTunesErrorCodeCloudServiceNetworkConnectionFailed)&#125;]; [self finished:transaction content:nil withError:recepitErr]; &#125; NSLogDebug(@\"----验证结果 %@\",jsonResponse); // 先验证正式服务器,如果正式服务器返回21007再去苹果测试服务器验证,沙盒测试环境苹果用的是测试服务器 NSString *status = [NSString stringWithFormat:@\"%@\",jsonResponse[@\"status\"]]; if (status &amp;&amp; [status isEqualToString:@\"21007\"]) &#123; [self verifyReceipt:receipt purchaseWithPaymentTransaction:transaction isTestServer:YES]; &#125; else if(status &amp;&amp; [status isEqualToString:@\"0\"])&#123; [self finished:transaction content:nil withError:nil]; &#125; &#125; &#125;];&#125; 6、返回校验结果，服务器根据不同类型商品去选择对应处理方式 如果应用内都是消耗性物品购买。只需去 inapp 字段的第一个值就可以 如果应用内有第二种和第四种，就需要遍历循环 inapp 的字段处理，判断里面的 original_transaction_id,是否已经被使用过，如果使用过，忽略。如果未使用，标记对应状态，入库存储。 如果有第三种状态，同样遍历循环 inapp 字段，判断 original_transaction_id 和 transaction_id，是否需要增加续订日子(未测试) 7、 如果是网络问题或者是服务器数据问题，导致客户端接收到错误信息，则该笔交易未完成，但是苹果后台的标示是已付款。则 app 再次向苹果服务器发起支付的时候，不会扣费，之后返回对应票据信息。 8、举个例子：放到本地去向苹果服务器做验证 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798992018-07-21 16:29:24.180774+0800 NiuWaJiaoYu[2583:584940] ------------- 请求对应的产品信息--( \"com.NiuWa.niuwaketang_yue\") --------------2018-07-21 16:29:25.295599+0800 NiuWaJiaoYu[2583:584940] --------------收到产品反馈消息---------------------2018-07-21 16:29:25.295966+0800 NiuWaJiaoYu[2583:584940] =====================产品信息==================2018-07-21 16:29:25.296181+0800 NiuWaJiaoYu[2583:584940] productID:()2018-07-21 16:29:25.296263+0800 NiuWaJiaoYu[2583:584940] 产品付费数量:12018-07-21 16:29:25.296341+0800 NiuWaJiaoYu[2583:584940] [pro description] &lt;SKProduct: 0x170200040&gt;2018-07-21 16:29:25.296438+0800 NiuWaJiaoYu[2583:584940] [pro localizedTitle] 牛娃课堂月会员2018-07-21 16:29:25.296530+0800 NiuWaJiaoYu[2583:584940] [pro localizedDescription] 购买此会员后，可以在接下来一个月的时间内免费使用牛娃课堂所有学习资源。2018-07-21 16:29:25.296655+0800 NiuWaJiaoYu[2583:584940] [pro price] 15982018-07-21 16:29:25.296705+0800 NiuWaJiaoYu[2583:584940] [pro productIdentifier] com.NiuWa.niuwaketang_yue2018-07-21 16:29:25.296818+0800 NiuWaJiaoYu[2583:584940] 商品添加进列表 com.NiuWa.niuwaketang_yue2018-07-21 16:29:25.299607+0800 NiuWaJiaoYu[2583:584940] =====================产品信息==================2018-07-21 16:29:25.299747+0800 NiuWaJiaoYu[2583:584940] ------------- 请求对应的产品信息完毕--&lt;SKProductsRequest: 0x174432480&gt; --------------2018-07-21 16:29:29.770250+0800 NiuWaJiaoYu[2583:584940] [Harpy]: Please make sure that you have set _presentationViewController before calling checkVersion, checkVersionDaily, or checkVersionWeekly.2018-07-21 16:29:32.144827+0800 NiuWaJiaoYu[2583:584940] [Harpy]: Please make sure that you have set _presentationViewController before calling checkVersion, checkVersionDaily, or checkVersionWeekly.2018-07-21 16:29:32.870369+0800 NiuWaJiaoYu[2583:584940] 交易完成 com.NiuWa.niuwaketang_yue2018-07-21 16:29:32.870486+0800 NiuWaJiaoYu[2583:584940] 交易结束,验证票据信息2018-07-21 16:29:35.997449+0800 NiuWaJiaoYu[2583:584940] 拿到票据信息向苹果服务器验证： 请求链接：https://sandbox.itunes.apple.com/verifyReceipt, 请求头信息：&#123;&#125;, 请求Method：POST, 请求Body: &#123;\"receipt-data\":\"MIIomAYJKoZIhvcNAQcCoIIoiTCCKIUCAQExCzAJBgUrDgMCGgUAMIIYOQYJKoZIhvcNAQcBoIIYKgSCGCYxghgiMAoCAQgCAQEEAhYAMAoCARQCAQEEAgwAMAsCAQECAQEEAwIBADALAgELAgEBBAMCAQAwCwIBDgIBAQQDAgFrMAsCAQ8CAQEEAwIBADALAgEQAgEBBAMCAQAwCwIBGQIBAQQDAgEDMAwCAQoCAQEEBBYCNCswDQIBDQIBAQQFAgMBh88wDQIBEwIBAQQFDAMxLjAwDgIBCQIBAQQGAgRQMjUwMBgCAQICAQEEEAwOY29tLm5pdXdhLmlwYWQwGAIBAwIBAQQQDA4yMDE4MDMxNTEwMjE1NTAYAgEEAgECBBB7PLpH6Z\\/pOfQeVikMoYe3MBsCAQACAQEEEwwRUHJvZHVjdGlvblNhbmRib3gwHAIBBQIBAQQU4I0JGhOO5ZGf5WnQHsj0Tu5hle8wHgIBDAIBAQQWFhQyMDE4LTA3LTIxVDA4OjI5OjMyWjAeAgESAgEBBBYWFDIwMTMtMDgtMDFUMDc6MDA6MDBaMEgCAQYCAQEEQBnfPN4Gyd3ojT7k+xTs7nQyCmfs\\/kXep9X+eOFlzcr66F\\/iZTc5dh31ejK0YTxvksuvLCFyJ8lrH\\/kceHxnnxcwSgIBBwIBAQRCYr6RiZfopSC4\\/wQoo0nUHRSYXCxiQgCdUkHp9iITsaOCKx\\/7lVuPPsRRw6+Q3shOBnL9rQW4xHsStSmJOGfj0eLMMIIBXQIBEQIBAQSCAVMxggFPMAsCAgasAgEBBAIWADALAgIGrQIBAQQ2018-07-21 16:29:38.168848+0800 NiuWaJiaoYu[2583:585724] ----验证结果 &#123; environment = Sandbox; receipt = &#123; \"adam_id\" = 0; \"app_item_id\" = 0; \"application_version\" = 20180315102155; \"bundle_id\" = \"com.niuwa.ipad\"; \"download_id\" = 0; \"in_app\" = ( &#123; \"is_trial_period\" = false; \"original_purchase_date\" = \"2018-03-22 04:20:37 Etc/GMT\"; \"original_purchase_date_ms\" = 1521692437000; \"original_purchase_date_pst\" = \"2018-03-21 21:20:37 America/Los_Angeles\"; \"original_transaction_id\" = 1000000384329524; \"product_id\" = \"com.NiuWa.niuwaketang_ji\"; \"purchase_date\" = \"2018-03-22 04:20:37 Etc/GMT\"; \"purchase_date_ms\" = 1521692437000; \"purchase_date_pst\" = \"2018-03-21 21:20:37 America/Los_Angeles\"; quantity = 1; \"transaction_id\" = 1000000384329524; &#125;, &#123; \"is_trial_ 9、拿到票据信息向苹果服务器做验证的状态码 iOS IAP 掉单处理 有哪些请况会发生掉单： 1、在 ApplePay 付款成功后由于网络或各种原因没有返回 Transaction（SKPaymentTransaction),从而不能得到凭证去 Apple 服务器验证订单的正确性。 2、苹果服务器成功返回了 Transaction,但是在 APP 在上传凭证给服务器时发生了网络或各种原因，造成了凭证的丢失，产生了掉单（用户付了款却没有得到相应的商品） 解决方案 [SKPaymentQueue defaultQueue]这个队列里面存着所有的已支付，未支付的订单，而且需要手动移除，而 APP 每次启动的时候都会去判断这个队列里面是否为空，如果不为空的话会调用代理的 // 此函数回调队列中所有订单信息 (void)paymentQueue:(SKPaymentQueue _)queue updatedTransactions:(NSArray *)transactions 所以我们可以把 AppDelegate 设置成这个协议的代理并实现这个方法，当然我一般是会写一个遵循的工具类单例，毕竟协议是一对一的，不管是哪里的支付回调，都只走这个类，统一处理。 移除代码： [[SKPaymentQueue defaultQueue]finishTransaction:transaction] 当我们创建苹果订单初始化 SKPayment 时我们应该使用 SKMutablePayment,这个类里面有一个参数叫 applicationUsername 的成员变量，我们可以把后台服务器的订单号写到这里，在付款成功后返回的 SKPaymentTransaction 里面能拿到这个参数，然后就带着它去请求本地服务器 1CDDLog(@&quot;=====订单号%@&quot;,tran.payment.applicationUsername); 附：苹果官方内购验证文档","categories":[{"name":"移动端","slug":"移动端","permalink":"https://www.cqzhong.cn/categories/移动端/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.cqzhong.cn/tags/iOS/"},{"name":"苹果内购","slug":"苹果内购","permalink":"https://www.cqzhong.cn/tags/苹果内购/"}]},{"title":"pop动画","slug":"pop动画","date":"2018-06-30T06:04:11.000Z","updated":"2020-11-03T10:21:35.559Z","comments":true,"path":"2018/06/30/pop动画/","link":"","permalink":"https://www.cqzhong.cn/2018/06/30/pop动画/","excerpt":"pod 'pop', '~&gt; 1.0.12'","text":"pod 'pop', '~&gt; 1.0.12' kPOPViewScaleXY 123456POPBasicAnimation *basicAnimation=[POPBasicAnimation animationWithPropertyNamed:kPOPViewScaleXY]; basicAnimation.fromValue = [NSValue valueWithCGSize:CGSizeMake(0.8, 0.8)]; basicAnimation.toValue = [NSValue valueWithCGSize:CGSizeMake(1.3, 1.3)];//1.3倍; basicAnimation.duration = 1; //设置动画的间隔时间 默认是0.4秒 basicAnimation.repeatCount=9999;//HUGE_VALF; //重复次数 HUGE_VALF设置为无限次重复 [_handImgView pop_addAnimation:basicAnimation forKey:@\"basicAnimationKey\"];//执行动画 kPOPViewFrame] 1234567891011121314POPBasicAnimation *pathAnim = [POPBasicAnimation animationWithPropertyNamed:kPOPViewFrame]; pathAnim.toValue = [NSValue valueWithCGRect:CGRectMake((SCREEN_WIDTH - 57)/2.f, (SCREEN_HEIGHT - 216)/2.f, 57.f, 216.f)]; [pathAnim setCompletionBlock:^(POPAnimation *anim, BOOL finished) &#123; // [weakSelf.clickScrollImgView setImage:UIImageMake(@\"guid_bgScroll\")]; // weakSelf.clickScrollImgView.transform = CGAffineTransformMakeRotation(AngleWithDegrees(78)); [_clickScrollImgView removeFromSuperview]; _clickScrollImgView = nil; [weakSelf addSubview:self.bgScrollView]; [weakSelf.bgScrollView showAScrollAction]; &#125;]; pathAnim.duration = 0.35f; [weakSelf.clickScrollImgView pop_addAnimation:pathAnim forKey:@\"pathAnim\"]; kPOPViewCenter 12345678POPBasicAnimation *pathAnim = [POPBasicAnimation animationWithPropertyNamed:kPOPViewCenter]; pathAnim.toValue = [NSValue valueWithCGPoint:self.center]; [pathAnim setCompletionBlock:^(POPAnimation *anim, BOOL finished) &#123; &#125;]; pathAnim.duration = 1.f; [_clickScrollImgView pop_addAnimation:pathAnim forKey:@\"pathAnim\"]; 数字动画 12345678910111213141516171819202122232425262728#pragma mark - Private Method- (void)numeralBeatingAnim:(NSString *)balance &#123; POPAnimatableProperty *prop = [POPAnimatableProperty propertyWithName:@\"money\" initializer:^(POPMutableAnimatableProperty *prop) &#123; prop.writeBlock = ^(id obj, const CGFloat values[]) &#123; UILabel *label = (UILabel *)obj; @autoreleasepool &#123; NSNumberFormatter *formatter = [[NSNumberFormatter alloc] init]; [formatter setNumberStyle:NSNumberFormatterNoStyle]; [formatter setFormatWidth:9]; [formatter setPositiveFormat:@\",##0\"]; NSString *titleStr = [NSString stringWithFormat:@\"%.@\",[formatter stringFromNumber:@(values[0])]]; [label setText:titleStr]; &#125; &#125;; //力学阀值,值越大writeBlock的调用次数越少 prop.threshold = 1; &#125;]; POPBasicAnimation *anBasic = [POPBasicAnimation easeInEaseOutAnimation]; anBasic.property = prop; anBasic.fromValue = @(0.00); anBasic.toValue = @([balance integerValue]); anBasic.duration = 1.4f; [_balanceLabel pop_addAnimation:anBasic forKey:@\"money\"];&#125; 属性 12345678910111213141516171819202122232425262728293031323334353637383940NSString * const kPOPLayerBackgroundColor = @\"backgroundColor\"; //背景色NSString * const kPOPLayerBounds = @\"bounds\"; //坐标NSString * const kPOPLayerCornerRadius = @\"cornerRadius\"; //圆形 值越大,角就越圆NSString * const kPOPLayerBorderWidth = @\"borderWidth\"; //边框宽度NSString * const kPOPLayerBorderColor = @\"borderColor\"; //边框色NSString * const kPOPLayerOpacity = @\"opacity\"; //透明度NSString * const kPOPLayerPosition = @\"position\"; //位置 position是相对于屏幕的NSString * const kPOPLayerPositionX = @\"positionX\";NSString * const kPOPLayerPositionY = @\"positionY\";NSString * const kPOPLayerRotation = @\"rotation\"; //旋转NSString * const kPOPLayerRotationX = @\"rotationX\";NSString * const kPOPLayerRotationY = @\"rotationY\";NSString * const kPOPLayerScaleX = @\"scaleX\"; //缩放系数NSString * const kPOPLayerScaleXY = @\"scaleXY\"; //XY缩放系数NSString * const kPOPLayerScaleY = @\"scaleY\"; //Y缩放系数NSString * const kPOPLayerSize = @\"size\"; //大小NSString * const kPOPLayerSubscaleXY = @\"subscaleXY\";NSString * const kPOPLayerSubtranslationX = @\"subtranslationX\";NSString * const kPOPLayerSubtranslationXY = @\"subtranslationXY\";NSString * const kPOPLayerSubtranslationY = @\"subtranslationY\";NSString * const kPOPLayerSubtranslationZ = @\"subtranslationZ\";NSString * const kPOPLayerTranslationX = @\"translationX\"; //X轴平移量NSString * const kPOPLayerTranslationXY = @\"translationXY\"; //XY轴平移量NSString * const kPOPLayerTranslationY = @\"translationY\"; //Y轴平移量NSString * const kPOPLayerTranslationZ = @\"translationZ\"; //Z轴平移量NSString * const kPOPLayerZPosition = @\"zPosition\"; //遮挡属性NSString * const kPOPLayerShadowColor = @\"shadowColor\"; //设置阴影NSString * const kPOPLayerShadowOffset = @\"shadowOffset\"; //阴影偏移NSString * const kPOPLayerShadowOpacity = @\"shadowOpacity\"; //阴影透明度NSString * const kPOPLayerShadowRadius = @\"shadowRadius\"; //阴影半径// CAShapeLayerNSString * const kPOPShapeLayerStrokeStart = @\"shapeLayer.strokeStart\";//strokeStart 动画的fromValue = 0，toValue = 1 表示从路径的0位置画到1 怎么画是按照清除开始的位置也就是清除0 一直清除到1 效果就是一条路径慢慢的消失 strokeStart 动画的fromValue = 1，toValue = 0 表示从路径的1位置画到0 怎么画是按照清除开始的位置也就是1 这样开始的路径是空的（即都被清除掉了）一直清除到0 效果就是一条路径被反方向画出来NSString * const kPOPShapeLayerStrokeEnd = @\"shapeLayer.strokeEnd\";// strokeEnd 动画的fromValue = 0，toValue = 1 表示 这里我们分3个点说明动画的顺序 strokeEnd从结尾开始清除 首先整条路径先清除后2/3，接着清除1/3 效果就是正方向画出路径 strokeEnd 动画的fromValue = 1，toValue = 0 效果就是反方向路径慢慢消失NSString * const kPOPShapeLayerStrokeColor = @\"shapeLayer.strokeColor\"; //画笔的色NSString * const kPOPShapeLayerFillColor = @\"shapeLayer.fillColor\";NSString * const kPOPShapeLayerLineWidth = @\"shapeLayer.lineWidth\"; //线的宽度NSString * const kPOPShapeLayerLineDashPhase = @\"shapeLayer.lineDashPhase\";复制代码","categories":[{"name":"移动端","slug":"移动端","permalink":"https://www.cqzhong.cn/categories/移动端/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.cqzhong.cn/tags/iOS/"}]},{"title":"UITextView自定义复制分享功能","slug":"UITextView自定义复制分享功能","date":"2018-06-13T13:41:04.000Z","updated":"2020-11-03T10:21:35.526Z","comments":true,"path":"2018/06/13/UITextView自定义复制分享功能/","link":"","permalink":"https://www.cqzhong.cn/2018/06/13/UITextView自定义复制分享功能/","excerpt":"自定义 UIMenuController，实现下图效果","text":"自定义 UIMenuController，实现下图效果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586@interface CDRichTextView : UITextView-(UIViewController *)cd_viewController;@end#import \"CDRichTextView.h\"#define kRootViewController [UIApplication sharedApplication].keyWindow.rootViewController@implementation CDRichTextView- (instancetype)initWithFrame:(CGRect)frame &#123; if (self = [super initWithFrame:frame]) &#123; [self setEditable:false]; self.scrollEnabled = false; self.textAlignment = NSTextAlignmentJustified; // self.textContainer.lineFragmentPadding = 0.0;// self.textContainer.lineBreakMode = NSLineBreakByTruncatingTail; CGFloat padding = self.textContainer.lineFragmentPadding; self.textContainerInset = UIEdgeInsetsMake(-padding, 0, 2*padding + 1, 0); &#125; return self;&#125;- (BOOL)canBecomeFirstResponder &#123; return true;&#125;- (BOOL)canPerformAction:(SEL)action withSender:(id)sender &#123; UIMenuController *menuController = [UIMenuController sharedMenuController]; UIMenuItem *copyItem = [[UIMenuItem alloc] initWithTitle:@\"复制\" action:@selector(copyEvent:)]; UIMenuItem *sahreItem = [[UIMenuItem alloc] initWithTitle:@\"分享\" action:@selector(shareEvent:)]; menuController.menuItems = @[copyItem, sahreItem]; return (action == @selector(copyEvent:) || action == @selector(shareEvent:));&#125;- (void)copyEvent:(id)sender &#123; [self copy:sender];&#125;- (void)shareEvent:(id)sender &#123; NSString *content = [self.attributedText.string substringWithRange:self.selectedRange]; if (content.length == 0) return; UIActivityViewController *activityVC = [[UIActivityViewController alloc]initWithActivityItems:@[content] applicationActivities:nil]; activityVC.excludedActivityTypes = @[UIActivityTypeAirDrop]; activityVC.completionWithItemsHandler = ^(NSString *activityType,BOOL completed,NSArray *returnedItems,NSError *activityError) &#123; CDDLog(@\"activityType :%@\", activityType);// activityVC = nil; if (completed) &#123; CDDLog(@\"completed\"); &#125; else &#123; CDDLog(@\"cancel\"); &#125; &#125;; [self.cd_viewController presentViewController:activityVC animated:true completion:^&#123; &#125;];&#125;-(UIViewController *)cd_viewController &#123; id responder = self; while (responder)&#123; if ([responder isKindOfClass:[UIViewController class]])&#123; return responder; &#125; responder = [responder nextResponder]; &#125; return nil;&#125;@end","categories":[{"name":"移动端","slug":"移动端","permalink":"https://www.cqzhong.cn/categories/移动端/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.cqzhong.cn/tags/iOS/"}]},{"title":"FOUNDATION_EXTERN、UIKIT_EXTERN、extern","slug":"FOUNDATION_EXTERN、UIKIT_EXTERN、extern","date":"2018-05-30T06:04:11.000Z","updated":"2020-11-03T10:21:35.898Z","comments":true,"path":"2018/05/30/FOUNDATION_EXTERN、UIKIT_EXTERN、extern/","link":"","permalink":"https://www.cqzhong.cn/2018/05/30/FOUNDATION_EXTERN、UIKIT_EXTERN、extern/","excerpt":"FOUNDATION_EXTERN 是可以兼容 C++的 extern 的宏","text":"FOUNDATION_EXTERN 是可以兼容 C++的 extern 的宏 FOUNDATION_EXPORT FOUNDATION_IMPORT 这两个是用来兼容 win32 应用程序的，当然这个宏我们在 iOS 编程中一般是很少用到的 FOUNDATION_EXTERN 是在 Foundation 框架里面 NSObjCRuntime.h 中定义的。 NSString 是在 Foundation 框架里面 NSString.h 中定义的。 所以用 FOUNDATION_EXTERN 修饰 NSString。 使用： FOUNDATION_EXTERN NSString *const CDRequestKeyVersion; NSString *const CDRequestKeyVersion = @“v2/”; UIKIT_EXTERN,是经过处理的 extern。 简单来说：就是将函数修饰为兼容以往 C 编译方式的、具有 extern 属性(文件外可见性)、public 修饰的方法或变量库外仍可见的属性。 UIKIT_EXTERN 是在 UIKit 框架里面 UIKitDefines.h 中定义的。 CGFloat 在 CoreGraphics 框架里面 CGBase.h 中定义的。 用 UIKIT_EXTERN 修饰 CGFloat。 NSInteger 是在 usr/include 框架里面 NSObjCRuntime.h 中定义的。 用 UIKIT_EXTERN 修饰 NSInteger。 使用： UIKIT_EXTERN const CGFloat MJRefreshLabelLeftInset; const CGFloat MJRefreshLabelLeftInset = 25; extern 可以在多处声明，但是只能在一处实现 extern extern const CGFloat QMUIImagePreviewViewControllerCornerR adiusAutomaticDimension; const CGFloat QMUIImagePreviewViewControllerCornerRadiusAutomaticDimension = -1;","categories":[{"name":"移动端","slug":"移动端","permalink":"https://www.cqzhong.cn/categories/移动端/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.cqzhong.cn/tags/iOS/"}]},{"title":"iOS以multipart/form-data形式上传文件","slug":"iOS以multipart!form-data形式上传文件","date":"2018-04-28T13:42:05.000Z","updated":"2020-11-03T10:21:35.889Z","comments":true,"path":"2018/04/28/iOS以multipart!form-data形式上传文件/","link":"","permalink":"https://www.cqzhong.cn/2018/04/28/iOS以multipart!form-data形式上传文件/","excerpt":"这里以 YTKRequest 为例， boundary 仅作分割参数作用，越复杂越好，其余无要求","text":"这里以 YTKRequest 为例， boundary 仅作分割参数作用，越复杂越好，其余无要求 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133- (NSURLRequest *)buildCustomUrlRequest &#123; NSMutableData *body = [NSMutableData data]; NSString *BOUNDARY = @\"0xKhTmLbOuNdArY\"; /** 遍历字典将字典中的键值对转换成请求格式: --Boundary+72D4CD655314C423 Content-Disposition: form-data; name=\"empId\" 254 --Boundary+72D4CD655314C423 Content-Disposition: form-data; name=\"shopId\" 18718 */ //表单数据 param [self.params enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123; NSMutableString *fieldStr = [NSMutableString string]; [fieldStr appendString:[NSString stringWithFormat:@\"--%@\\r\\n\", BOUNDARY]]; [fieldStr appendString:[NSString stringWithFormat:@\"Content-Disposition: form-data; name=\\\"%@\\\"\\r\\n\\r\\n\", key]]; [fieldStr appendString:[NSString stringWithFormat:@\"%@\", obj]]; NSLog(@\"file=====%@\",fieldStr); [body appendData:[fieldStr dataUsingEncoding:NSUTF8StringEncoding]];// [body appendData:[obj dataUsingEncoding:NSUTF8StringEncoding]];// NSData *data = [NSKeyedArchiver archivedDataWithRootObject:obj];// [body appendData:data]; [body appendData:[@\"\\r\\n\" dataUsingEncoding:NSUTF8StringEncoding]]; &#125;]; //文件逻辑 for (NSDictionary *fileDictionary in self.imageDictionaryArray) &#123; NSString *fileName = fileDictionary[photoImageNameTag]; UIImage *image = fileDictionary[photoImageTag]; NSData *data = UIImageJPEGRepresentation(image, 0.5); NSString *name = BimImageGuidName; NSString *type = @\"image\"; NSString *param = [NSString stringWithFormat:@\"--%@\\r\\nContent-Disposition: form-data; name=\\\"%@\\\";filename=\\\"%@\\\"\\r\\nContent-Type: application/octet-stream\\r\\n\\r\\n\",BOUNDARY,[NSString stringWithFormat:@\"%@%@\",name,type],fileName,nil]; [body appendData:[param dataUsingEncoding:NSUTF8StringEncoding]]; [body appendData:data]; [body appendData:[@\"\\r\\n\" dataUsingEncoding:NSUTF8StringEncoding]]; &#125; for (NSDictionary *fileDictionary in self.amrDictionaryArray) &#123; NSString *filePath = fileDictionary[recordPathTag]; NSString *fileName = [NSString stringWithFormat:@\"%@.amr\",fileDictionary[recordNameTag]]; NSData *data = [[NSData alloc]initWithContentsOfURL:[NSURL fileURLWithPath:filePath]]; NSString *name = BIMAmrGuidName; NSString *type = @\"amr\"; NSString *param = [NSString stringWithFormat:@\"--%@\\r\\nContent-Disposition: form-data; name=\\\"%@\\\";filename=\\\"%@\\\"\\r\\nContent-Type: application/octet-stream\\r\\n\\r\\n\",BOUNDARY,[NSString stringWithFormat:@\"%@%@\",name,type],fileName,nil]; [body appendData:[param dataUsingEncoding:NSUTF8StringEncoding]]; [body appendData:data]; [body appendData:[@\"\\r\\n\" dataUsingEncoding:NSUTF8StringEncoding]]; &#125; NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:[NSString stringWithFormat:@\"%@%@\",[YTKNetworkConfig sharedConfig].baseUrl,self.requestUrl]]]; NSString *endString = [NSString stringWithFormat:@\"--%@--\",BOUNDARY]; [body appendData:[endString dataUsingEncoding:NSUTF8StringEncoding]]; [request setHTTPBody:body]; // 设置请求类型为post请求 request.HTTPMethod = @\"post\"; // 设置request的请求体 request.HTTPBody = body; // 设置头部数据，标明上传数据总大小，用于服务器接收校验 [request setValue:@(body.length).stringValue forHTTPHeaderField:@\"Content-Length\"]; [request setValue:[BIMSQLiteManager manager].cookieToken forHTTPHeaderField:BIMRequestKeyCookie]; // 设置头部数据，指定了http post请求的编码方式为multipart/form-data（上传文件必须用这个）。 [request setValue:[NSString stringWithFormat:@\"multipart/form-data; boundary=%@\",BOUNDARY] forHTTPHeaderField:@\"Content-Type\"]; //token 放请求头// [request setValue:@\"\" forHTTPHeaderField:@\"Authorization\"]; return request;&#125;","categories":[{"name":"移动端","slug":"移动端","permalink":"https://www.cqzhong.cn/categories/移动端/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.cqzhong.cn/tags/iOS/"}]},{"title":"AVPlayer搭配FBKVOController使用","slug":"AVPlayer搭配FBKVOController使用","date":"2018-03-29T11:26:04.000Z","updated":"2020-11-03T10:21:35.919Z","comments":true,"path":"2018/03/29/AVPlayer搭配FBKVOController使用/","link":"","permalink":"https://www.cqzhong.cn/2018/03/29/AVPlayer搭配FBKVOController使用/","excerpt":"1、导入 123#import &lt;AVKit/AVKit.h&gt;#import &lt;AVFoundation/AVFoundation.h&gt;#import &lt;KVOController/KVOController.h&gt;","text":"1、导入 123#import &lt;AVKit/AVKit.h&gt;#import &lt;AVFoundation/AVFoundation.h&gt;#import &lt;KVOController/KVOController.h&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116@property (nonatomic, strong) AVPlayer *player;@property (nonatomic, strong) AVPlayerLayer *playerLayer;@property (nonatomic, strong) NSURL *playUrl;@property (nonatomic, strong) UIActivityIndicatorView *loadingView; [self addSubview:self.loadingView]; [self.loadingView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.center.equalTo(self); make.height.width.mas_offset(CDREALVALUE_HEIGHT(30.0)); &#125;]; // 播放器 self.playUrl = [NSURL URLWithString:model.pinyin_audio]; [self.layer addSublayer:self.playerLayer]; [self.player play]; self.playerLayer.frame = CGRectMake(0, 0, CDREALVALUE_HEIGHT(320), CDREALVALUE_WIDTH(180)); [self.loadingView startAnimating];// 获取播放器状态- (void)avPlayerItemStatus:(AVPlayerItemStatus)status &#123; switch (status) &#123; case AVPlayerItemStatusReadyToPlay: &#123; break; &#125; case AVPlayerItemStatusUnknown: &#123; break; &#125; case AVPlayerItemStatusFailed: &#123; break; &#125; default: break; &#125;&#125;// 播放完成- (void)didPlayToEnd &#123; // 播放完成并回到首帧 [self.player seekToTime:kCMTimeZero];&#125;// 释放播放器- (void)releasePlayer &#123; if (_player) &#123; [_player pause]; [_playerLayer removeFromSuperlayer]; [self.KVOController unobserveAll]; [[NSNotificationCenter defaultCenter] removeObserver:AVPlayerItemDidPlayToEndTimeNotification]; _player = nil; _playerLayer = nil; &#125;&#125;- (AVPlayer *)player &#123; if (!_player) &#123; _player = [[AVPlayer alloc] initWithURL:self.playUrl]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(didPlayToEnd) name:AVPlayerItemDidPlayToEndTimeNotification object:_player.currentItem];// _player.volume = 1; &#125; return _player;&#125;- (AVPlayerLayer *)playerLayer &#123; if (!_playerLayer) &#123; _playerLayer = [AVPlayerLayer playerLayerWithPlayer:self.player]; //AVLayerVideoGravityResizeAspect _playerLayer.videoGravity = AVLayerVideoGravityResizeAspectFill; @weakify(self); self.KVOController = [FBKVOController controllerWithObserver:self]; [self.KVOController observe:self.player.currentItem keyPath:@keypath(self.player.currentItem, status) options:NSKeyValueObservingOptionNew block:^(id _Nullable observer, id _Nonnull object, NSDictionary&lt;NSString *,id&gt; * _Nonnull change) &#123; @strongify(self); AVPlayerItemStatus state = [change[NSKeyValueChangeNewKey] integerValue]; [self avPlayerItemStatus:state]; &#125;]; [self.KVOController observe:self.player keyPath:@keypath(self.player, rate) options:NSKeyValueObservingOptionNew block:^(id _Nullable observer, id _Nonnull object, NSDictionary&lt;NSString *,id&gt; * _Nonnull change) &#123; @strongify(self); CGFloat rate = [change[NSKeyValueChangeNewKey] floatValue]; CDDLog(@\"rate: %.2f\", rate); if (rate &gt; 0.0) &#123; // 正在播放 [self.loadingView stopAnimating]; &#125; else &#123; // 暂停 [self.loadingView startAnimating]; &#125; &#125;]; &#125; return _playerLayer;&#125;- (UIActivityIndicatorView *)loadingView &#123; if (!_loadingView) &#123; _loadingView = [[UIActivityIndicatorView alloc] initWithActivityIndicatorStyle:UIActivityIndicatorViewStyleWhite]; _loadingView.hidesWhenStopped = true; &#125; return _loadingView;&#125;","categories":[{"name":"移动端","slug":"移动端","permalink":"https://www.cqzhong.cn/categories/移动端/"}],"tags":[{"name":"AVPlayer","slug":"AVPlayer","permalink":"https://www.cqzhong.cn/tags/AVPlayer/"},{"name":"iOS","slug":"iOS","permalink":"https://www.cqzhong.cn/tags/iOS/"}]},{"title":"iTunes安装（回退到有App Store）","slug":"iTunes安装（回退到有App Store）","date":"2018-03-21T03:46:52.000Z","updated":"2020-11-03T10:21:35.577Z","comments":true,"path":"2018/03/21/iTunes安装（回退到有App Store）/","link":"","permalink":"https://www.cqzhong.cn/2018/03/21/iTunes安装（回退到有App Store）/","excerpt":"1、退出 iTunes 2、使用终端强制删除","text":"1、退出 iTunes 2、使用终端强制删除 终端输入：sudo rm -rf /Applications/iTunes.app 回车， 3、删除错误文件 打开 Finder，搜索 iTunes 文件(可能存在相同文件夹，右键 iTunes 文件夹选择“在上层文件夹显示”，找到根文件夹为音乐文件夹的 iTunes 文件，删除下图中选中的文件)，如下图删除选中文件: [https://support.apple.com/kb/DL1934?viewlocale=zh_CN&amp;locale=zh_CN](https://support.apple.com/kb/DL1934?viewlocale=zh_CN&amp;locale=zh_CN) 补充 command+R 进入 recover 打开终端 csrutil disable csrutil enable 错误参考；[https://apple.stackexchange.com/questions/299842/how-to-fix-itunes-error-45076](https://apple.stackexchange.com/questions/299842/how-to-fix-itunes-error-45076) 1234567891011121314151617sudo rm -rf /Library/Documentation/Applications/iTunes/Acknowledgements.rtfsudo rm -rf /Library/Documentation/iPod/Acknowledgements.rtfsudo rm -rf /Library/Frameworks/iTunesLibrary.framework/sudo rm -rf /Applications/iTunes.app/sudo rm -rf /System/Library/PrivateFrameworks/iTunesAccess.framework/sudo rm -rf /System/Library/LaunchDaemons/com.apple.fpsd.plistsudo rm -rf /System/Library/PrivateFrameworks/CoreFP.framework/sudo rm -rf /System/Library/PrivateFrameworks/CoreADI.framework/sudo rm -rf /System/Library/LaunchDaemons/com.apple.adid.plistsudo rm -rf /System/Library/CoreServices/UAUPlugins/ADIUserAccountUpdater.bundle/sudo rm -rf /System/Library/CoreServices/CoreTypes.bundle/Contents/Library/MobileDevices.bundle/sudo rm -rf /System/Library/LaunchDaemons/com.apple.usbmuxd.plistsudo rm -rf /System/Library/PrivateFrameworks/AirTrafficHost.framework/sudo rm -rf /System/Library/PrivateFrameworks/DeviceLink.framework/sudo rm -rf /System/Library/PrivateFrameworks/MobileDevice.framework/sudo rm -rf /System/Library/Extensions/AppleMobileDevice.kext/sudo rm -rf /System/Library/Extensions/AppleUsbEthernetHost","categories":[{"name":"其它","slug":"其它","permalink":"https://www.cqzhong.cn/categories/其它/"}],"tags":[{"name":"iTunes","slug":"iTunes","permalink":"https://www.cqzhong.cn/tags/iTunes/"}]},{"title":"App多环境配置","slug":"App多环境配置","date":"2018-03-06T03:46:52.000Z","updated":"2020-11-03T10:21:35.752Z","comments":true,"path":"2018/03/06/App多环境配置/","link":"","permalink":"https://www.cqzhong.cn/2018/03/06/App多环境配置/","excerpt":"1、project 里 Configurations 增加环境","text":"1、project 里 Configurations 增加环境 2、project 里 build settings 里 Preprocessor Macros 里的 value 里修改名字 3、target 里 build settings 里 Preprocessor Macros 再设置下环境名字 4、target 里 build settings 里 点击+按钮增加一个宏 BUNDLE_DISPLAY_NAME 在里面给不同环境，设置不同名字 最后在 info 里 Bundle display name 设置名字 ${BUNDLE_DISPLAY_NAME} 5、target 里 build settings 里 Asset Catalog App Icon Set Name 给不同环境设置不同 icon","categories":[{"name":"移动端","slug":"移动端","permalink":"https://www.cqzhong.cn/categories/移动端/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.cqzhong.cn/tags/iOS/"}]},{"title":"iOS 计算两点距离、点间角度、线间角度","slug":"iOS 计算两点距离、点间角度、线间角度","date":"2018-03-05T03:46:52.000Z","updated":"2020-11-03T10:21:35.912Z","comments":true,"path":"2018/03/05/iOS 计算两点距离、点间角度、线间角度/","link":"","permalink":"https://www.cqzhong.cn/2018/03/05/iOS 计算两点距离、点间角度、线间角度/","excerpt":"1、如果枚举没有&lt;&lt;就不能组合使用","text":"1、如果枚举没有&lt;&lt;就不能组合使用 12345678910111213141516171819202122232425261 &lt;&lt; n 代表:2的n次方://1 &lt;&lt; 16 代表:2的16次方 UIControlEventEditingDidBegin = 1 &lt;&lt; 16,//1 &lt;&lt; 17 代表:2的17次方 UIControlEventEditingChanged = 1 &lt;&lt; 17,//1 &lt;&lt; 18 代表:2的18次方 UIControlEventEditingDidEnd = 1 &lt;&lt; 18,//1 &lt;&lt; 19 代表:2的19次方 UIControlEventEditingDidEndOnExit = 1 &lt;&lt; 19, 原来这样的枚举可以组合使用, 那苹果官方是怎么知道我们多个条件组合使用了呢 ? NSUInteger controlEvents = UIControlEventEditingDidBegin | UIControlEventValueChanged | UIControlEventEditingDidEnd; /** //通过 &amp; 符号来判断是否包含: UIControlEventEditingDidBegin, UIControlEventValueChanged, UIControlEventEditingDidEnd */ if (controlEvents &amp; UIControlEventEditingDidBegin) &#123; NSLog(@\"UIControlEventEditingDidBegin\"); &#125;else if (controlEvents &amp; UIControlEventValueChanged) &#123; NSLog(@\"UIControlEventValueChanged\"); &#125;else if (controlEvents &amp; UIControlEventEditingDidEnd) &#123; NSLog(@\"UIControlEventEditingDidEnd\"); &#125; 2、iOS 计算两点距离、点间角度、线间角度 1234567891011121314151617181920212223242526272829#include &lt;math.h&gt;#define pi 3.14159265358979323846#define degreesToRadian(x) (pi * x / 180.0)#define radiansToDegrees(x) (180.0 * x / pi)CGFloat distanceBetweenPoints (CGPoint first, CGPoint second) &#123;CGFloat deltaX = second.x - first.x;CGFloat deltaY = second.y - first.y;return sqrt(deltaX*deltaX + deltaY*deltaY );&#125;;CGFloat angleBetweenPoints(CGPoint first, CGPoint second) &#123;CGFloat height = second.y - first.y;CGFloat width = first.x - second.x;CGFloat rads = atan(height/width);return radiansToDegrees(rads);//degs = degrees(atan((top - bottom)/(right - left)))&#125;CGFloat angleBetweenLines(CGPoint line1Start, CGPoint line1End, CGPoint line2Start, CGPoint line2End) &#123;CGFloat a = line1End.x - line1Start.x;CGFloat b = line1End.y - line1Start.y;CGFloat c = line2End.x - line2Start.x;CGFloat d = line2End.y - line2Start.y;CGFloat rads = acos(((a*c) + (b*d)) / ((sqrt(a*a + b*b)) * (sqrt(c*c + d*d))));return radiansToDegrees(rads);&#125;","categories":[{"name":"移动端","slug":"移动端","permalink":"https://www.cqzhong.cn/categories/移动端/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.cqzhong.cn/tags/iOS/"}]},{"title":"Git简单使用","slug":"Git简单使用","date":"2018-01-08T03:46:52.000Z","updated":"2020-11-03T10:21:35.723Z","comments":true,"path":"2018/01/08/Git简单使用/","link":"","permalink":"https://www.cqzhong.cn/2018/01/08/Git简单使用/","excerpt":"简易的命令行入门教程 Git 全局设置: 12git config --global user.name \"name\"git config --global user.email \"email@163.com\"","text":"简易的命令行入门教程 Git 全局设置: 12git config --global user.name \"name\"git config --global user.email \"email@163.com\" 创建 git 仓库: 12345678mkdir Privatefilecd Privatefilegit inittouch README.mdgit add README.mdgit commit -m \"first commit\"git remote add origin git@gitee.com:yao11.com/Privatefile.gitgit push -u origin master 已有项目? 123cd existing_git_repogit remote add origin git@gitee.com:yao11.com/Privatefile.gitgit push -u origin master Git 全局设置 12git config --global user.name \"cqz\"git config --global user.email \"cqz@ttsing.com\" 创建新版本库 123456git clone git@gitlab.ttsing.com:ios/CDFont.gitcd CDFonttouch README.mdgit add README.mdgit commit -m \"add README\"git push -u origin master 已存在的文件夹 123456cd existing_foldergit initgit remote add origin git@gitlab.ttsing.com:ios/CDFont.gitgit add .git commit -m \"Initial commit\"git push -u origin master 已存在的 Git 版本库 12345cd existing_repogit remote rename origin old-origingit remote add origin git@gitlab.ttsing.com:ios/CDFont.gitgit push -u origin --allgit push -u origin --tags 如何从码云 GIT 导入到 GitHubDeskTop 桌面工具。 先用命令行切换到本地的目录 使用 git clone 码云 GIT 地址 命令将项目克隆到本地。 在 GitHub Desktop 上添加(Add)本地项目(local path)。 在 GitHub Desktop 上尽情地提交、同步吧！ 如何将本地的项目上传到码云 GIT。 选择本地目录，在 GitHub Desktop 上添加本地项目。 在码云 GIT 上新建项目。 命令行使用 git remote add origin GIT 地址 将本地项目与码云 GIT 项目建立关系。 先使用命令 git pull origin master 同步代码。 使用命令 git push origin master 将本地代码推送到远程项目。 在 GitHub Desktop 上尽情地提交、同步吧！ 建立链接命令 1234ssh-addssh -T git@git.oschina.netssh -T git@gitlab.ttsing.net 第一步：成生 SSH 密钥 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647打开终端命令工具，输入命令：ssh-keygen -t rsa -C \"xxx@gmail.com\"注意ssh-keygen没有空格。屏幕输出：Generating public/private rsa key pair.Enter file in which to save the key (/Users/xxx/.ssh/id_rsa):xxx在上方输入生成的密钥文件名，xxx，屏幕输出：Enter passphrase (empty for no passphrase): 输入密码Enter same passphrase again: 确认密码Your identification has been saved in xxx.Your public key has been saved in xxx.pub.The key fingerprint is:25:fd:01:00:89:98:49:bf:2e:ac:32:2e:d2:5d:bf:98 xxx@gmail.comThe key's randomart image is:+--[ RSA 2048]----+| ..+ ..o... || +.. . . . || . . o . || . o . . || . S . || . . . || .o... . ||=.... o. ||*o E .. |+-----------------+屏幕提示生成密钥文件成功，保存在/Users/xxx。 第二步：把 xxx.pub 中的内容加入 git@osc 的 SSH 密钥中 第三步：添加 SSH 并连接 输入命令：ssh-add ~/xxx ~/xxx 是刚刚生成的密钥文件路径，屏幕输出： Enter passphrase for /Users/xxx/xxx:输入密码 Identity added: /Users/xxx /xxx (/Users/xxx /xxx) 输入命令 ssh -T git@git.oschina.net，屏幕输出： The authenticity of host ‘git.oschina.net (58.215.179.44)’ can’t be established. RSA key fingerprint is 14:b8:b8:0b:c2:b2:5e:ae:f2:21:f8:18:4d:3a:be:fc. Are you sure you want to continue connecting (yes/no)? yes（输入 yes），屏幕输出： Warning: Permanently added ‘git.oschina.net,58.215.179.44’ (RSA) to the list of known hosts. Welcome to Git@OSC , 老左! 错误解决 git pull origin master --allow-unrelated-histories git pull --rebase origin master git push -u origin master 回退为上次的版本 123456Last login: Thu Dec 6 19:32:45 on ttys000cao:~ caoqingzhong$ cd /Users/caoqingzhong/Desktop/GitLab/FamousTeacher/CDProgrammecao:CDProgramme caoqingzhong$ git reset --hard FETCH_HEADHEAD is now at ae6c1138 删除 .DS_Storecao:CDProgramme caoqingzhong$","categories":[{"name":"其它","slug":"其它","permalink":"https://www.cqzhong.cn/categories/其它/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.cqzhong.cn/tags/git/"}]},{"title":"strong、weak、assign和copy","slug":"strong、weak、assign和copy","date":"2018-01-05T01:20:00.000Z","updated":"2020-11-03T10:21:35.908Z","comments":true,"path":"2018/01/05/strong、weak、assign和copy/","link":"","permalink":"https://www.cqzhong.cn/2018/01/05/strong、weak、assign和copy/","excerpt":"说明并比较关键词：strong、weak、assign 和 copy","text":"说明并比较关键词：strong、weak、assign 和 copy strong 表示指向并拥有该对象。其修饰的对象引用计数会增加 1。该对象只要引用计数不为 0，就不会被销毁。当然，强行将其设为 nil 也可以销毁它。 weak 表示指向但不拥有该对象。其修饰的对象引用计数不会增加。无需手动设置，该对象会自行在内存中被销毁。 assign 主要用于修饰基本数据类型，如 NSInteger 和 CGFloat，这些数值主要存在栈中。 weak 一般用来修饰对象，assign 一般用来修饰基本数据类型。原因是 assign 修饰的对象被释放后，指针的地址依然存在，造成“野指针”，在堆上容易造成崩溃。而栈上的内存系统会自动处理，不会造成“野指针”。 copy 与 strong 类似。不同之处是，strong 的复制是多个指针指向同一个地址，而 copy 的复制是每次会在内存中复制一份对象，指针指向不同的地址。copy 一般用在修饰有对应可变类型的不可变对象上，如 NSString，NSArray，NSDictionary。 在 Objective-C 中，基本数据的默认你关键字是 atomic，readwrite 和 assign；普通属性的默认关键字是 atmoic，readwrite 和 strong。","categories":[{"name":"移动端","slug":"移动端","permalink":"https://www.cqzhong.cn/categories/移动端/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://www.cqzhong.cn/tags/iOS/"}]}]}